// Generated by jextract

package blis_typed;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct gemm_cntl_s {
 *     part_cntl_t part_jc;
 *     part_cntl_t part_pc;
 *     packm_def_cntl_t pack_b;
 *     part_cntl_t part_ic;
 *     packm_def_cntl_t pack_a;
 *     gemm_var_cntl_t ker;
 *     cntl_t ir_loop;
 * }
 * }
 */
public class gemm_cntl_s {

    gemm_cntl_s() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        part_cntl_s.layout().withName("part_jc"),
        part_cntl_s.layout().withName("part_pc"),
        packm_def_cntl_s.layout().withName("pack_b"),
        part_cntl_s.layout().withName("part_ic"),
        packm_def_cntl_s.layout().withName("pack_a"),
        gemm_var_cntl_s.layout().withName("ker"),
        cntl_s.layout().withName("ir_loop")
    ).withName("gemm_cntl_s");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final GroupLayout part_jc$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("part_jc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * part_cntl_t part_jc
     * }
     */
    public static final GroupLayout part_jc$layout() {
        return part_jc$LAYOUT;
    }

    private static final long part_jc$OFFSET = $LAYOUT.byteOffset(groupElement("part_jc"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * part_cntl_t part_jc
     * }
     */
    public static final long part_jc$offset() {
        return part_jc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * part_cntl_t part_jc
     * }
     */
    public static MemorySegment part_jc(MemorySegment struct) {
        return struct.asSlice(part_jc$OFFSET, part_jc$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * part_cntl_t part_jc
     * }
     */
    public static void part_jc(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, part_jc$OFFSET, part_jc$LAYOUT.byteSize());
    }

    private static final GroupLayout part_pc$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("part_pc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * part_cntl_t part_pc
     * }
     */
    public static final GroupLayout part_pc$layout() {
        return part_pc$LAYOUT;
    }

    private static final long part_pc$OFFSET = $LAYOUT.byteOffset(groupElement("part_pc"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * part_cntl_t part_pc
     * }
     */
    public static final long part_pc$offset() {
        return part_pc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * part_cntl_t part_pc
     * }
     */
    public static MemorySegment part_pc(MemorySegment struct) {
        return struct.asSlice(part_pc$OFFSET, part_pc$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * part_cntl_t part_pc
     * }
     */
    public static void part_pc(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, part_pc$OFFSET, part_pc$LAYOUT.byteSize());
    }

    private static final GroupLayout pack_b$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("pack_b"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * packm_def_cntl_t pack_b
     * }
     */
    public static final GroupLayout pack_b$layout() {
        return pack_b$LAYOUT;
    }

    private static final long pack_b$OFFSET = $LAYOUT.byteOffset(groupElement("pack_b"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * packm_def_cntl_t pack_b
     * }
     */
    public static final long pack_b$offset() {
        return pack_b$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * packm_def_cntl_t pack_b
     * }
     */
    public static MemorySegment pack_b(MemorySegment struct) {
        return struct.asSlice(pack_b$OFFSET, pack_b$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * packm_def_cntl_t pack_b
     * }
     */
    public static void pack_b(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, pack_b$OFFSET, pack_b$LAYOUT.byteSize());
    }

    private static final GroupLayout part_ic$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("part_ic"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * part_cntl_t part_ic
     * }
     */
    public static final GroupLayout part_ic$layout() {
        return part_ic$LAYOUT;
    }

    private static final long part_ic$OFFSET = $LAYOUT.byteOffset(groupElement("part_ic"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * part_cntl_t part_ic
     * }
     */
    public static final long part_ic$offset() {
        return part_ic$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * part_cntl_t part_ic
     * }
     */
    public static MemorySegment part_ic(MemorySegment struct) {
        return struct.asSlice(part_ic$OFFSET, part_ic$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * part_cntl_t part_ic
     * }
     */
    public static void part_ic(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, part_ic$OFFSET, part_ic$LAYOUT.byteSize());
    }

    private static final GroupLayout pack_a$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("pack_a"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * packm_def_cntl_t pack_a
     * }
     */
    public static final GroupLayout pack_a$layout() {
        return pack_a$LAYOUT;
    }

    private static final long pack_a$OFFSET = $LAYOUT.byteOffset(groupElement("pack_a"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * packm_def_cntl_t pack_a
     * }
     */
    public static final long pack_a$offset() {
        return pack_a$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * packm_def_cntl_t pack_a
     * }
     */
    public static MemorySegment pack_a(MemorySegment struct) {
        return struct.asSlice(pack_a$OFFSET, pack_a$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * packm_def_cntl_t pack_a
     * }
     */
    public static void pack_a(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, pack_a$OFFSET, pack_a$LAYOUT.byteSize());
    }

    private static final GroupLayout ker$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("ker"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gemm_var_cntl_t ker
     * }
     */
    public static final GroupLayout ker$layout() {
        return ker$LAYOUT;
    }

    private static final long ker$OFFSET = $LAYOUT.byteOffset(groupElement("ker"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gemm_var_cntl_t ker
     * }
     */
    public static final long ker$offset() {
        return ker$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gemm_var_cntl_t ker
     * }
     */
    public static MemorySegment ker(MemorySegment struct) {
        return struct.asSlice(ker$OFFSET, ker$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gemm_var_cntl_t ker
     * }
     */
    public static void ker(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, ker$OFFSET, ker$LAYOUT.byteSize());
    }

    private static final GroupLayout ir_loop$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("ir_loop"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * cntl_t ir_loop
     * }
     */
    public static final GroupLayout ir_loop$layout() {
        return ir_loop$LAYOUT;
    }

    private static final long ir_loop$OFFSET = $LAYOUT.byteOffset(groupElement("ir_loop"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * cntl_t ir_loop
     * }
     */
    public static final long ir_loop$offset() {
        return ir_loop$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * cntl_t ir_loop
     * }
     */
    public static MemorySegment ir_loop(MemorySegment struct) {
        return struct.asSlice(ir_loop$OFFSET, ir_loop$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * cntl_t ir_loop
     * }
     */
    public static void ir_loop(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, ir_loop$OFFSET, ir_loop$LAYOUT.byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

