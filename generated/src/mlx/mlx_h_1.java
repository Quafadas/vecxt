// Generated by jextract

package mlx;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

class mlx_h_1 extends mlx_h_shared {

    mlx_h_1() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()
            .or(Linker.nativeLinker().defaultLookup());

    private static final int FLT_HAS_SUBNORM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FLT_HAS_SUBNORM 1
     * }
     */
    public static int FLT_HAS_SUBNORM() {
        return FLT_HAS_SUBNORM;
    }
    private static final int DBL_HAS_SUBNORM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define DBL_HAS_SUBNORM 1
     * }
     */
    public static int DBL_HAS_SUBNORM() {
        return DBL_HAS_SUBNORM;
    }
    private static final int LDBL_HAS_SUBNORM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LDBL_HAS_SUBNORM 1
     * }
     */
    public static int LDBL_HAS_SUBNORM() {
        return LDBL_HAS_SUBNORM;
    }
    private static final int __bool_true_false_are_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __bool_true_false_are_defined 1
     * }
     */
    public static int __bool_true_false_are_defined() {
        return __bool_true_false_are_defined;
    }
    private static final int true_ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define true 1
     * }
     */
    public static int true_() {
        return true_;
    }
    private static final int false_ = (int)0L;
    /**
     * {@snippet lang=c :
     * #define false 0
     * }
     */
    public static int false_() {
        return false_;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int __has_safe_buffers = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __has_safe_buffers 1
     * }
     */
    public static int __has_safe_buffers() {
        return __has_safe_buffers;
    }
    private static final int __DARWIN_ONLY_64_BIT_INO_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_64_BIT_INO_T 1
     * }
     */
    public static int __DARWIN_ONLY_64_BIT_INO_T() {
        return __DARWIN_ONLY_64_BIT_INO_T;
    }
    private static final int __DARWIN_ONLY_UNIX_CONFORMANCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_UNIX_CONFORMANCE 1
     * }
     */
    public static int __DARWIN_ONLY_UNIX_CONFORMANCE() {
        return __DARWIN_ONLY_UNIX_CONFORMANCE;
    }
    private static final int __DARWIN_ONLY_VERS_1050 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_VERS_1050 1
     * }
     */
    public static int __DARWIN_ONLY_VERS_1050() {
        return __DARWIN_ONLY_VERS_1050;
    }
    private static final int __DARWIN_UNIX03 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_UNIX03 1
     * }
     */
    public static int __DARWIN_UNIX03() {
        return __DARWIN_UNIX03;
    }
    private static final int __DARWIN_64_BIT_INO_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_64_BIT_INO_T 1
     * }
     */
    public static int __DARWIN_64_BIT_INO_T() {
        return __DARWIN_64_BIT_INO_T;
    }
    private static final int __DARWIN_VERS_1050 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_VERS_1050 1
     * }
     */
    public static int __DARWIN_VERS_1050() {
        return __DARWIN_VERS_1050;
    }
    private static final int __DARWIN_NON_CANCELABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NON_CANCELABLE 0
     * }
     */
    public static int __DARWIN_NON_CANCELABLE() {
        return __DARWIN_NON_CANCELABLE;
    }
    private static final int __STDC_WANT_LIB_EXT1__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_WANT_LIB_EXT1__ 1
     * }
     */
    public static int __STDC_WANT_LIB_EXT1__() {
        return __STDC_WANT_LIB_EXT1__;
    }
    private static final int __DARWIN_NO_LONG_LONG = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NO_LONG_LONG 0
     * }
     */
    public static int __DARWIN_NO_LONG_LONG() {
        return __DARWIN_NO_LONG_LONG;
    }
    private static final int _DARWIN_FEATURE_64_BIT_INODE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_64_BIT_INODE 1
     * }
     */
    public static int _DARWIN_FEATURE_64_BIT_INODE() {
        return _DARWIN_FEATURE_64_BIT_INODE;
    }
    private static final int _DARWIN_FEATURE_ONLY_64_BIT_INODE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_ONLY_64_BIT_INODE 1
     * }
     */
    public static int _DARWIN_FEATURE_ONLY_64_BIT_INODE() {
        return _DARWIN_FEATURE_ONLY_64_BIT_INODE;
    }
    private static final int _DARWIN_FEATURE_ONLY_VERS_1050 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_ONLY_VERS_1050 1
     * }
     */
    public static int _DARWIN_FEATURE_ONLY_VERS_1050() {
        return _DARWIN_FEATURE_ONLY_VERS_1050;
    }
    private static final int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE 1
     * }
     */
    public static int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE() {
        return _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE;
    }
    private static final int _DARWIN_FEATURE_UNIX_CONFORMANCE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_UNIX_CONFORMANCE 3
     * }
     */
    public static int _DARWIN_FEATURE_UNIX_CONFORMANCE() {
        return _DARWIN_FEATURE_UNIX_CONFORMANCE;
    }
    private static final int __has_ptrcheck = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __has_ptrcheck 0
     * }
     */
    public static int __has_ptrcheck() {
        return __has_ptrcheck;
    }
    private static final int USE_CLANG_TYPES = (int)0L;
    /**
     * {@snippet lang=c :
     * #define USE_CLANG_TYPES 0
     * }
     */
    public static int USE_CLANG_TYPES() {
        return USE_CLANG_TYPES;
    }
    private static final int __PTHREAD_SIZE__ = (int)8176L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_SIZE__ 8176
     * }
     */
    public static int __PTHREAD_SIZE__() {
        return __PTHREAD_SIZE__;
    }
    private static final int __PTHREAD_ATTR_SIZE__ = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_ATTR_SIZE__ 56
     * }
     */
    public static int __PTHREAD_ATTR_SIZE__() {
        return __PTHREAD_ATTR_SIZE__;
    }
    private static final int __PTHREAD_MUTEXATTR_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEXATTR_SIZE__ 8
     * }
     */
    public static int __PTHREAD_MUTEXATTR_SIZE__() {
        return __PTHREAD_MUTEXATTR_SIZE__;
    }
    private static final int __PTHREAD_MUTEX_SIZE__ = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEX_SIZE__ 56
     * }
     */
    public static int __PTHREAD_MUTEX_SIZE__() {
        return __PTHREAD_MUTEX_SIZE__;
    }
    private static final int __PTHREAD_CONDATTR_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_CONDATTR_SIZE__ 8
     * }
     */
    public static int __PTHREAD_CONDATTR_SIZE__() {
        return __PTHREAD_CONDATTR_SIZE__;
    }
    private static final int __PTHREAD_COND_SIZE__ = (int)40L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_COND_SIZE__ 40
     * }
     */
    public static int __PTHREAD_COND_SIZE__() {
        return __PTHREAD_COND_SIZE__;
    }
    private static final int __PTHREAD_ONCE_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_ONCE_SIZE__ 8
     * }
     */
    public static int __PTHREAD_ONCE_SIZE__() {
        return __PTHREAD_ONCE_SIZE__;
    }
    private static final int __PTHREAD_RWLOCK_SIZE__ = (int)192L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCK_SIZE__ 192
     * }
     */
    public static int __PTHREAD_RWLOCK_SIZE__() {
        return __PTHREAD_RWLOCK_SIZE__;
    }
    private static final int __PTHREAD_RWLOCKATTR_SIZE__ = (int)16L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCKATTR_SIZE__ 16
     * }
     */
    public static int __PTHREAD_RWLOCKATTR_SIZE__() {
        return __PTHREAD_RWLOCKATTR_SIZE__;
    }
    private static final int INT8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static int INT8_MAX() {
        return INT8_MAX;
    }
    private static final int INT16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static int INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final int UINT8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static int UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final int UINT16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static int UINT16_MAX() {
        return UINT16_MAX;
    }
    private static final int __API_TO_BE_DEPRECATED = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED() {
        return __API_TO_BE_DEPRECATED;
    }
    private static final int __API_TO_BE_DEPRECATED_MACOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_MACOS 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_MACOS() {
        return __API_TO_BE_DEPRECATED_MACOS;
    }
    private static final int __API_TO_BE_DEPRECATED_MACOSAPPLICATIONEXTENSION = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_MACOSAPPLICATIONEXTENSION 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_MACOSAPPLICATIONEXTENSION() {
        return __API_TO_BE_DEPRECATED_MACOSAPPLICATIONEXTENSION;
    }
    private static final int __API_TO_BE_DEPRECATED_IOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_IOS 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_IOS() {
        return __API_TO_BE_DEPRECATED_IOS;
    }
    private static final int __API_TO_BE_DEPRECATED_IOSAPPLICATIONEXTENSION = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_IOSAPPLICATIONEXTENSION 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_IOSAPPLICATIONEXTENSION() {
        return __API_TO_BE_DEPRECATED_IOSAPPLICATIONEXTENSION;
    }
    private static final int __API_TO_BE_DEPRECATED_MACCATALYST = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_MACCATALYST 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_MACCATALYST() {
        return __API_TO_BE_DEPRECATED_MACCATALYST;
    }
    private static final int __API_TO_BE_DEPRECATED_MACCATALYSTAPPLICATIONEXTENSION = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_MACCATALYSTAPPLICATIONEXTENSION 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_MACCATALYSTAPPLICATIONEXTENSION() {
        return __API_TO_BE_DEPRECATED_MACCATALYSTAPPLICATIONEXTENSION;
    }
    private static final int __API_TO_BE_DEPRECATED_WATCHOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_WATCHOS 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_WATCHOS() {
        return __API_TO_BE_DEPRECATED_WATCHOS;
    }
    private static final int __API_TO_BE_DEPRECATED_WATCHOSAPPLICATIONEXTENSION = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_WATCHOSAPPLICATIONEXTENSION 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_WATCHOSAPPLICATIONEXTENSION() {
        return __API_TO_BE_DEPRECATED_WATCHOSAPPLICATIONEXTENSION;
    }
    private static final int __API_TO_BE_DEPRECATED_TVOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_TVOS 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_TVOS() {
        return __API_TO_BE_DEPRECATED_TVOS;
    }
    private static final int __API_TO_BE_DEPRECATED_TVOSAPPLICATIONEXTENSION = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_TVOSAPPLICATIONEXTENSION 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_TVOSAPPLICATIONEXTENSION() {
        return __API_TO_BE_DEPRECATED_TVOSAPPLICATIONEXTENSION;
    }
    private static final int __API_TO_BE_DEPRECATED_DRIVERKIT = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_DRIVERKIT 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_DRIVERKIT() {
        return __API_TO_BE_DEPRECATED_DRIVERKIT;
    }
    private static final int __API_TO_BE_DEPRECATED_VISIONOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_VISIONOS 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_VISIONOS() {
        return __API_TO_BE_DEPRECATED_VISIONOS;
    }
    private static final int __API_TO_BE_DEPRECATED_VISIONOSAPPLICATIONEXTENSION = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_VISIONOSAPPLICATIONEXTENSION 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_VISIONOSAPPLICATIONEXTENSION() {
        return __API_TO_BE_DEPRECATED_VISIONOSAPPLICATIONEXTENSION;
    }
    private static final int __API_TO_BE_DEPRECATED_KERNELKIT = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_KERNELKIT 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_KERNELKIT() {
        return __API_TO_BE_DEPRECATED_KERNELKIT;
    }
    private static final int __MAC_10_0 = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_0 1000
     * }
     */
    public static int __MAC_10_0() {
        return __MAC_10_0;
    }
    private static final int __MAC_10_1 = (int)1010L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_1 1010
     * }
     */
    public static int __MAC_10_1() {
        return __MAC_10_1;
    }
    private static final int __MAC_10_2 = (int)1020L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_2 1020
     * }
     */
    public static int __MAC_10_2() {
        return __MAC_10_2;
    }
    private static final int __MAC_10_3 = (int)1030L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_3 1030
     * }
     */
    public static int __MAC_10_3() {
        return __MAC_10_3;
    }
    private static final int __MAC_10_4 = (int)1040L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_4 1040
     * }
     */
    public static int __MAC_10_4() {
        return __MAC_10_4;
    }
    private static final int __MAC_10_5 = (int)1050L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_5 1050
     * }
     */
    public static int __MAC_10_5() {
        return __MAC_10_5;
    }
    private static final int __MAC_10_6 = (int)1060L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_6 1060
     * }
     */
    public static int __MAC_10_6() {
        return __MAC_10_6;
    }
    private static final int __MAC_10_7 = (int)1070L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_7 1070
     * }
     */
    public static int __MAC_10_7() {
        return __MAC_10_7;
    }
    private static final int __MAC_10_8 = (int)1080L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_8 1080
     * }
     */
    public static int __MAC_10_8() {
        return __MAC_10_8;
    }
    private static final int __MAC_10_9 = (int)1090L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_9 1090
     * }
     */
    public static int __MAC_10_9() {
        return __MAC_10_9;
    }
    private static final int __MAC_10_10 = (int)101000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_10 101000
     * }
     */
    public static int __MAC_10_10() {
        return __MAC_10_10;
    }
    private static final int __MAC_10_10_2 = (int)101002L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_10_2 101002
     * }
     */
    public static int __MAC_10_10_2() {
        return __MAC_10_10_2;
    }
    private static final int __MAC_10_10_3 = (int)101003L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_10_3 101003
     * }
     */
    public static int __MAC_10_10_3() {
        return __MAC_10_10_3;
    }
    private static final int __MAC_10_11 = (int)101100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_11 101100
     * }
     */
    public static int __MAC_10_11() {
        return __MAC_10_11;
    }
    private static final int __MAC_10_11_2 = (int)101102L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_11_2 101102
     * }
     */
    public static int __MAC_10_11_2() {
        return __MAC_10_11_2;
    }
    private static final int __MAC_10_11_3 = (int)101103L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_11_3 101103
     * }
     */
    public static int __MAC_10_11_3() {
        return __MAC_10_11_3;
    }
    private static final int __MAC_10_11_4 = (int)101104L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_11_4 101104
     * }
     */
    public static int __MAC_10_11_4() {
        return __MAC_10_11_4;
    }
    private static final int __MAC_10_12 = (int)101200L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_12 101200
     * }
     */
    public static int __MAC_10_12() {
        return __MAC_10_12;
    }
    private static final int __MAC_10_12_1 = (int)101201L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_12_1 101201
     * }
     */
    public static int __MAC_10_12_1() {
        return __MAC_10_12_1;
    }
    private static final int __MAC_10_12_2 = (int)101202L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_12_2 101202
     * }
     */
    public static int __MAC_10_12_2() {
        return __MAC_10_12_2;
    }
    private static final int __MAC_10_12_4 = (int)101204L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_12_4 101204
     * }
     */
    public static int __MAC_10_12_4() {
        return __MAC_10_12_4;
    }
    private static final int __MAC_10_13 = (int)101300L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_13 101300
     * }
     */
    public static int __MAC_10_13() {
        return __MAC_10_13;
    }
    private static final int __MAC_10_13_1 = (int)101301L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_13_1 101301
     * }
     */
    public static int __MAC_10_13_1() {
        return __MAC_10_13_1;
    }
    private static final int __MAC_10_13_2 = (int)101302L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_13_2 101302
     * }
     */
    public static int __MAC_10_13_2() {
        return __MAC_10_13_2;
    }
    private static final int __MAC_10_13_4 = (int)101304L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_13_4 101304
     * }
     */
    public static int __MAC_10_13_4() {
        return __MAC_10_13_4;
    }
    private static final int __MAC_10_14 = (int)101400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_14 101400
     * }
     */
    public static int __MAC_10_14() {
        return __MAC_10_14;
    }
    private static final int __MAC_10_14_1 = (int)101401L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_14_1 101401
     * }
     */
    public static int __MAC_10_14_1() {
        return __MAC_10_14_1;
    }
    private static final int __MAC_10_14_4 = (int)101404L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_14_4 101404
     * }
     */
    public static int __MAC_10_14_4() {
        return __MAC_10_14_4;
    }
    private static final int __MAC_10_14_5 = (int)101405L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_14_5 101405
     * }
     */
    public static int __MAC_10_14_5() {
        return __MAC_10_14_5;
    }
    private static final int __MAC_10_14_6 = (int)101406L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_14_6 101406
     * }
     */
    public static int __MAC_10_14_6() {
        return __MAC_10_14_6;
    }
    private static final int __MAC_10_15 = (int)101500L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_15 101500
     * }
     */
    public static int __MAC_10_15() {
        return __MAC_10_15;
    }
    private static final int __MAC_10_15_1 = (int)101501L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_15_1 101501
     * }
     */
    public static int __MAC_10_15_1() {
        return __MAC_10_15_1;
    }
    private static final int __MAC_10_15_4 = (int)101504L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_15_4 101504
     * }
     */
    public static int __MAC_10_15_4() {
        return __MAC_10_15_4;
    }
    private static final int __MAC_10_16 = (int)101600L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_16 101600
     * }
     */
    public static int __MAC_10_16() {
        return __MAC_10_16;
    }
    private static final int __MAC_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_0 110000
     * }
     */
    public static int __MAC_11_0() {
        return __MAC_11_0;
    }
    private static final int __MAC_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_1 110100
     * }
     */
    public static int __MAC_11_1() {
        return __MAC_11_1;
    }
    private static final int __MAC_11_3 = (int)110300L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_3 110300
     * }
     */
    public static int __MAC_11_3() {
        return __MAC_11_3;
    }
    private static final int __MAC_11_4 = (int)110400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_4 110400
     * }
     */
    public static int __MAC_11_4() {
        return __MAC_11_4;
    }
    private static final int __MAC_11_5 = (int)110500L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_5 110500
     * }
     */
    public static int __MAC_11_5() {
        return __MAC_11_5;
    }
    private static final int __MAC_11_6 = (int)110600L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_6 110600
     * }
     */
    public static int __MAC_11_6() {
        return __MAC_11_6;
    }
    private static final int __MAC_12_0 = (int)120000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_0 120000
     * }
     */
    public static int __MAC_12_0() {
        return __MAC_12_0;
    }
    private static final int __MAC_12_1 = (int)120100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_1 120100
     * }
     */
    public static int __MAC_12_1() {
        return __MAC_12_1;
    }
    private static final int __MAC_12_2 = (int)120200L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_2 120200
     * }
     */
    public static int __MAC_12_2() {
        return __MAC_12_2;
    }
    private static final int __MAC_12_3 = (int)120300L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_3 120300
     * }
     */
    public static int __MAC_12_3() {
        return __MAC_12_3;
    }
    private static final int __MAC_12_4 = (int)120400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_4 120400
     * }
     */
    public static int __MAC_12_4() {
        return __MAC_12_4;
    }
    private static final int __MAC_12_5 = (int)120500L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_5 120500
     * }
     */
    public static int __MAC_12_5() {
        return __MAC_12_5;
    }
    private static final int __MAC_12_6 = (int)120600L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_6 120600
     * }
     */
    public static int __MAC_12_6() {
        return __MAC_12_6;
    }
    private static final int __MAC_12_7 = (int)120700L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_7 120700
     * }
     */
    public static int __MAC_12_7() {
        return __MAC_12_7;
    }
    private static final int __MAC_13_0 = (int)130000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_0 130000
     * }
     */
    public static int __MAC_13_0() {
        return __MAC_13_0;
    }
    private static final int __MAC_13_1 = (int)130100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_1 130100
     * }
     */
    public static int __MAC_13_1() {
        return __MAC_13_1;
    }
    private static final int __MAC_13_2 = (int)130200L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_2 130200
     * }
     */
    public static int __MAC_13_2() {
        return __MAC_13_2;
    }
    private static final int __MAC_13_3 = (int)130300L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_3 130300
     * }
     */
    public static int __MAC_13_3() {
        return __MAC_13_3;
    }
    private static final int __MAC_13_4 = (int)130400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_4 130400
     * }
     */
    public static int __MAC_13_4() {
        return __MAC_13_4;
    }
    private static final int __MAC_13_5 = (int)130500L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_5 130500
     * }
     */
    public static int __MAC_13_5() {
        return __MAC_13_5;
    }
    private static final int __MAC_13_6 = (int)130600L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_6 130600
     * }
     */
    public static int __MAC_13_6() {
        return __MAC_13_6;
    }
    private static final int __MAC_13_7 = (int)130700L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_7 130700
     * }
     */
    public static int __MAC_13_7() {
        return __MAC_13_7;
    }
    private static final int __MAC_14_0 = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_14_0 140000
     * }
     */
    public static int __MAC_14_0() {
        return __MAC_14_0;
    }
    private static final int __MAC_14_1 = (int)140100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_14_1 140100
     * }
     */
    public static int __MAC_14_1() {
        return __MAC_14_1;
    }
    private static final int __MAC_14_2 = (int)140200L;
    /**
     * {@snippet lang=c :
     * #define __MAC_14_2 140200
     * }
     */
    public static int __MAC_14_2() {
        return __MAC_14_2;
    }
    private static final int __MAC_14_3 = (int)140300L;
    /**
     * {@snippet lang=c :
     * #define __MAC_14_3 140300
     * }
     */
    public static int __MAC_14_3() {
        return __MAC_14_3;
    }
    private static final int __MAC_14_4 = (int)140400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_14_4 140400
     * }
     */
    public static int __MAC_14_4() {
        return __MAC_14_4;
    }
    private static final int __MAC_14_5 = (int)140500L;
    /**
     * {@snippet lang=c :
     * #define __MAC_14_5 140500
     * }
     */
    public static int __MAC_14_5() {
        return __MAC_14_5;
    }
    private static final int __MAC_14_6 = (int)140600L;
    /**
     * {@snippet lang=c :
     * #define __MAC_14_6 140600
     * }
     */
    public static int __MAC_14_6() {
        return __MAC_14_6;
    }
    private static final int __MAC_14_7 = (int)140700L;
    /**
     * {@snippet lang=c :
     * #define __MAC_14_7 140700
     * }
     */
    public static int __MAC_14_7() {
        return __MAC_14_7;
    }
    private static final int __MAC_15_0 = (int)150000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_15_0 150000
     * }
     */
    public static int __MAC_15_0() {
        return __MAC_15_0;
    }
    private static final int __MAC_15_1 = (int)150100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_15_1 150100
     * }
     */
    public static int __MAC_15_1() {
        return __MAC_15_1;
    }
    private static final int __MAC_15_2 = (int)150200L;
    /**
     * {@snippet lang=c :
     * #define __MAC_15_2 150200
     * }
     */
    public static int __MAC_15_2() {
        return __MAC_15_2;
    }
    private static final int __MAC_15_3 = (int)150300L;
    /**
     * {@snippet lang=c :
     * #define __MAC_15_3 150300
     * }
     */
    public static int __MAC_15_3() {
        return __MAC_15_3;
    }
    private static final int __MAC_15_4 = (int)150400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_15_4 150400
     * }
     */
    public static int __MAC_15_4() {
        return __MAC_15_4;
    }
    private static final int __MAC_15_5 = (int)150500L;
    /**
     * {@snippet lang=c :
     * #define __MAC_15_5 150500
     * }
     */
    public static int __MAC_15_5() {
        return __MAC_15_5;
    }
    private static final int __IPHONE_2_0 = (int)20000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_2_0 20000
     * }
     */
    public static int __IPHONE_2_0() {
        return __IPHONE_2_0;
    }
    private static final int __IPHONE_2_1 = (int)20100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_2_1 20100
     * }
     */
    public static int __IPHONE_2_1() {
        return __IPHONE_2_1;
    }
    private static final int __IPHONE_2_2 = (int)20200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_2_2 20200
     * }
     */
    public static int __IPHONE_2_2() {
        return __IPHONE_2_2;
    }
    private static final int __IPHONE_3_0 = (int)30000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_3_0 30000
     * }
     */
    public static int __IPHONE_3_0() {
        return __IPHONE_3_0;
    }
    private static final int __IPHONE_3_1 = (int)30100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_3_1 30100
     * }
     */
    public static int __IPHONE_3_1() {
        return __IPHONE_3_1;
    }
    private static final int __IPHONE_3_2 = (int)30200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_3_2 30200
     * }
     */
    public static int __IPHONE_3_2() {
        return __IPHONE_3_2;
    }
    private static final int __IPHONE_4_0 = (int)40000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_4_0 40000
     * }
     */
    public static int __IPHONE_4_0() {
        return __IPHONE_4_0;
    }
    private static final int __IPHONE_4_1 = (int)40100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_4_1 40100
     * }
     */
    public static int __IPHONE_4_1() {
        return __IPHONE_4_1;
    }
    private static final int __IPHONE_4_2 = (int)40200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_4_2 40200
     * }
     */
    public static int __IPHONE_4_2() {
        return __IPHONE_4_2;
    }
    private static final int __IPHONE_4_3 = (int)40300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_4_3 40300
     * }
     */
    public static int __IPHONE_4_3() {
        return __IPHONE_4_3;
    }
    private static final int __IPHONE_5_0 = (int)50000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_5_0 50000
     * }
     */
    public static int __IPHONE_5_0() {
        return __IPHONE_5_0;
    }
    private static final int __IPHONE_5_1 = (int)50100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_5_1 50100
     * }
     */
    public static int __IPHONE_5_1() {
        return __IPHONE_5_1;
    }
    private static final int __IPHONE_6_0 = (int)60000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_6_0 60000
     * }
     */
    public static int __IPHONE_6_0() {
        return __IPHONE_6_0;
    }
    private static final int __IPHONE_6_1 = (int)60100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_6_1 60100
     * }
     */
    public static int __IPHONE_6_1() {
        return __IPHONE_6_1;
    }
    private static final int __IPHONE_7_0 = (int)70000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_7_0 70000
     * }
     */
    public static int __IPHONE_7_0() {
        return __IPHONE_7_0;
    }
    private static final int __IPHONE_7_1 = (int)70100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_7_1 70100
     * }
     */
    public static int __IPHONE_7_1() {
        return __IPHONE_7_1;
    }
    private static final int __IPHONE_8_0 = (int)80000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_8_0 80000
     * }
     */
    public static int __IPHONE_8_0() {
        return __IPHONE_8_0;
    }
    private static final int __IPHONE_8_1 = (int)80100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_8_1 80100
     * }
     */
    public static int __IPHONE_8_1() {
        return __IPHONE_8_1;
    }
    private static final int __IPHONE_8_2 = (int)80200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_8_2 80200
     * }
     */
    public static int __IPHONE_8_2() {
        return __IPHONE_8_2;
    }
    private static final int __IPHONE_8_3 = (int)80300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_8_3 80300
     * }
     */
    public static int __IPHONE_8_3() {
        return __IPHONE_8_3;
    }
    private static final int __IPHONE_8_4 = (int)80400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_8_4 80400
     * }
     */
    public static int __IPHONE_8_4() {
        return __IPHONE_8_4;
    }
    private static final int __IPHONE_9_0 = (int)90000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_9_0 90000
     * }
     */
    public static int __IPHONE_9_0() {
        return __IPHONE_9_0;
    }
    private static final int __IPHONE_9_1 = (int)90100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_9_1 90100
     * }
     */
    public static int __IPHONE_9_1() {
        return __IPHONE_9_1;
    }
    private static final int __IPHONE_9_2 = (int)90200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_9_2 90200
     * }
     */
    public static int __IPHONE_9_2() {
        return __IPHONE_9_2;
    }
    private static final int __IPHONE_9_3 = (int)90300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_9_3 90300
     * }
     */
    public static int __IPHONE_9_3() {
        return __IPHONE_9_3;
    }
    private static final int __IPHONE_10_0 = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_10_0 100000
     * }
     */
    public static int __IPHONE_10_0() {
        return __IPHONE_10_0;
    }
    private static final int __IPHONE_10_1 = (int)100100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_10_1 100100
     * }
     */
    public static int __IPHONE_10_1() {
        return __IPHONE_10_1;
    }
    private static final int __IPHONE_10_2 = (int)100200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_10_2 100200
     * }
     */
    public static int __IPHONE_10_2() {
        return __IPHONE_10_2;
    }
    private static final int __IPHONE_10_3 = (int)100300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_10_3 100300
     * }
     */
    public static int __IPHONE_10_3() {
        return __IPHONE_10_3;
    }
    private static final int __IPHONE_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_11_0 110000
     * }
     */
    public static int __IPHONE_11_0() {
        return __IPHONE_11_0;
    }
    private static final int __IPHONE_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_11_1 110100
     * }
     */
    public static int __IPHONE_11_1() {
        return __IPHONE_11_1;
    }
    private static final int __IPHONE_11_2 = (int)110200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_11_2 110200
     * }
     */
    public static int __IPHONE_11_2() {
        return __IPHONE_11_2;
    }
    private static final int __IPHONE_11_3 = (int)110300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_11_3 110300
     * }
     */
    public static int __IPHONE_11_3() {
        return __IPHONE_11_3;
    }
    private static final int __IPHONE_11_4 = (int)110400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_11_4 110400
     * }
     */
    public static int __IPHONE_11_4() {
        return __IPHONE_11_4;
    }
    private static final int __IPHONE_12_0 = (int)120000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_12_0 120000
     * }
     */
    public static int __IPHONE_12_0() {
        return __IPHONE_12_0;
    }
    private static final int __IPHONE_12_1 = (int)120100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_12_1 120100
     * }
     */
    public static int __IPHONE_12_1() {
        return __IPHONE_12_1;
    }
    private static final int __IPHONE_12_2 = (int)120200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_12_2 120200
     * }
     */
    public static int __IPHONE_12_2() {
        return __IPHONE_12_2;
    }
    private static final int __IPHONE_12_3 = (int)120300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_12_3 120300
     * }
     */
    public static int __IPHONE_12_3() {
        return __IPHONE_12_3;
    }
    private static final int __IPHONE_12_4 = (int)120400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_12_4 120400
     * }
     */
    public static int __IPHONE_12_4() {
        return __IPHONE_12_4;
    }
    private static final int __IPHONE_13_0 = (int)130000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_0 130000
     * }
     */
    public static int __IPHONE_13_0() {
        return __IPHONE_13_0;
    }
    private static final int __IPHONE_13_1 = (int)130100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_1 130100
     * }
     */
    public static int __IPHONE_13_1() {
        return __IPHONE_13_1;
    }
    private static final int __IPHONE_13_2 = (int)130200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_2 130200
     * }
     */
    public static int __IPHONE_13_2() {
        return __IPHONE_13_2;
    }
    private static final int __IPHONE_13_3 = (int)130300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_3 130300
     * }
     */
    public static int __IPHONE_13_3() {
        return __IPHONE_13_3;
    }
    private static final int __IPHONE_13_4 = (int)130400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_4 130400
     * }
     */
    public static int __IPHONE_13_4() {
        return __IPHONE_13_4;
    }
    private static final int __IPHONE_13_5 = (int)130500L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_5 130500
     * }
     */
    public static int __IPHONE_13_5() {
        return __IPHONE_13_5;
    }
    private static final int __IPHONE_13_6 = (int)130600L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_6 130600
     * }
     */
    public static int __IPHONE_13_6() {
        return __IPHONE_13_6;
    }
    private static final int __IPHONE_13_7 = (int)130700L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_7 130700
     * }
     */
    public static int __IPHONE_13_7() {
        return __IPHONE_13_7;
    }
    private static final int __IPHONE_14_0 = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_0 140000
     * }
     */
    public static int __IPHONE_14_0() {
        return __IPHONE_14_0;
    }
    private static final int __IPHONE_14_1 = (int)140100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_1 140100
     * }
     */
    public static int __IPHONE_14_1() {
        return __IPHONE_14_1;
    }
    private static final int __IPHONE_14_2 = (int)140200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_2 140200
     * }
     */
    public static int __IPHONE_14_2() {
        return __IPHONE_14_2;
    }
    private static final int __IPHONE_14_3 = (int)140300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_3 140300
     * }
     */
    public static int __IPHONE_14_3() {
        return __IPHONE_14_3;
    }
    private static final int __IPHONE_14_5 = (int)140500L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_5 140500
     * }
     */
    public static int __IPHONE_14_5() {
        return __IPHONE_14_5;
    }
    private static final int __IPHONE_14_4 = (int)140400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_4 140400
     * }
     */
    public static int __IPHONE_14_4() {
        return __IPHONE_14_4;
    }
    private static final int __IPHONE_14_6 = (int)140600L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_6 140600
     * }
     */
    public static int __IPHONE_14_6() {
        return __IPHONE_14_6;
    }
    private static final int __IPHONE_14_7 = (int)140700L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_7 140700
     * }
     */
    public static int __IPHONE_14_7() {
        return __IPHONE_14_7;
    }
    private static final int __IPHONE_14_8 = (int)140800L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_8 140800
     * }
     */
    public static int __IPHONE_14_8() {
        return __IPHONE_14_8;
    }
    private static final int __IPHONE_15_0 = (int)150000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_0 150000
     * }
     */
    public static int __IPHONE_15_0() {
        return __IPHONE_15_0;
    }
    private static final int __IPHONE_15_1 = (int)150100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_1 150100
     * }
     */
    public static int __IPHONE_15_1() {
        return __IPHONE_15_1;
    }
    private static final int __IPHONE_15_2 = (int)150200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_2 150200
     * }
     */
    public static int __IPHONE_15_2() {
        return __IPHONE_15_2;
    }
    private static final int __IPHONE_15_3 = (int)150300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_3 150300
     * }
     */
    public static int __IPHONE_15_3() {
        return __IPHONE_15_3;
    }
    private static final int __IPHONE_15_4 = (int)150400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_4 150400
     * }
     */
    public static int __IPHONE_15_4() {
        return __IPHONE_15_4;
    }
    private static final int __IPHONE_15_5 = (int)150500L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_5 150500
     * }
     */
    public static int __IPHONE_15_5() {
        return __IPHONE_15_5;
    }
    private static final int __IPHONE_15_6 = (int)150600L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_6 150600
     * }
     */
    public static int __IPHONE_15_6() {
        return __IPHONE_15_6;
    }
    private static final int __IPHONE_15_7 = (int)150700L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_7 150700
     * }
     */
    public static int __IPHONE_15_7() {
        return __IPHONE_15_7;
    }
    private static final int __IPHONE_15_8 = (int)150800L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_8 150800
     * }
     */
    public static int __IPHONE_15_8() {
        return __IPHONE_15_8;
    }
    private static final int __IPHONE_16_0 = (int)160000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_0 160000
     * }
     */
    public static int __IPHONE_16_0() {
        return __IPHONE_16_0;
    }
    private static final int __IPHONE_16_1 = (int)160100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_1 160100
     * }
     */
    public static int __IPHONE_16_1() {
        return __IPHONE_16_1;
    }
    private static final int __IPHONE_16_2 = (int)160200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_2 160200
     * }
     */
    public static int __IPHONE_16_2() {
        return __IPHONE_16_2;
    }
    private static final int __IPHONE_16_3 = (int)160300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_3 160300
     * }
     */
    public static int __IPHONE_16_3() {
        return __IPHONE_16_3;
    }
    private static final int __IPHONE_16_4 = (int)160400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_4 160400
     * }
     */
    public static int __IPHONE_16_4() {
        return __IPHONE_16_4;
    }
    private static final int __IPHONE_16_5 = (int)160500L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_5 160500
     * }
     */
    public static int __IPHONE_16_5() {
        return __IPHONE_16_5;
    }
    private static final int __IPHONE_16_6 = (int)160600L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_6 160600
     * }
     */
    public static int __IPHONE_16_6() {
        return __IPHONE_16_6;
    }
    private static final int __IPHONE_16_7 = (int)160700L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_7 160700
     * }
     */
    public static int __IPHONE_16_7() {
        return __IPHONE_16_7;
    }
    private static final int __IPHONE_17_0 = (int)170000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_17_0 170000
     * }
     */
    public static int __IPHONE_17_0() {
        return __IPHONE_17_0;
    }
    private static final int __IPHONE_17_1 = (int)170100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_17_1 170100
     * }
     */
    public static int __IPHONE_17_1() {
        return __IPHONE_17_1;
    }
    private static final int __IPHONE_17_2 = (int)170200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_17_2 170200
     * }
     */
    public static int __IPHONE_17_2() {
        return __IPHONE_17_2;
    }
    private static final int __IPHONE_17_3 = (int)170300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_17_3 170300
     * }
     */
    public static int __IPHONE_17_3() {
        return __IPHONE_17_3;
    }
    private static final int __IPHONE_17_4 = (int)170400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_17_4 170400
     * }
     */
    public static int __IPHONE_17_4() {
        return __IPHONE_17_4;
    }
    private static final int __IPHONE_17_5 = (int)170500L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_17_5 170500
     * }
     */
    public static int __IPHONE_17_5() {
        return __IPHONE_17_5;
    }
    private static final int __IPHONE_17_6 = (int)170600L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_17_6 170600
     * }
     */
    public static int __IPHONE_17_6() {
        return __IPHONE_17_6;
    }
    private static final int __IPHONE_17_7 = (int)170700L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_17_7 170700
     * }
     */
    public static int __IPHONE_17_7() {
        return __IPHONE_17_7;
    }
    private static final int __IPHONE_18_0 = (int)180000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_18_0 180000
     * }
     */
    public static int __IPHONE_18_0() {
        return __IPHONE_18_0;
    }
    private static final int __IPHONE_18_1 = (int)180100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_18_1 180100
     * }
     */
    public static int __IPHONE_18_1() {
        return __IPHONE_18_1;
    }
    private static final int __IPHONE_18_2 = (int)180200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_18_2 180200
     * }
     */
    public static int __IPHONE_18_2() {
        return __IPHONE_18_2;
    }
    private static final int __IPHONE_18_3 = (int)180300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_18_3 180300
     * }
     */
    public static int __IPHONE_18_3() {
        return __IPHONE_18_3;
    }
    private static final int __IPHONE_18_4 = (int)180400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_18_4 180400
     * }
     */
    public static int __IPHONE_18_4() {
        return __IPHONE_18_4;
    }
    private static final int __IPHONE_18_5 = (int)180500L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_18_5 180500
     * }
     */
    public static int __IPHONE_18_5() {
        return __IPHONE_18_5;
    }
    private static final int __WATCHOS_1_0 = (int)10000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_1_0 10000
     * }
     */
    public static int __WATCHOS_1_0() {
        return __WATCHOS_1_0;
    }
    private static final int __WATCHOS_2_0 = (int)20000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_2_0 20000
     * }
     */
    public static int __WATCHOS_2_0() {
        return __WATCHOS_2_0;
    }
    private static final int __WATCHOS_2_1 = (int)20100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_2_1 20100
     * }
     */
    public static int __WATCHOS_2_1() {
        return __WATCHOS_2_1;
    }
    private static final int __WATCHOS_2_2 = (int)20200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_2_2 20200
     * }
     */
    public static int __WATCHOS_2_2() {
        return __WATCHOS_2_2;
    }
    private static final int __WATCHOS_3_0 = (int)30000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_3_0 30000
     * }
     */
    public static int __WATCHOS_3_0() {
        return __WATCHOS_3_0;
    }
    private static final int __WATCHOS_3_1 = (int)30100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_3_1 30100
     * }
     */
    public static int __WATCHOS_3_1() {
        return __WATCHOS_3_1;
    }
    private static final int __WATCHOS_3_1_1 = (int)30101L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_3_1_1 30101
     * }
     */
    public static int __WATCHOS_3_1_1() {
        return __WATCHOS_3_1_1;
    }
    private static final int __WATCHOS_3_2 = (int)30200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_3_2 30200
     * }
     */
    public static int __WATCHOS_3_2() {
        return __WATCHOS_3_2;
    }
    private static final int __WATCHOS_4_0 = (int)40000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_4_0 40000
     * }
     */
    public static int __WATCHOS_4_0() {
        return __WATCHOS_4_0;
    }
    private static final int __WATCHOS_4_1 = (int)40100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_4_1 40100
     * }
     */
    public static int __WATCHOS_4_1() {
        return __WATCHOS_4_1;
    }
    private static final int __WATCHOS_4_2 = (int)40200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_4_2 40200
     * }
     */
    public static int __WATCHOS_4_2() {
        return __WATCHOS_4_2;
    }
    private static final int __WATCHOS_4_3 = (int)40300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_4_3 40300
     * }
     */
    public static int __WATCHOS_4_3() {
        return __WATCHOS_4_3;
    }
    private static final int __WATCHOS_5_0 = (int)50000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_5_0 50000
     * }
     */
    public static int __WATCHOS_5_0() {
        return __WATCHOS_5_0;
    }
    private static final int __WATCHOS_5_1 = (int)50100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_5_1 50100
     * }
     */
    public static int __WATCHOS_5_1() {
        return __WATCHOS_5_1;
    }
    private static final int __WATCHOS_5_2 = (int)50200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_5_2 50200
     * }
     */
    public static int __WATCHOS_5_2() {
        return __WATCHOS_5_2;
    }
    private static final int __WATCHOS_5_3 = (int)50300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_5_3 50300
     * }
     */
    public static int __WATCHOS_5_3() {
        return __WATCHOS_5_3;
    }
    private static final int __WATCHOS_6_0 = (int)60000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_6_0 60000
     * }
     */
    public static int __WATCHOS_6_0() {
        return __WATCHOS_6_0;
    }
    private static final int __WATCHOS_6_1 = (int)60100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_6_1 60100
     * }
     */
    public static int __WATCHOS_6_1() {
        return __WATCHOS_6_1;
    }
    private static final int __WATCHOS_6_2 = (int)60200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_6_2 60200
     * }
     */
    public static int __WATCHOS_6_2() {
        return __WATCHOS_6_2;
    }
    private static final int __WATCHOS_7_0 = (int)70000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_0 70000
     * }
     */
    public static int __WATCHOS_7_0() {
        return __WATCHOS_7_0;
    }
    private static final int __WATCHOS_7_1 = (int)70100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_1 70100
     * }
     */
    public static int __WATCHOS_7_1() {
        return __WATCHOS_7_1;
    }
    private static final int __WATCHOS_7_2 = (int)70200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_2 70200
     * }
     */
    public static int __WATCHOS_7_2() {
        return __WATCHOS_7_2;
    }
    private static final int __WATCHOS_7_3 = (int)70300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_3 70300
     * }
     */
    public static int __WATCHOS_7_3() {
        return __WATCHOS_7_3;
    }
    private static final int __WATCHOS_7_4 = (int)70400L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_4 70400
     * }
     */
    public static int __WATCHOS_7_4() {
        return __WATCHOS_7_4;
    }
    private static final int __WATCHOS_7_5 = (int)70500L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_5 70500
     * }
     */
    public static int __WATCHOS_7_5() {
        return __WATCHOS_7_5;
    }
    private static final int __WATCHOS_7_6 = (int)70600L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_6 70600
     * }
     */
    public static int __WATCHOS_7_6() {
        return __WATCHOS_7_6;
    }
    private static final int __WATCHOS_8_0 = (int)80000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_0 80000
     * }
     */
    public static int __WATCHOS_8_0() {
        return __WATCHOS_8_0;
    }
    private static final int __WATCHOS_8_1 = (int)80100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_1 80100
     * }
     */
    public static int __WATCHOS_8_1() {
        return __WATCHOS_8_1;
    }
    private static final int __WATCHOS_8_3 = (int)80300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_3 80300
     * }
     */
    public static int __WATCHOS_8_3() {
        return __WATCHOS_8_3;
    }
    private static final int __WATCHOS_8_4 = (int)80400L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_4 80400
     * }
     */
    public static int __WATCHOS_8_4() {
        return __WATCHOS_8_4;
    }
    private static final int __WATCHOS_8_5 = (int)80500L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_5 80500
     * }
     */
    public static int __WATCHOS_8_5() {
        return __WATCHOS_8_5;
    }
    private static final int __WATCHOS_8_6 = (int)80600L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_6 80600
     * }
     */
    public static int __WATCHOS_8_6() {
        return __WATCHOS_8_6;
    }
    private static final int __WATCHOS_8_7 = (int)80700L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_7 80700
     * }
     */
    public static int __WATCHOS_8_7() {
        return __WATCHOS_8_7;
    }
    private static final int __WATCHOS_8_8 = (int)80800L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_8 80800
     * }
     */
    public static int __WATCHOS_8_8() {
        return __WATCHOS_8_8;
    }
    private static final int __WATCHOS_9_0 = (int)90000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_0 90000
     * }
     */
    public static int __WATCHOS_9_0() {
        return __WATCHOS_9_0;
    }
    private static final int __WATCHOS_9_1 = (int)90100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_1 90100
     * }
     */
    public static int __WATCHOS_9_1() {
        return __WATCHOS_9_1;
    }
    private static final int __WATCHOS_9_2 = (int)90200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_2 90200
     * }
     */
    public static int __WATCHOS_9_2() {
        return __WATCHOS_9_2;
    }
    private static final int __WATCHOS_9_3 = (int)90300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_3 90300
     * }
     */
    public static int __WATCHOS_9_3() {
        return __WATCHOS_9_3;
    }
    private static final int __WATCHOS_9_4 = (int)90400L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_4 90400
     * }
     */
    public static int __WATCHOS_9_4() {
        return __WATCHOS_9_4;
    }
    private static final int __WATCHOS_9_5 = (int)90500L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_5 90500
     * }
     */
    public static int __WATCHOS_9_5() {
        return __WATCHOS_9_5;
    }
    private static final int __WATCHOS_9_6 = (int)90600L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_6 90600
     * }
     */
    public static int __WATCHOS_9_6() {
        return __WATCHOS_9_6;
    }
    private static final int __WATCHOS_10_0 = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_10_0 100000
     * }
     */
    public static int __WATCHOS_10_0() {
        return __WATCHOS_10_0;
    }
    private static final int __WATCHOS_10_1 = (int)100100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_10_1 100100
     * }
     */
    public static int __WATCHOS_10_1() {
        return __WATCHOS_10_1;
    }
    private static final int __WATCHOS_10_2 = (int)100200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_10_2 100200
     * }
     */
    public static int __WATCHOS_10_2() {
        return __WATCHOS_10_2;
    }
    private static final int __WATCHOS_10_3 = (int)100300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_10_3 100300
     * }
     */
    public static int __WATCHOS_10_3() {
        return __WATCHOS_10_3;
    }
    private static final int __WATCHOS_10_4 = (int)100400L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_10_4 100400
     * }
     */
    public static int __WATCHOS_10_4() {
        return __WATCHOS_10_4;
    }
    private static final int __WATCHOS_10_5 = (int)100500L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_10_5 100500
     * }
     */
    public static int __WATCHOS_10_5() {
        return __WATCHOS_10_5;
    }
    private static final int __WATCHOS_10_6 = (int)100600L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_10_6 100600
     * }
     */
    public static int __WATCHOS_10_6() {
        return __WATCHOS_10_6;
    }
    private static final int __WATCHOS_10_7 = (int)100700L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_10_7 100700
     * }
     */
    public static int __WATCHOS_10_7() {
        return __WATCHOS_10_7;
    }
    private static final int __WATCHOS_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_11_0 110000
     * }
     */
    public static int __WATCHOS_11_0() {
        return __WATCHOS_11_0;
    }
    private static final int __WATCHOS_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_11_1 110100
     * }
     */
    public static int __WATCHOS_11_1() {
        return __WATCHOS_11_1;
    }
    private static final int __WATCHOS_11_2 = (int)110200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_11_2 110200
     * }
     */
    public static int __WATCHOS_11_2() {
        return __WATCHOS_11_2;
    }
    private static final int __WATCHOS_11_3 = (int)110300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_11_3 110300
     * }
     */
    public static int __WATCHOS_11_3() {
        return __WATCHOS_11_3;
    }
    private static final int __WATCHOS_11_4 = (int)110400L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_11_4 110400
     * }
     */
    public static int __WATCHOS_11_4() {
        return __WATCHOS_11_4;
    }
    private static final int __WATCHOS_11_5 = (int)110500L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_11_5 110500
     * }
     */
    public static int __WATCHOS_11_5() {
        return __WATCHOS_11_5;
    }
    private static final int __TVOS_9_0 = (int)90000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_9_0 90000
     * }
     */
    public static int __TVOS_9_0() {
        return __TVOS_9_0;
    }
    private static final int __TVOS_9_1 = (int)90100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_9_1 90100
     * }
     */
    public static int __TVOS_9_1() {
        return __TVOS_9_1;
    }
    private static final int __TVOS_9_2 = (int)90200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_9_2 90200
     * }
     */
    public static int __TVOS_9_2() {
        return __TVOS_9_2;
    }
    private static final int __TVOS_10_0 = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_10_0 100000
     * }
     */
    public static int __TVOS_10_0() {
        return __TVOS_10_0;
    }
    private static final int __TVOS_10_0_1 = (int)100001L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_10_0_1 100001
     * }
     */
    public static int __TVOS_10_0_1() {
        return __TVOS_10_0_1;
    }
    private static final int __TVOS_10_1 = (int)100100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_10_1 100100
     * }
     */
    public static int __TVOS_10_1() {
        return __TVOS_10_1;
    }
    private static final int __TVOS_10_2 = (int)100200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_10_2 100200
     * }
     */
    public static int __TVOS_10_2() {
        return __TVOS_10_2;
    }
    private static final int __TVOS_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_11_0 110000
     * }
     */
    public static int __TVOS_11_0() {
        return __TVOS_11_0;
    }
    private static final int __TVOS_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_11_1 110100
     * }
     */
    public static int __TVOS_11_1() {
        return __TVOS_11_1;
    }
    private static final int __TVOS_11_2 = (int)110200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_11_2 110200
     * }
     */
    public static int __TVOS_11_2() {
        return __TVOS_11_2;
    }
    private static final int __TVOS_11_3 = (int)110300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_11_3 110300
     * }
     */
    public static int __TVOS_11_3() {
        return __TVOS_11_3;
    }
    private static final int __TVOS_11_4 = (int)110400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_11_4 110400
     * }
     */
    public static int __TVOS_11_4() {
        return __TVOS_11_4;
    }
    private static final int __TVOS_12_0 = (int)120000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_12_0 120000
     * }
     */
    public static int __TVOS_12_0() {
        return __TVOS_12_0;
    }
    private static final int __TVOS_12_1 = (int)120100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_12_1 120100
     * }
     */
    public static int __TVOS_12_1() {
        return __TVOS_12_1;
    }
    private static final int __TVOS_12_2 = (int)120200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_12_2 120200
     * }
     */
    public static int __TVOS_12_2() {
        return __TVOS_12_2;
    }
    private static final int __TVOS_12_3 = (int)120300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_12_3 120300
     * }
     */
    public static int __TVOS_12_3() {
        return __TVOS_12_3;
    }
    private static final int __TVOS_12_4 = (int)120400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_12_4 120400
     * }
     */
    public static int __TVOS_12_4() {
        return __TVOS_12_4;
    }
    private static final int __TVOS_13_0 = (int)130000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_13_0 130000
     * }
     */
    public static int __TVOS_13_0() {
        return __TVOS_13_0;
    }
    private static final int __TVOS_13_2 = (int)130200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_13_2 130200
     * }
     */
    public static int __TVOS_13_2() {
        return __TVOS_13_2;
    }
    private static final int __TVOS_13_3 = (int)130300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_13_3 130300
     * }
     */
    public static int __TVOS_13_3() {
        return __TVOS_13_3;
    }
    private static final int __TVOS_13_4 = (int)130400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_13_4 130400
     * }
     */
    public static int __TVOS_13_4() {
        return __TVOS_13_4;
    }
    private static final int __TVOS_14_0 = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_0 140000
     * }
     */
    public static int __TVOS_14_0() {
        return __TVOS_14_0;
    }
    private static final int __TVOS_14_1 = (int)140100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_1 140100
     * }
     */
    public static int __TVOS_14_1() {
        return __TVOS_14_1;
    }
    private static final int __TVOS_14_2 = (int)140200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_2 140200
     * }
     */
    public static int __TVOS_14_2() {
        return __TVOS_14_2;
    }
    private static final int __TVOS_14_3 = (int)140300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_3 140300
     * }
     */
    public static int __TVOS_14_3() {
        return __TVOS_14_3;
    }
    private static final int __TVOS_14_5 = (int)140500L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_5 140500
     * }
     */
    public static int __TVOS_14_5() {
        return __TVOS_14_5;
    }
    private static final int __TVOS_14_6 = (int)140600L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_6 140600
     * }
     */
    public static int __TVOS_14_6() {
        return __TVOS_14_6;
    }
    private static final int __TVOS_14_7 = (int)140700L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_7 140700
     * }
     */
    public static int __TVOS_14_7() {
        return __TVOS_14_7;
    }
    private static final int __TVOS_15_0 = (int)150000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_0 150000
     * }
     */
    public static int __TVOS_15_0() {
        return __TVOS_15_0;
    }
    private static final int __TVOS_15_1 = (int)150100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_1 150100
     * }
     */
    public static int __TVOS_15_1() {
        return __TVOS_15_1;
    }
    private static final int __TVOS_15_2 = (int)150200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_2 150200
     * }
     */
    public static int __TVOS_15_2() {
        return __TVOS_15_2;
    }
    private static final int __TVOS_15_3 = (int)150300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_3 150300
     * }
     */
    public static int __TVOS_15_3() {
        return __TVOS_15_3;
    }
    private static final int __TVOS_15_4 = (int)150400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_4 150400
     * }
     */
    public static int __TVOS_15_4() {
        return __TVOS_15_4;
    }
    private static final int __TVOS_15_5 = (int)150500L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_5 150500
     * }
     */
    public static int __TVOS_15_5() {
        return __TVOS_15_5;
    }
    private static final int __TVOS_15_6 = (int)150600L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_6 150600
     * }
     */
    public static int __TVOS_15_6() {
        return __TVOS_15_6;
    }
    private static final int __TVOS_16_0 = (int)160000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_0 160000
     * }
     */
    public static int __TVOS_16_0() {
        return __TVOS_16_0;
    }
    private static final int __TVOS_16_1 = (int)160100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_1 160100
     * }
     */
    public static int __TVOS_16_1() {
        return __TVOS_16_1;
    }
    private static final int __TVOS_16_2 = (int)160200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_2 160200
     * }
     */
    public static int __TVOS_16_2() {
        return __TVOS_16_2;
    }
    private static final int __TVOS_16_3 = (int)160300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_3 160300
     * }
     */
    public static int __TVOS_16_3() {
        return __TVOS_16_3;
    }
    private static final int __TVOS_16_4 = (int)160400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_4 160400
     * }
     */
    public static int __TVOS_16_4() {
        return __TVOS_16_4;
    }
    private static final int __TVOS_16_5 = (int)160500L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_5 160500
     * }
     */
    public static int __TVOS_16_5() {
        return __TVOS_16_5;
    }
    private static final int __TVOS_16_6 = (int)160600L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_6 160600
     * }
     */
    public static int __TVOS_16_6() {
        return __TVOS_16_6;
    }
    private static final int __TVOS_17_0 = (int)170000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_17_0 170000
     * }
     */
    public static int __TVOS_17_0() {
        return __TVOS_17_0;
    }
    private static final int __TVOS_17_1 = (int)170100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_17_1 170100
     * }
     */
    public static int __TVOS_17_1() {
        return __TVOS_17_1;
    }
    private static final int __TVOS_17_2 = (int)170200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_17_2 170200
     * }
     */
    public static int __TVOS_17_2() {
        return __TVOS_17_2;
    }
    private static final int __TVOS_17_3 = (int)170300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_17_3 170300
     * }
     */
    public static int __TVOS_17_3() {
        return __TVOS_17_3;
    }
    private static final int __TVOS_17_4 = (int)170400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_17_4 170400
     * }
     */
    public static int __TVOS_17_4() {
        return __TVOS_17_4;
    }
    private static final int __TVOS_17_5 = (int)170500L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_17_5 170500
     * }
     */
    public static int __TVOS_17_5() {
        return __TVOS_17_5;
    }
    private static final int __TVOS_17_6 = (int)170600L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_17_6 170600
     * }
     */
    public static int __TVOS_17_6() {
        return __TVOS_17_6;
    }
    private static final int __TVOS_18_0 = (int)180000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_18_0 180000
     * }
     */
    public static int __TVOS_18_0() {
        return __TVOS_18_0;
    }
    private static final int __TVOS_18_1 = (int)180100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_18_1 180100
     * }
     */
    public static int __TVOS_18_1() {
        return __TVOS_18_1;
    }
    private static final int __TVOS_18_2 = (int)180200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_18_2 180200
     * }
     */
    public static int __TVOS_18_2() {
        return __TVOS_18_2;
    }
    private static final int __TVOS_18_3 = (int)180300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_18_3 180300
     * }
     */
    public static int __TVOS_18_3() {
        return __TVOS_18_3;
    }
    private static final int __TVOS_18_4 = (int)180400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_18_4 180400
     * }
     */
    public static int __TVOS_18_4() {
        return __TVOS_18_4;
    }
    private static final int __TVOS_18_5 = (int)180500L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_18_5 180500
     * }
     */
    public static int __TVOS_18_5() {
        return __TVOS_18_5;
    }
    private static final int __BRIDGEOS_2_0 = (int)20000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_2_0 20000
     * }
     */
    public static int __BRIDGEOS_2_0() {
        return __BRIDGEOS_2_0;
    }
    private static final int __BRIDGEOS_3_0 = (int)30000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_3_0 30000
     * }
     */
    public static int __BRIDGEOS_3_0() {
        return __BRIDGEOS_3_0;
    }
    private static final int __BRIDGEOS_3_1 = (int)30100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_3_1 30100
     * }
     */
    public static int __BRIDGEOS_3_1() {
        return __BRIDGEOS_3_1;
    }
    private static final int __BRIDGEOS_3_4 = (int)30400L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_3_4 30400
     * }
     */
    public static int __BRIDGEOS_3_4() {
        return __BRIDGEOS_3_4;
    }
    private static final int __BRIDGEOS_4_0 = (int)40000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_4_0 40000
     * }
     */
    public static int __BRIDGEOS_4_0() {
        return __BRIDGEOS_4_0;
    }
    private static final int __BRIDGEOS_4_1 = (int)40100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_4_1 40100
     * }
     */
    public static int __BRIDGEOS_4_1() {
        return __BRIDGEOS_4_1;
    }
    private static final int __BRIDGEOS_5_0 = (int)50000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_5_0 50000
     * }
     */
    public static int __BRIDGEOS_5_0() {
        return __BRIDGEOS_5_0;
    }
    private static final int __BRIDGEOS_5_1 = (int)50100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_5_1 50100
     * }
     */
    public static int __BRIDGEOS_5_1() {
        return __BRIDGEOS_5_1;
    }
    private static final int __BRIDGEOS_5_3 = (int)50300L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_5_3 50300
     * }
     */
    public static int __BRIDGEOS_5_3() {
        return __BRIDGEOS_5_3;
    }
    private static final int __BRIDGEOS_6_0 = (int)60000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_6_0 60000
     * }
     */
    public static int __BRIDGEOS_6_0() {
        return __BRIDGEOS_6_0;
    }
    private static final int __BRIDGEOS_6_2 = (int)60200L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_6_2 60200
     * }
     */
    public static int __BRIDGEOS_6_2() {
        return __BRIDGEOS_6_2;
    }
    private static final int __BRIDGEOS_6_4 = (int)60400L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_6_4 60400
     * }
     */
    public static int __BRIDGEOS_6_4() {
        return __BRIDGEOS_6_4;
    }
    private static final int __BRIDGEOS_6_5 = (int)60500L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_6_5 60500
     * }
     */
    public static int __BRIDGEOS_6_5() {
        return __BRIDGEOS_6_5;
    }
    private static final int __BRIDGEOS_6_6 = (int)60600L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_6_6 60600
     * }
     */
    public static int __BRIDGEOS_6_6() {
        return __BRIDGEOS_6_6;
    }
    private static final int __BRIDGEOS_7_0 = (int)70000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_0 70000
     * }
     */
    public static int __BRIDGEOS_7_0() {
        return __BRIDGEOS_7_0;
    }
    private static final int __BRIDGEOS_7_1 = (int)70100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_1 70100
     * }
     */
    public static int __BRIDGEOS_7_1() {
        return __BRIDGEOS_7_1;
    }
    private static final int __BRIDGEOS_7_2 = (int)70200L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_2 70200
     * }
     */
    public static int __BRIDGEOS_7_2() {
        return __BRIDGEOS_7_2;
    }
    private static final int __BRIDGEOS_7_3 = (int)70300L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_3 70300
     * }
     */
    public static int __BRIDGEOS_7_3() {
        return __BRIDGEOS_7_3;
    }
    private static final int __BRIDGEOS_7_4 = (int)70400L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_4 70400
     * }
     */
    public static int __BRIDGEOS_7_4() {
        return __BRIDGEOS_7_4;
    }
    private static final int __BRIDGEOS_7_6 = (int)70600L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_6 70600
     * }
     */
    public static int __BRIDGEOS_7_6() {
        return __BRIDGEOS_7_6;
    }
    private static final int __BRIDGEOS_8_0 = (int)80000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_8_0 80000
     * }
     */
    public static int __BRIDGEOS_8_0() {
        return __BRIDGEOS_8_0;
    }
    private static final int __BRIDGEOS_8_1 = (int)80100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_8_1 80100
     * }
     */
    public static int __BRIDGEOS_8_1() {
        return __BRIDGEOS_8_1;
    }
    private static final int __BRIDGEOS_8_2 = (int)80200L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_8_2 80200
     * }
     */
    public static int __BRIDGEOS_8_2() {
        return __BRIDGEOS_8_2;
    }
    private static final int __BRIDGEOS_8_3 = (int)80300L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_8_3 80300
     * }
     */
    public static int __BRIDGEOS_8_3() {
        return __BRIDGEOS_8_3;
    }
    private static final int __BRIDGEOS_8_4 = (int)80400L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_8_4 80400
     * }
     */
    public static int __BRIDGEOS_8_4() {
        return __BRIDGEOS_8_4;
    }
    private static final int __BRIDGEOS_8_5 = (int)80500L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_8_5 80500
     * }
     */
    public static int __BRIDGEOS_8_5() {
        return __BRIDGEOS_8_5;
    }
    private static final int __BRIDGEOS_8_6 = (int)80600L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_8_6 80600
     * }
     */
    public static int __BRIDGEOS_8_6() {
        return __BRIDGEOS_8_6;
    }
    private static final int __BRIDGEOS_9_0 = (int)90000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_9_0 90000
     * }
     */
    public static int __BRIDGEOS_9_0() {
        return __BRIDGEOS_9_0;
    }
    private static final int __BRIDGEOS_9_1 = (int)90100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_9_1 90100
     * }
     */
    public static int __BRIDGEOS_9_1() {
        return __BRIDGEOS_9_1;
    }
    private static final int __BRIDGEOS_9_2 = (int)90200L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_9_2 90200
     * }
     */
    public static int __BRIDGEOS_9_2() {
        return __BRIDGEOS_9_2;
    }
    private static final int __BRIDGEOS_9_3 = (int)90300L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_9_3 90300
     * }
     */
    public static int __BRIDGEOS_9_3() {
        return __BRIDGEOS_9_3;
    }
    private static final int __BRIDGEOS_9_4 = (int)90400L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_9_4 90400
     * }
     */
    public static int __BRIDGEOS_9_4() {
        return __BRIDGEOS_9_4;
    }
    private static final int __BRIDGEOS_9_5 = (int)90500L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_9_5 90500
     * }
     */
    public static int __BRIDGEOS_9_5() {
        return __BRIDGEOS_9_5;
    }
    private static final int __DRIVERKIT_19_0 = (int)190000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_19_0 190000
     * }
     */
    public static int __DRIVERKIT_19_0() {
        return __DRIVERKIT_19_0;
    }
    private static final int __DRIVERKIT_20_0 = (int)200000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_20_0 200000
     * }
     */
    public static int __DRIVERKIT_20_0() {
        return __DRIVERKIT_20_0;
    }
    private static final int __DRIVERKIT_21_0 = (int)210000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_21_0 210000
     * }
     */
    public static int __DRIVERKIT_21_0() {
        return __DRIVERKIT_21_0;
    }
    private static final int __DRIVERKIT_22_0 = (int)220000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_22_0 220000
     * }
     */
    public static int __DRIVERKIT_22_0() {
        return __DRIVERKIT_22_0;
    }
    private static final int __DRIVERKIT_22_4 = (int)220400L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_22_4 220400
     * }
     */
    public static int __DRIVERKIT_22_4() {
        return __DRIVERKIT_22_4;
    }
    private static final int __DRIVERKIT_22_5 = (int)220500L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_22_5 220500
     * }
     */
    public static int __DRIVERKIT_22_5() {
        return __DRIVERKIT_22_5;
    }
    private static final int __DRIVERKIT_22_6 = (int)220600L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_22_6 220600
     * }
     */
    public static int __DRIVERKIT_22_6() {
        return __DRIVERKIT_22_6;
    }
    private static final int __DRIVERKIT_23_0 = (int)230000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_23_0 230000
     * }
     */
    public static int __DRIVERKIT_23_0() {
        return __DRIVERKIT_23_0;
    }
    private static final int __DRIVERKIT_23_1 = (int)230100L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_23_1 230100
     * }
     */
    public static int __DRIVERKIT_23_1() {
        return __DRIVERKIT_23_1;
    }
    private static final int __DRIVERKIT_23_2 = (int)230200L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_23_2 230200
     * }
     */
    public static int __DRIVERKIT_23_2() {
        return __DRIVERKIT_23_2;
    }
    private static final int __DRIVERKIT_23_3 = (int)230300L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_23_3 230300
     * }
     */
    public static int __DRIVERKIT_23_3() {
        return __DRIVERKIT_23_3;
    }
    private static final int __DRIVERKIT_23_4 = (int)230400L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_23_4 230400
     * }
     */
    public static int __DRIVERKIT_23_4() {
        return __DRIVERKIT_23_4;
    }
    private static final int __DRIVERKIT_23_5 = (int)230500L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_23_5 230500
     * }
     */
    public static int __DRIVERKIT_23_5() {
        return __DRIVERKIT_23_5;
    }
    private static final int __DRIVERKIT_23_6 = (int)230600L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_23_6 230600
     * }
     */
    public static int __DRIVERKIT_23_6() {
        return __DRIVERKIT_23_6;
    }
    private static final int __DRIVERKIT_24_0 = (int)240000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_24_0 240000
     * }
     */
    public static int __DRIVERKIT_24_0() {
        return __DRIVERKIT_24_0;
    }
    private static final int __DRIVERKIT_24_1 = (int)240100L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_24_1 240100
     * }
     */
    public static int __DRIVERKIT_24_1() {
        return __DRIVERKIT_24_1;
    }
    private static final int __DRIVERKIT_24_2 = (int)240200L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_24_2 240200
     * }
     */
    public static int __DRIVERKIT_24_2() {
        return __DRIVERKIT_24_2;
    }
    private static final int __DRIVERKIT_24_3 = (int)240300L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_24_3 240300
     * }
     */
    public static int __DRIVERKIT_24_3() {
        return __DRIVERKIT_24_3;
    }
    private static final int __DRIVERKIT_24_4 = (int)240400L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_24_4 240400
     * }
     */
    public static int __DRIVERKIT_24_4() {
        return __DRIVERKIT_24_4;
    }
    private static final int __DRIVERKIT_24_5 = (int)240500L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_24_5 240500
     * }
     */
    public static int __DRIVERKIT_24_5() {
        return __DRIVERKIT_24_5;
    }
    private static final int __VISIONOS_1_0 = (int)10000L;
    /**
     * {@snippet lang=c :
     * #define __VISIONOS_1_0 10000
     * }
     */
    public static int __VISIONOS_1_0() {
        return __VISIONOS_1_0;
    }
    private static final int __VISIONOS_1_1 = (int)10100L;
    /**
     * {@snippet lang=c :
     * #define __VISIONOS_1_1 10100
     * }
     */
    public static int __VISIONOS_1_1() {
        return __VISIONOS_1_1;
    }
    private static final int __VISIONOS_1_2 = (int)10200L;
    /**
     * {@snippet lang=c :
     * #define __VISIONOS_1_2 10200
     * }
     */
    public static int __VISIONOS_1_2() {
        return __VISIONOS_1_2;
    }
    private static final int __VISIONOS_1_3 = (int)10300L;
    /**
     * {@snippet lang=c :
     * #define __VISIONOS_1_3 10300
     * }
     */
    public static int __VISIONOS_1_3() {
        return __VISIONOS_1_3;
    }
    private static final int __VISIONOS_2_0 = (int)20000L;
    /**
     * {@snippet lang=c :
     * #define __VISIONOS_2_0 20000
     * }
     */
    public static int __VISIONOS_2_0() {
        return __VISIONOS_2_0;
    }
    private static final int __VISIONOS_2_1 = (int)20100L;
    /**
     * {@snippet lang=c :
     * #define __VISIONOS_2_1 20100
     * }
     */
    public static int __VISIONOS_2_1() {
        return __VISIONOS_2_1;
    }
    private static final int __VISIONOS_2_2 = (int)20200L;
    /**
     * {@snippet lang=c :
     * #define __VISIONOS_2_2 20200
     * }
     */
    public static int __VISIONOS_2_2() {
        return __VISIONOS_2_2;
    }
    private static final int __VISIONOS_2_3 = (int)20300L;
    /**
     * {@snippet lang=c :
     * #define __VISIONOS_2_3 20300
     * }
     */
    public static int __VISIONOS_2_3() {
        return __VISIONOS_2_3;
    }
    private static final int __VISIONOS_2_4 = (int)20400L;
    /**
     * {@snippet lang=c :
     * #define __VISIONOS_2_4 20400
     * }
     */
    public static int __VISIONOS_2_4() {
        return __VISIONOS_2_4;
    }
    private static final int __VISIONOS_2_5 = (int)20500L;
    /**
     * {@snippet lang=c :
     * #define __VISIONOS_2_5 20500
     * }
     */
    public static int __VISIONOS_2_5() {
        return __VISIONOS_2_5;
    }
    private static final int __ENABLE_LEGACY_MAC_AVAILABILITY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __ENABLE_LEGACY_MAC_AVAILABILITY 1
     * }
     */
    public static int __ENABLE_LEGACY_MAC_AVAILABILITY() {
        return __ENABLE_LEGACY_MAC_AVAILABILITY;
    }
    private static final int _FORTIFY_SOURCE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _FORTIFY_SOURCE 2
     * }
     */
    public static int _FORTIFY_SOURCE() {
        return _FORTIFY_SOURCE;
    }
    private static final int __DARWIN_NSIG = (int)32L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NSIG 32
     * }
     */
    public static int __DARWIN_NSIG() {
        return __DARWIN_NSIG;
    }
    private static final int _ARM_SIGNAL_ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ARM_SIGNAL_ 1
     * }
     */
    public static int _ARM_SIGNAL_() {
        return _ARM_SIGNAL_;
    }
    private static final int SIGHUP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SIGHUP 1
     * }
     */
    public static int SIGHUP() {
        return SIGHUP;
    }
    private static final int SIGINT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SIGINT 2
     * }
     */
    public static int SIGINT() {
        return SIGINT;
    }
    private static final int SIGQUIT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SIGQUIT 3
     * }
     */
    public static int SIGQUIT() {
        return SIGQUIT;
    }
    private static final int SIGILL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SIGILL 4
     * }
     */
    public static int SIGILL() {
        return SIGILL;
    }
    private static final int SIGTRAP = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SIGTRAP 5
     * }
     */
    public static int SIGTRAP() {
        return SIGTRAP;
    }
    private static final int SIGABRT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define SIGABRT 6
     * }
     */
    public static int SIGABRT() {
        return SIGABRT;
    }
    private static final int SIGEMT = (int)7L;
    /**
     * {@snippet lang=c :
     * #define SIGEMT 7
     * }
     */
    public static int SIGEMT() {
        return SIGEMT;
    }
    private static final int SIGFPE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SIGFPE 8
     * }
     */
    public static int SIGFPE() {
        return SIGFPE;
    }
    private static final int SIGKILL = (int)9L;
    /**
     * {@snippet lang=c :
     * #define SIGKILL 9
     * }
     */
    public static int SIGKILL() {
        return SIGKILL;
    }
    private static final int SIGBUS = (int)10L;
    /**
     * {@snippet lang=c :
     * #define SIGBUS 10
     * }
     */
    public static int SIGBUS() {
        return SIGBUS;
    }
    private static final int SIGSEGV = (int)11L;
    /**
     * {@snippet lang=c :
     * #define SIGSEGV 11
     * }
     */
    public static int SIGSEGV() {
        return SIGSEGV;
    }
    private static final int SIGSYS = (int)12L;
    /**
     * {@snippet lang=c :
     * #define SIGSYS 12
     * }
     */
    public static int SIGSYS() {
        return SIGSYS;
    }
    private static final int SIGPIPE = (int)13L;
    /**
     * {@snippet lang=c :
     * #define SIGPIPE 13
     * }
     */
    public static int SIGPIPE() {
        return SIGPIPE;
    }
    private static final int SIGALRM = (int)14L;
    /**
     * {@snippet lang=c :
     * #define SIGALRM 14
     * }
     */
    public static int SIGALRM() {
        return SIGALRM;
    }
    private static final int SIGTERM = (int)15L;
    /**
     * {@snippet lang=c :
     * #define SIGTERM 15
     * }
     */
    public static int SIGTERM() {
        return SIGTERM;
    }
    private static final int SIGURG = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SIGURG 16
     * }
     */
    public static int SIGURG() {
        return SIGURG;
    }
    private static final int SIGSTOP = (int)17L;
    /**
     * {@snippet lang=c :
     * #define SIGSTOP 17
     * }
     */
    public static int SIGSTOP() {
        return SIGSTOP;
    }
    private static final int SIGTSTP = (int)18L;
    /**
     * {@snippet lang=c :
     * #define SIGTSTP 18
     * }
     */
    public static int SIGTSTP() {
        return SIGTSTP;
    }
    private static final int SIGCONT = (int)19L;
    /**
     * {@snippet lang=c :
     * #define SIGCONT 19
     * }
     */
    public static int SIGCONT() {
        return SIGCONT;
    }
    private static final int SIGCHLD = (int)20L;
    /**
     * {@snippet lang=c :
     * #define SIGCHLD 20
     * }
     */
    public static int SIGCHLD() {
        return SIGCHLD;
    }
    private static final int SIGTTIN = (int)21L;
    /**
     * {@snippet lang=c :
     * #define SIGTTIN 21
     * }
     */
    public static int SIGTTIN() {
        return SIGTTIN;
    }
    private static final int SIGTTOU = (int)22L;
    /**
     * {@snippet lang=c :
     * #define SIGTTOU 22
     * }
     */
    public static int SIGTTOU() {
        return SIGTTOU;
    }
    private static final int SIGIO = (int)23L;
    /**
     * {@snippet lang=c :
     * #define SIGIO 23
     * }
     */
    public static int SIGIO() {
        return SIGIO;
    }
    private static final int SIGXCPU = (int)24L;
    /**
     * {@snippet lang=c :
     * #define SIGXCPU 24
     * }
     */
    public static int SIGXCPU() {
        return SIGXCPU;
    }
    private static final int SIGXFSZ = (int)25L;
    /**
     * {@snippet lang=c :
     * #define SIGXFSZ 25
     * }
     */
    public static int SIGXFSZ() {
        return SIGXFSZ;
    }
    private static final int SIGVTALRM = (int)26L;
    /**
     * {@snippet lang=c :
     * #define SIGVTALRM 26
     * }
     */
    public static int SIGVTALRM() {
        return SIGVTALRM;
    }
    private static final int SIGPROF = (int)27L;
    /**
     * {@snippet lang=c :
     * #define SIGPROF 27
     * }
     */
    public static int SIGPROF() {
        return SIGPROF;
    }
    private static final int SIGWINCH = (int)28L;
    /**
     * {@snippet lang=c :
     * #define SIGWINCH 28
     * }
     */
    public static int SIGWINCH() {
        return SIGWINCH;
    }
    private static final int SIGINFO = (int)29L;
    /**
     * {@snippet lang=c :
     * #define SIGINFO 29
     * }
     */
    public static int SIGINFO() {
        return SIGINFO;
    }
    private static final int SIGUSR1 = (int)30L;
    /**
     * {@snippet lang=c :
     * #define SIGUSR1 30
     * }
     */
    public static int SIGUSR1() {
        return SIGUSR1;
    }
    private static final int SIGUSR2 = (int)31L;
    /**
     * {@snippet lang=c :
     * #define SIGUSR2 31
     * }
     */
    public static int SIGUSR2() {
        return SIGUSR2;
    }
    private static final int __DARWIN_OPAQUE_ARM_THREAD_STATE64 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_OPAQUE_ARM_THREAD_STATE64 0
     * }
     */
    public static int __DARWIN_OPAQUE_ARM_THREAD_STATE64() {
        return __DARWIN_OPAQUE_ARM_THREAD_STATE64;
    }
    private static final int USE_CLANG_STDDEF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define USE_CLANG_STDDEF 0
     * }
     */
    public static int USE_CLANG_STDDEF() {
        return USE_CLANG_STDDEF;
    }
    private static final int SIGEV_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SIGEV_NONE 0
     * }
     */
    public static int SIGEV_NONE() {
        return SIGEV_NONE;
    }
    private static final int SIGEV_SIGNAL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SIGEV_SIGNAL 1
     * }
     */
    public static int SIGEV_SIGNAL() {
        return SIGEV_SIGNAL;
    }
    private static final int SIGEV_THREAD = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SIGEV_THREAD 3
     * }
     */
    public static int SIGEV_THREAD() {
        return SIGEV_THREAD;
    }
    private static final int ILL_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define ILL_NOOP 0
     * }
     */
    public static int ILL_NOOP() {
        return ILL_NOOP;
    }
    private static final int ILL_ILLOPC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ILL_ILLOPC 1
     * }
     */
    public static int ILL_ILLOPC() {
        return ILL_ILLOPC;
    }
    private static final int ILL_ILLTRP = (int)2L;
    /**
     * {@snippet lang=c :
     * #define ILL_ILLTRP 2
     * }
     */
    public static int ILL_ILLTRP() {
        return ILL_ILLTRP;
    }
    private static final int ILL_PRVOPC = (int)3L;
    /**
     * {@snippet lang=c :
     * #define ILL_PRVOPC 3
     * }
     */
    public static int ILL_PRVOPC() {
        return ILL_PRVOPC;
    }
    private static final int ILL_ILLOPN = (int)4L;
    /**
     * {@snippet lang=c :
     * #define ILL_ILLOPN 4
     * }
     */
    public static int ILL_ILLOPN() {
        return ILL_ILLOPN;
    }
    private static final int ILL_ILLADR = (int)5L;
    /**
     * {@snippet lang=c :
     * #define ILL_ILLADR 5
     * }
     */
    public static int ILL_ILLADR() {
        return ILL_ILLADR;
    }
    private static final int ILL_PRVREG = (int)6L;
    /**
     * {@snippet lang=c :
     * #define ILL_PRVREG 6
     * }
     */
    public static int ILL_PRVREG() {
        return ILL_PRVREG;
    }
    private static final int ILL_COPROC = (int)7L;
    /**
     * {@snippet lang=c :
     * #define ILL_COPROC 7
     * }
     */
    public static int ILL_COPROC() {
        return ILL_COPROC;
    }
    private static final int ILL_BADSTK = (int)8L;
    /**
     * {@snippet lang=c :
     * #define ILL_BADSTK 8
     * }
     */
    public static int ILL_BADSTK() {
        return ILL_BADSTK;
    }
    private static final int FPE_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FPE_NOOP 0
     * }
     */
    public static int FPE_NOOP() {
        return FPE_NOOP;
    }
    private static final int FPE_FLTDIV = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTDIV 1
     * }
     */
    public static int FPE_FLTDIV() {
        return FPE_FLTDIV;
    }
    private static final int FPE_FLTOVF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTOVF 2
     * }
     */
    public static int FPE_FLTOVF() {
        return FPE_FLTOVF;
    }
    private static final int FPE_FLTUND = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTUND 3
     * }
     */
    public static int FPE_FLTUND() {
        return FPE_FLTUND;
    }
    private static final int FPE_FLTRES = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTRES 4
     * }
     */
    public static int FPE_FLTRES() {
        return FPE_FLTRES;
    }
    private static final int FPE_FLTINV = (int)5L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTINV 5
     * }
     */
    public static int FPE_FLTINV() {
        return FPE_FLTINV;
    }
    private static final int FPE_FLTSUB = (int)6L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTSUB 6
     * }
     */
    public static int FPE_FLTSUB() {
        return FPE_FLTSUB;
    }
    private static final int FPE_INTDIV = (int)7L;
    /**
     * {@snippet lang=c :
     * #define FPE_INTDIV 7
     * }
     */
    public static int FPE_INTDIV() {
        return FPE_INTDIV;
    }
    private static final int FPE_INTOVF = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FPE_INTOVF 8
     * }
     */
    public static int FPE_INTOVF() {
        return FPE_INTOVF;
    }
    private static final int SEGV_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEGV_NOOP 0
     * }
     */
    public static int SEGV_NOOP() {
        return SEGV_NOOP;
    }
    private static final int SEGV_MAPERR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEGV_MAPERR 1
     * }
     */
    public static int SEGV_MAPERR() {
        return SEGV_MAPERR;
    }
    private static final int SEGV_ACCERR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEGV_ACCERR 2
     * }
     */
    public static int SEGV_ACCERR() {
        return SEGV_ACCERR;
    }
    private static final int BUS_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define BUS_NOOP 0
     * }
     */
    public static int BUS_NOOP() {
        return BUS_NOOP;
    }
    private static final int BUS_ADRALN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define BUS_ADRALN 1
     * }
     */
    public static int BUS_ADRALN() {
        return BUS_ADRALN;
    }
    private static final int BUS_ADRERR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define BUS_ADRERR 2
     * }
     */
    public static int BUS_ADRERR() {
        return BUS_ADRERR;
    }
    private static final int BUS_OBJERR = (int)3L;
    /**
     * {@snippet lang=c :
     * #define BUS_OBJERR 3
     * }
     */
    public static int BUS_OBJERR() {
        return BUS_OBJERR;
    }
    private static final int TRAP_BRKPT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TRAP_BRKPT 1
     * }
     */
    public static int TRAP_BRKPT() {
        return TRAP_BRKPT;
    }
    private static final int TRAP_TRACE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define TRAP_TRACE 2
     * }
     */
    public static int TRAP_TRACE() {
        return TRAP_TRACE;
    }
    private static final int CLD_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CLD_NOOP 0
     * }
     */
    public static int CLD_NOOP() {
        return CLD_NOOP;
    }
    private static final int CLD_EXITED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CLD_EXITED 1
     * }
     */
    public static int CLD_EXITED() {
        return CLD_EXITED;
    }
    private static final int CLD_KILLED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CLD_KILLED 2
     * }
     */
    public static int CLD_KILLED() {
        return CLD_KILLED;
    }
    private static final int CLD_DUMPED = (int)3L;
    /**
     * {@snippet lang=c :
     * #define CLD_DUMPED 3
     * }
     */
    public static int CLD_DUMPED() {
        return CLD_DUMPED;
    }
    private static final int CLD_TRAPPED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CLD_TRAPPED 4
     * }
     */
    public static int CLD_TRAPPED() {
        return CLD_TRAPPED;
    }
    private static final int CLD_STOPPED = (int)5L;
    /**
     * {@snippet lang=c :
     * #define CLD_STOPPED 5
     * }
     */
    public static int CLD_STOPPED() {
        return CLD_STOPPED;
    }
    private static final int CLD_CONTINUED = (int)6L;
    /**
     * {@snippet lang=c :
     * #define CLD_CONTINUED 6
     * }
     */
    public static int CLD_CONTINUED() {
        return CLD_CONTINUED;
    }
    private static final int POLL_IN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define POLL_IN 1
     * }
     */
    public static int POLL_IN() {
        return POLL_IN;
    }
    private static final int POLL_OUT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define POLL_OUT 2
     * }
     */
    public static int POLL_OUT() {
        return POLL_OUT;
    }
    private static final int POLL_MSG = (int)3L;
    /**
     * {@snippet lang=c :
     * #define POLL_MSG 3
     * }
     */
    public static int POLL_MSG() {
        return POLL_MSG;
    }
    private static final int POLL_ERR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define POLL_ERR 4
     * }
     */
    public static int POLL_ERR() {
        return POLL_ERR;
    }
    private static final int POLL_PRI = (int)5L;
    /**
     * {@snippet lang=c :
     * #define POLL_PRI 5
     * }
     */
    public static int POLL_PRI() {
        return POLL_PRI;
    }
    private static final int POLL_HUP = (int)6L;
    /**
     * {@snippet lang=c :
     * #define POLL_HUP 6
     * }
     */
    public static int POLL_HUP() {
        return POLL_HUP;
    }
    private static final int SA_ONSTACK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SA_ONSTACK 1
     * }
     */
    public static int SA_ONSTACK() {
        return SA_ONSTACK;
    }
    private static final int SA_RESTART = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SA_RESTART 2
     * }
     */
    public static int SA_RESTART() {
        return SA_RESTART;
    }
    private static final int SA_RESETHAND = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SA_RESETHAND 4
     * }
     */
    public static int SA_RESETHAND() {
        return SA_RESETHAND;
    }
    private static final int SA_NOCLDSTOP = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SA_NOCLDSTOP 8
     * }
     */
    public static int SA_NOCLDSTOP() {
        return SA_NOCLDSTOP;
    }
    private static final int SA_NODEFER = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SA_NODEFER 16
     * }
     */
    public static int SA_NODEFER() {
        return SA_NODEFER;
    }
    private static final int SA_NOCLDWAIT = (int)32L;
    /**
     * {@snippet lang=c :
     * #define SA_NOCLDWAIT 32
     * }
     */
    public static int SA_NOCLDWAIT() {
        return SA_NOCLDWAIT;
    }
    private static final int SA_SIGINFO = (int)64L;
    /**
     * {@snippet lang=c :
     * #define SA_SIGINFO 64
     * }
     */
    public static int SA_SIGINFO() {
        return SA_SIGINFO;
    }
    private static final int SA_USERTRAMP = (int)256L;
    /**
     * {@snippet lang=c :
     * #define SA_USERTRAMP 256
     * }
     */
    public static int SA_USERTRAMP() {
        return SA_USERTRAMP;
    }
    private static final int SA_64REGSET = (int)512L;
    /**
     * {@snippet lang=c :
     * #define SA_64REGSET 512
     * }
     */
    public static int SA_64REGSET() {
        return SA_64REGSET;
    }
    private static final int SIG_BLOCK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SIG_BLOCK 1
     * }
     */
    public static int SIG_BLOCK() {
        return SIG_BLOCK;
    }
    private static final int SIG_UNBLOCK = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SIG_UNBLOCK 2
     * }
     */
    public static int SIG_UNBLOCK() {
        return SIG_UNBLOCK;
    }
    private static final int SIG_SETMASK = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SIG_SETMASK 3
     * }
     */
    public static int SIG_SETMASK() {
        return SIG_SETMASK;
    }
    private static final int SI_USER = (int)65537L;
    /**
     * {@snippet lang=c :
     * #define SI_USER 65537
     * }
     */
    public static int SI_USER() {
        return SI_USER;
    }
    private static final int SI_QUEUE = (int)65538L;
    /**
     * {@snippet lang=c :
     * #define SI_QUEUE 65538
     * }
     */
    public static int SI_QUEUE() {
        return SI_QUEUE;
    }
    private static final int SI_TIMER = (int)65539L;
    /**
     * {@snippet lang=c :
     * #define SI_TIMER 65539
     * }
     */
    public static int SI_TIMER() {
        return SI_TIMER;
    }
    private static final int SI_ASYNCIO = (int)65540L;
    /**
     * {@snippet lang=c :
     * #define SI_ASYNCIO 65540
     * }
     */
    public static int SI_ASYNCIO() {
        return SI_ASYNCIO;
    }
    private static final int SI_MESGQ = (int)65541L;
    /**
     * {@snippet lang=c :
     * #define SI_MESGQ 65541
     * }
     */
    public static int SI_MESGQ() {
        return SI_MESGQ;
    }
    private static final int SS_ONSTACK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SS_ONSTACK 1
     * }
     */
    public static int SS_ONSTACK() {
        return SS_ONSTACK;
    }
    private static final int SS_DISABLE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SS_DISABLE 4
     * }
     */
    public static int SS_DISABLE() {
        return SS_DISABLE;
    }
    private static final int MINSIGSTKSZ = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define MINSIGSTKSZ 32768
     * }
     */
    public static int MINSIGSTKSZ() {
        return MINSIGSTKSZ;
    }
    private static final int SIGSTKSZ = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define SIGSTKSZ 131072
     * }
     */
    public static int SIGSTKSZ() {
        return SIGSTKSZ;
    }
    private static final int PRIO_PROCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PRIO_PROCESS 0
     * }
     */
    public static int PRIO_PROCESS() {
        return PRIO_PROCESS;
    }
    private static final int PRIO_PGRP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PRIO_PGRP 1
     * }
     */
    public static int PRIO_PGRP() {
        return PRIO_PGRP;
    }
    private static final int PRIO_USER = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PRIO_USER 2
     * }
     */
    public static int PRIO_USER() {
        return PRIO_USER;
    }
    private static final int PRIO_DARWIN_THREAD = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PRIO_DARWIN_THREAD 3
     * }
     */
    public static int PRIO_DARWIN_THREAD() {
        return PRIO_DARWIN_THREAD;
    }
    private static final int PRIO_DARWIN_PROCESS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PRIO_DARWIN_PROCESS 4
     * }
     */
    public static int PRIO_DARWIN_PROCESS() {
        return PRIO_DARWIN_PROCESS;
    }
    private static final int PRIO_MAX = (int)20L;
    /**
     * {@snippet lang=c :
     * #define PRIO_MAX 20
     * }
     */
    public static int PRIO_MAX() {
        return PRIO_MAX;
    }
    private static final int PRIO_DARWIN_BG = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define PRIO_DARWIN_BG 4096
     * }
     */
    public static int PRIO_DARWIN_BG() {
        return PRIO_DARWIN_BG;
    }
    private static final int PRIO_DARWIN_NONUI = (int)4097L;
    /**
     * {@snippet lang=c :
     * #define PRIO_DARWIN_NONUI 4097
     * }
     */
    public static int PRIO_DARWIN_NONUI() {
        return PRIO_DARWIN_NONUI;
    }
    private static final int RUSAGE_SELF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_SELF 0
     * }
     */
    public static int RUSAGE_SELF() {
        return RUSAGE_SELF;
    }
    private static final int RUSAGE_INFO_V0 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V0 0
     * }
     */
    public static int RUSAGE_INFO_V0() {
        return RUSAGE_INFO_V0;
    }
    private static final int RUSAGE_INFO_V1 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V1 1
     * }
     */
    public static int RUSAGE_INFO_V1() {
        return RUSAGE_INFO_V1;
    }
    private static final int RUSAGE_INFO_V2 = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V2 2
     * }
     */
    public static int RUSAGE_INFO_V2() {
        return RUSAGE_INFO_V2;
    }
    private static final int RUSAGE_INFO_V3 = (int)3L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V3 3
     * }
     */
    public static int RUSAGE_INFO_V3() {
        return RUSAGE_INFO_V3;
    }
    private static final int RUSAGE_INFO_V4 = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V4 4
     * }
     */
    public static int RUSAGE_INFO_V4() {
        return RUSAGE_INFO_V4;
    }
    private static final int RUSAGE_INFO_V5 = (int)5L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V5 5
     * }
     */
    public static int RUSAGE_INFO_V5() {
        return RUSAGE_INFO_V5;
    }
    private static final int RUSAGE_INFO_V6 = (int)6L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V6 6
     * }
     */
    public static int RUSAGE_INFO_V6() {
        return RUSAGE_INFO_V6;
    }
    private static final int RU_PROC_RUNS_RESLIDE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RU_PROC_RUNS_RESLIDE 1
     * }
     */
    public static int RU_PROC_RUNS_RESLIDE() {
        return RU_PROC_RUNS_RESLIDE;
    }
    private static final int RLIMIT_CPU = (int)0L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_CPU 0
     * }
     */
    public static int RLIMIT_CPU() {
        return RLIMIT_CPU;
    }
    private static final int RLIMIT_FSIZE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_FSIZE 1
     * }
     */
    public static int RLIMIT_FSIZE() {
        return RLIMIT_FSIZE;
    }
    private static final int RLIMIT_DATA = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_DATA 2
     * }
     */
    public static int RLIMIT_DATA() {
        return RLIMIT_DATA;
    }
    private static final int RLIMIT_STACK = (int)3L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_STACK 3
     * }
     */
    public static int RLIMIT_STACK() {
        return RLIMIT_STACK;
    }
    private static final int RLIMIT_CORE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_CORE 4
     * }
     */
    public static int RLIMIT_CORE() {
        return RLIMIT_CORE;
    }
    private static final int RLIMIT_AS = (int)5L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_AS 5
     * }
     */
    public static int RLIMIT_AS() {
        return RLIMIT_AS;
    }
    private static final int RLIMIT_MEMLOCK = (int)6L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_MEMLOCK 6
     * }
     */
    public static int RLIMIT_MEMLOCK() {
        return RLIMIT_MEMLOCK;
    }
    private static final int RLIMIT_NPROC = (int)7L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_NPROC 7
     * }
     */
    public static int RLIMIT_NPROC() {
        return RLIMIT_NPROC;
    }
    private static final int RLIMIT_NOFILE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_NOFILE 8
     * }
     */
    public static int RLIMIT_NOFILE() {
        return RLIMIT_NOFILE;
    }
    private static final int RLIM_NLIMITS = (int)9L;
    /**
     * {@snippet lang=c :
     * #define RLIM_NLIMITS 9
     * }
     */
    public static int RLIM_NLIMITS() {
        return RLIM_NLIMITS;
    }
    private static final int _RLIMIT_POSIX_FLAG = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define _RLIMIT_POSIX_FLAG 4096
     * }
     */
    public static int _RLIMIT_POSIX_FLAG() {
        return _RLIMIT_POSIX_FLAG;
    }
    private static final int RLIMIT_WAKEUPS_MONITOR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_WAKEUPS_MONITOR 1
     * }
     */
    public static int RLIMIT_WAKEUPS_MONITOR() {
        return RLIMIT_WAKEUPS_MONITOR;
    }
    private static final int RLIMIT_CPU_USAGE_MONITOR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_CPU_USAGE_MONITOR 2
     * }
     */
    public static int RLIMIT_CPU_USAGE_MONITOR() {
        return RLIMIT_CPU_USAGE_MONITOR;
    }
    private static final int RLIMIT_THREAD_CPULIMITS = (int)3L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_THREAD_CPULIMITS 3
     * }
     */
    public static int RLIMIT_THREAD_CPULIMITS() {
        return RLIMIT_THREAD_CPULIMITS;
    }
    private static final int RLIMIT_FOOTPRINT_INTERVAL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_FOOTPRINT_INTERVAL 4
     * }
     */
    public static int RLIMIT_FOOTPRINT_INTERVAL() {
        return RLIMIT_FOOTPRINT_INTERVAL;
    }
    private static final int WAKEMON_ENABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WAKEMON_ENABLE 1
     * }
     */
    public static int WAKEMON_ENABLE() {
        return WAKEMON_ENABLE;
    }
    private static final int WAKEMON_DISABLE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WAKEMON_DISABLE 2
     * }
     */
    public static int WAKEMON_DISABLE() {
        return WAKEMON_DISABLE;
    }
    private static final int WAKEMON_GET_PARAMS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define WAKEMON_GET_PARAMS 4
     * }
     */
    public static int WAKEMON_GET_PARAMS() {
        return WAKEMON_GET_PARAMS;
    }
    private static final int WAKEMON_SET_DEFAULTS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define WAKEMON_SET_DEFAULTS 8
     * }
     */
    public static int WAKEMON_SET_DEFAULTS() {
        return WAKEMON_SET_DEFAULTS;
    }
    private static final int WAKEMON_MAKE_FATAL = (int)16L;
    /**
     * {@snippet lang=c :
     * #define WAKEMON_MAKE_FATAL 16
     * }
     */
    public static int WAKEMON_MAKE_FATAL() {
        return WAKEMON_MAKE_FATAL;
    }
    private static final int CPUMON_MAKE_FATAL = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define CPUMON_MAKE_FATAL 4096
     * }
     */
    public static int CPUMON_MAKE_FATAL() {
        return CPUMON_MAKE_FATAL;
    }
    private static final int FOOTPRINT_INTERVAL_RESET = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FOOTPRINT_INTERVAL_RESET 1
     * }
     */
    public static int FOOTPRINT_INTERVAL_RESET() {
        return FOOTPRINT_INTERVAL_RESET;
    }
    private static final int IOPOL_TYPE_DISK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_DISK 0
     * }
     */
    public static int IOPOL_TYPE_DISK() {
        return IOPOL_TYPE_DISK;
    }
    private static final int IOPOL_TYPE_VFS_ATIME_UPDATES = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_ATIME_UPDATES 2
     * }
     */
    public static int IOPOL_TYPE_VFS_ATIME_UPDATES() {
        return IOPOL_TYPE_VFS_ATIME_UPDATES;
    }
    private static final int IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES = (int)3L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES 3
     * }
     */
    public static int IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES() {
        return IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES;
    }
    private static final int IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME = (int)4L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME 4
     * }
     */
    public static int IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME() {
        return IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME;
    }
    private static final int IOPOL_TYPE_VFS_TRIGGER_RESOLVE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_TRIGGER_RESOLVE 5
     * }
     */
    public static int IOPOL_TYPE_VFS_TRIGGER_RESOLVE() {
        return IOPOL_TYPE_VFS_TRIGGER_RESOLVE;
    }
    private static final int IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION = (int)6L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION 6
     * }
     */
    public static int IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION() {
        return IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION;
    }
    private static final int IOPOL_TYPE_VFS_IGNORE_PERMISSIONS = (int)7L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_IGNORE_PERMISSIONS 7
     * }
     */
    public static int IOPOL_TYPE_VFS_IGNORE_PERMISSIONS() {
        return IOPOL_TYPE_VFS_IGNORE_PERMISSIONS;
    }
    private static final int IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE 8
     * }
     */
    public static int IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE() {
        return IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE;
    }
    private static final int IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES = (int)9L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES 9
     * }
     */
    public static int IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES() {
        return IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES;
    }
    private static final int IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY = (int)10L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY 10
     * }
     */
    public static int IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY() {
        return IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY;
    }
    private static final int IOPOL_SCOPE_PROCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_SCOPE_PROCESS 0
     * }
     */
    public static int IOPOL_SCOPE_PROCESS() {
        return IOPOL_SCOPE_PROCESS;
    }
    private static final int IOPOL_SCOPE_THREAD = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_SCOPE_THREAD 1
     * }
     */
    public static int IOPOL_SCOPE_THREAD() {
        return IOPOL_SCOPE_THREAD;
    }
    private static final int IOPOL_SCOPE_DARWIN_BG = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_SCOPE_DARWIN_BG 2
     * }
     */
    public static int IOPOL_SCOPE_DARWIN_BG() {
        return IOPOL_SCOPE_DARWIN_BG;
    }
    private static final int IOPOL_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_DEFAULT 0
     * }
     */
    public static int IOPOL_DEFAULT() {
        return IOPOL_DEFAULT;
    }
    private static final int IOPOL_IMPORTANT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_IMPORTANT 1
     * }
     */
    public static int IOPOL_IMPORTANT() {
        return IOPOL_IMPORTANT;
    }
    private static final int IOPOL_PASSIVE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_PASSIVE 2
     * }
     */
    public static int IOPOL_PASSIVE() {
        return IOPOL_PASSIVE;
    }
    private static final int IOPOL_THROTTLE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_THROTTLE 3
     * }
     */
    public static int IOPOL_THROTTLE() {
        return IOPOL_THROTTLE;
    }
    private static final int IOPOL_UTILITY = (int)4L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_UTILITY 4
     * }
     */
    public static int IOPOL_UTILITY() {
        return IOPOL_UTILITY;
    }
    private static final int IOPOL_STANDARD = (int)5L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_STANDARD 5
     * }
     */
    public static int IOPOL_STANDARD() {
        return IOPOL_STANDARD;
    }
    private static final int IOPOL_ATIME_UPDATES_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_ATIME_UPDATES_DEFAULT 0
     * }
     */
    public static int IOPOL_ATIME_UPDATES_DEFAULT() {
        return IOPOL_ATIME_UPDATES_DEFAULT;
    }
    private static final int IOPOL_ATIME_UPDATES_OFF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_ATIME_UPDATES_OFF 1
     * }
     */
    public static int IOPOL_ATIME_UPDATES_OFF() {
        return IOPOL_ATIME_UPDATES_OFF;
    }
    private static final int IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT 0
     * }
     */
    public static int IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT() {
        return IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT;
    }
    private static final int IOPOL_MATERIALIZE_DATALESS_FILES_OFF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_MATERIALIZE_DATALESS_FILES_OFF 1
     * }
     */
    public static int IOPOL_MATERIALIZE_DATALESS_FILES_OFF() {
        return IOPOL_MATERIALIZE_DATALESS_FILES_OFF;
    }
    private static final int IOPOL_MATERIALIZE_DATALESS_FILES_ON = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_MATERIALIZE_DATALESS_FILES_ON 2
     * }
     */
    public static int IOPOL_MATERIALIZE_DATALESS_FILES_ON() {
        return IOPOL_MATERIALIZE_DATALESS_FILES_ON;
    }
    private static final int IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT 0
     * }
     */
    public static int IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT() {
        return IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT;
    }
    private static final int IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME 1
     * }
     */
    public static int IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME() {
        return IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME;
    }
    private static final int IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT 0
     * }
     */
    public static int IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT() {
        return IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT;
    }
    private static final int IOPOL_VFS_TRIGGER_RESOLVE_OFF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_TRIGGER_RESOLVE_OFF 1
     * }
     */
    public static int IOPOL_VFS_TRIGGER_RESOLVE_OFF() {
        return IOPOL_VFS_TRIGGER_RESOLVE_OFF;
    }
    private static final int IOPOL_VFS_CONTENT_PROTECTION_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_CONTENT_PROTECTION_DEFAULT 0
     * }
     */
    public static int IOPOL_VFS_CONTENT_PROTECTION_DEFAULT() {
        return IOPOL_VFS_CONTENT_PROTECTION_DEFAULT;
    }
    private static final int IOPOL_VFS_CONTENT_PROTECTION_IGNORE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_CONTENT_PROTECTION_IGNORE 1
     * }
     */
    public static int IOPOL_VFS_CONTENT_PROTECTION_IGNORE() {
        return IOPOL_VFS_CONTENT_PROTECTION_IGNORE;
    }
    private static final int IOPOL_VFS_IGNORE_PERMISSIONS_OFF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_IGNORE_PERMISSIONS_OFF 0
     * }
     */
    public static int IOPOL_VFS_IGNORE_PERMISSIONS_OFF() {
        return IOPOL_VFS_IGNORE_PERMISSIONS_OFF;
    }
    private static final int IOPOL_VFS_IGNORE_PERMISSIONS_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_IGNORE_PERMISSIONS_ON 1
     * }
     */
    public static int IOPOL_VFS_IGNORE_PERMISSIONS_ON() {
        return IOPOL_VFS_IGNORE_PERMISSIONS_ON;
    }
    private static final int IOPOL_VFS_SKIP_MTIME_UPDATE_OFF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_SKIP_MTIME_UPDATE_OFF 0
     * }
     */
    public static int IOPOL_VFS_SKIP_MTIME_UPDATE_OFF() {
        return IOPOL_VFS_SKIP_MTIME_UPDATE_OFF;
    }
    private static final int IOPOL_VFS_SKIP_MTIME_UPDATE_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_SKIP_MTIME_UPDATE_ON 1
     * }
     */
    public static int IOPOL_VFS_SKIP_MTIME_UPDATE_ON() {
        return IOPOL_VFS_SKIP_MTIME_UPDATE_ON;
    }
    private static final int IOPOL_VFS_SKIP_MTIME_UPDATE_IGNORE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_SKIP_MTIME_UPDATE_IGNORE 2
     * }
     */
    public static int IOPOL_VFS_SKIP_MTIME_UPDATE_IGNORE() {
        return IOPOL_VFS_SKIP_MTIME_UPDATE_IGNORE;
    }
    private static final int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF 0
     * }
     */
    public static int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF() {
        return IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF;
    }
    private static final int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON 1
     * }
     */
    public static int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON() {
        return IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON;
    }
    private static final int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT 0
     * }
     */
    public static int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT() {
        return IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT;
    }
    private static final int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON 1
     * }
     */
    public static int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON() {
        return IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON;
    }
    private static final int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT 0
     * }
     */
    public static int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT() {
        return IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT;
    }
    private static final int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON 1
     * }
     */
    public static int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON() {
        return IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON;
    }
    private static final int WNOHANG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WNOHANG 1
     * }
     */
    public static int WNOHANG() {
        return WNOHANG;
    }
    private static final int WUNTRACED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WUNTRACED 2
     * }
     */
    public static int WUNTRACED() {
        return WUNTRACED;
    }
    private static final int WCOREFLAG = (int)128L;
    /**
     * {@snippet lang=c :
     * #define WCOREFLAG 128
     * }
     */
    public static int WCOREFLAG() {
        return WCOREFLAG;
    }
    private static final int _WSTOPPED = (int)127L;
    /**
     * {@snippet lang=c :
     * #define _WSTOPPED 127
     * }
     */
    public static int _WSTOPPED() {
        return _WSTOPPED;
    }
    private static final int WEXITED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define WEXITED 4
     * }
     */
    public static int WEXITED() {
        return WEXITED;
    }
    private static final int WSTOPPED = (int)8L;
    /**
     * {@snippet lang=c :
     * #define WSTOPPED 8
     * }
     */
    public static int WSTOPPED() {
        return WSTOPPED;
    }
    private static final int WCONTINUED = (int)16L;
    /**
     * {@snippet lang=c :
     * #define WCONTINUED 16
     * }
     */
    public static int WCONTINUED() {
        return WCONTINUED;
    }
    private static final int WNOWAIT = (int)32L;
    /**
     * {@snippet lang=c :
     * #define WNOWAIT 32
     * }
     */
    public static int WNOWAIT() {
        return WNOWAIT;
    }
    private static final int WAIT_MYPGRP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WAIT_MYPGRP 0
     * }
     */
    public static int WAIT_MYPGRP() {
        return WAIT_MYPGRP;
    }
    private static final int _QUAD_HIGHWORD = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _QUAD_HIGHWORD 1
     * }
     */
    public static int _QUAD_HIGHWORD() {
        return _QUAD_HIGHWORD;
    }
    private static final int _QUAD_LOWWORD = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _QUAD_LOWWORD 0
     * }
     */
    public static int _QUAD_LOWWORD() {
        return _QUAD_LOWWORD;
    }
    private static final int __DARWIN_LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_LITTLE_ENDIAN 1234
     * }
     */
    public static int __DARWIN_LITTLE_ENDIAN() {
        return __DARWIN_LITTLE_ENDIAN;
    }
    private static final int __DARWIN_BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_BIG_ENDIAN 4321
     * }
     */
    public static int __DARWIN_BIG_ENDIAN() {
        return __DARWIN_BIG_ENDIAN;
    }
    private static final int __DARWIN_PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_PDP_ENDIAN 3412
     * }
     */
    public static int __DARWIN_PDP_ENDIAN() {
        return __DARWIN_PDP_ENDIAN;
    }
    private static final int EXIT_FAILURE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EXIT_FAILURE 1
     * }
     */
    public static int EXIT_FAILURE() {
        return EXIT_FAILURE;
    }
    private static final int EXIT_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define EXIT_SUCCESS 0
     * }
     */
    public static int EXIT_SUCCESS() {
        return EXIT_SUCCESS;
    }
    private static final int RAND_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define RAND_MAX 2147483647
     * }
     */
    public static int RAND_MAX() {
        return RAND_MAX;
    }
    private static final int USE_CLANG_STDARG = (int)0L;
    /**
     * {@snippet lang=c :
     * #define USE_CLANG_STDARG 0
     * }
     */
    public static int USE_CLANG_STDARG() {
        return USE_CLANG_STDARG;
    }
    private static final int RENAME_SECLUDE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RENAME_SECLUDE 1
     * }
     */
    public static int RENAME_SECLUDE() {
        return RENAME_SECLUDE;
    }
    private static final int RENAME_SWAP = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RENAME_SWAP 2
     * }
     */
    public static int RENAME_SWAP() {
        return RENAME_SWAP;
    }
    private static final int RENAME_EXCL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RENAME_EXCL 4
     * }
     */
    public static int RENAME_EXCL() {
        return RENAME_EXCL;
    }
    private static final int RENAME_RESERVED1 = (int)8L;
    /**
     * {@snippet lang=c :
     * #define RENAME_RESERVED1 8
     * }
     */
    public static int RENAME_RESERVED1() {
        return RENAME_RESERVED1;
    }
    private static final int RENAME_NOFOLLOW_ANY = (int)16L;
    /**
     * {@snippet lang=c :
     * #define RENAME_NOFOLLOW_ANY 16
     * }
     */
    public static int RENAME_NOFOLLOW_ANY() {
        return RENAME_NOFOLLOW_ANY;
    }
    private static final int SEEK_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEEK_SET 0
     * }
     */
    public static int SEEK_SET() {
        return SEEK_SET;
    }
    private static final int SEEK_CUR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEEK_CUR 1
     * }
     */
    public static int SEEK_CUR() {
        return SEEK_CUR;
    }
    private static final int SEEK_END = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEEK_END 2
     * }
     */
    public static int SEEK_END() {
        return SEEK_END;
    }
    private static final int SEEK_HOLE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SEEK_HOLE 3
     * }
     */
    public static int SEEK_HOLE() {
        return SEEK_HOLE;
    }
    private static final int SEEK_DATA = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SEEK_DATA 4
     * }
     */
    public static int SEEK_DATA() {
        return SEEK_DATA;
    }
    private static final int __SLBF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __SLBF 1
     * }
     */
    public static int __SLBF() {
        return __SLBF;
    }
    private static final int __SNBF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define __SNBF 2
     * }
     */
    public static int __SNBF() {
        return __SNBF;
    }
    private static final int __SRD = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SRD 4
     * }
     */
    public static int __SRD() {
        return __SRD;
    }
    private static final int __SWR = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __SWR 8
     * }
     */
    public static int __SWR() {
        return __SWR;
    }
    private static final int __SRW = (int)16L;
    /**
     * {@snippet lang=c :
     * #define __SRW 16
     * }
     */
    public static int __SRW() {
        return __SRW;
    }
    private static final int __SEOF = (int)32L;
    /**
     * {@snippet lang=c :
     * #define __SEOF 32
     * }
     */
    public static int __SEOF() {
        return __SEOF;
    }
    private static final int __SERR = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __SERR 64
     * }
     */
    public static int __SERR() {
        return __SERR;
    }
    private static final int __SMBF = (int)128L;
    /**
     * {@snippet lang=c :
     * #define __SMBF 128
     * }
     */
    public static int __SMBF() {
        return __SMBF;
    }
    private static final int __SAPP = (int)256L;
    /**
     * {@snippet lang=c :
     * #define __SAPP 256
     * }
     */
    public static int __SAPP() {
        return __SAPP;
    }
    private static final int __SSTR = (int)512L;
    /**
     * {@snippet lang=c :
     * #define __SSTR 512
     * }
     */
    public static int __SSTR() {
        return __SSTR;
    }
    private static final int __SOPT = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __SOPT 1024
     * }
     */
    public static int __SOPT() {
        return __SOPT;
    }
    private static final int __SNPT = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define __SNPT 2048
     * }
     */
    public static int __SNPT() {
        return __SNPT;
    }
    private static final int __SOFF = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define __SOFF 4096
     * }
     */
    public static int __SOFF() {
        return __SOFF;
    }
    private static final int __SMOD = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define __SMOD 8192
     * }
     */
    public static int __SMOD() {
        return __SMOD;
    }
    private static final int __SALC = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define __SALC 16384
     * }
     */
    public static int __SALC() {
        return __SALC;
    }
    private static final int __SIGN = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define __SIGN 32768
     * }
     */
    public static int __SIGN() {
        return __SIGN;
    }
    private static final int _IOFBF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _IOFBF 0
     * }
     */
    public static int _IOFBF() {
        return _IOFBF;
    }
    private static final int _IOLBF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _IOLBF 1
     * }
     */
    public static int _IOLBF() {
        return _IOLBF;
    }
    private static final int _IONBF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _IONBF 2
     * }
     */
    public static int _IONBF() {
        return _IONBF;
    }
    private static final int BUFSIZ = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define BUFSIZ 1024
     * }
     */
    public static int BUFSIZ() {
        return BUFSIZ;
    }
    private static final int FOPEN_MAX = (int)20L;
    /**
     * {@snippet lang=c :
     * #define FOPEN_MAX 20
     * }
     */
    public static int FOPEN_MAX() {
        return FOPEN_MAX;
    }
    private static final int FILENAME_MAX = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define FILENAME_MAX 1024
     * }
     */
    public static int FILENAME_MAX() {
        return FILENAME_MAX;
    }
    private static final int L_tmpnam = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define L_tmpnam 1024
     * }
     */
    public static int L_tmpnam() {
        return L_tmpnam;
    }
    private static final int TMP_MAX = (int)308915776L;
    /**
     * {@snippet lang=c :
     * #define TMP_MAX 308915776
     * }
     */
    public static int TMP_MAX() {
        return TMP_MAX;
    }
    private static final int L_ctermid = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define L_ctermid 1024
     * }
     */
    public static int L_ctermid() {
        return L_ctermid;
    }
    private static final int _USE_FORTIFY_LEVEL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _USE_FORTIFY_LEVEL 2
     * }
     */
    public static int _USE_FORTIFY_LEVEL() {
        return _USE_FORTIFY_LEVEL;
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * mlx_string mlx_string_new()
     * }
     */
    public static class mlx_string_new {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_string_.layout()        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_string_new");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private mlx_string_new(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * mlx_string mlx_string_new()
         * }
         */
        public static mlx_string_new makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new mlx_string_new(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("mlx_string_new", allocator, x0);
                }
                return (MemorySegment) spreader.invokeExact(allocator, x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class mlx_string_new_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_string_.layout(),
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_string_new_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_string mlx_string_new_data(const char *str)
     * }
     */
    public static FunctionDescriptor mlx_string_new_data$descriptor() {
        return mlx_string_new_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_string mlx_string_new_data(const char *str)
     * }
     */
    public static MethodHandle mlx_string_new_data$handle() {
        return mlx_string_new_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_string mlx_string_new_data(const char *str)
     * }
     */
    public static MemorySegment mlx_string_new_data$address() {
        return mlx_string_new_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_string mlx_string_new_data(const char *str)
     * }
     */
    public static MemorySegment mlx_string_new_data(SegmentAllocator allocator, MemorySegment str) {
        var mh$ = mlx_string_new_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_string_new_data", allocator, str);
            }
            return (MemorySegment)mh$.invokeExact(allocator, str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_string_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_string_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_string_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_string_set(mlx_string *str, const mlx_string src)
     * }
     */
    public static FunctionDescriptor mlx_string_set$descriptor() {
        return mlx_string_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_string_set(mlx_string *str, const mlx_string src)
     * }
     */
    public static MethodHandle mlx_string_set$handle() {
        return mlx_string_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_string_set(mlx_string *str, const mlx_string src)
     * }
     */
    public static MemorySegment mlx_string_set$address() {
        return mlx_string_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_string_set(mlx_string *str, const mlx_string src)
     * }
     */
    public static int mlx_string_set(MemorySegment str, MemorySegment src) {
        var mh$ = mlx_string_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_string_set", str, src);
            }
            return (int)mh$.invokeExact(str, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_string_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_string_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_string_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *mlx_string_data(mlx_string str)
     * }
     */
    public static FunctionDescriptor mlx_string_data$descriptor() {
        return mlx_string_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *mlx_string_data(mlx_string str)
     * }
     */
    public static MethodHandle mlx_string_data$handle() {
        return mlx_string_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *mlx_string_data(mlx_string str)
     * }
     */
    public static MemorySegment mlx_string_data$address() {
        return mlx_string_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *mlx_string_data(mlx_string str)
     * }
     */
    public static MemorySegment mlx_string_data(MemorySegment str) {
        var mh$ = mlx_string_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_string_data", str);
            }
            return (MemorySegment)mh$.invokeExact(str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_string_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_string_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_string_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_string_free(mlx_string str)
     * }
     */
    public static FunctionDescriptor mlx_string_free$descriptor() {
        return mlx_string_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_string_free(mlx_string str)
     * }
     */
    public static MethodHandle mlx_string_free$handle() {
        return mlx_string_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_string_free(mlx_string str)
     * }
     */
    public static MemorySegment mlx_string_free$address() {
        return mlx_string_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_string_free(mlx_string str)
     * }
     */
    public static int mlx_string_free(MemorySegment str) {
        var mh$ = mlx_string_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_string_free", str);
            }
            return (int)mh$.invokeExact(str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef signed char int8_t
     * }
     */
    public static final OfByte int8_t = mlx_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int16_t
     * }
     */
    public static final OfShort int16_t = mlx_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int32_t
     * }
     */
    public static final OfInt int32_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int64_t
     * }
     */
    public static final OfLong int64_t = mlx_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint8_t
     * }
     */
    public static final OfByte uint8_t = mlx_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint16_t
     * }
     */
    public static final OfShort uint16_t = mlx_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = mlx_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = mlx_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = mlx_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = mlx_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = mlx_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = mlx_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = mlx_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = mlx_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_fast16_t
     * }
     */
    public static final OfShort int_fast16_t = mlx_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_fast32_t
     * }
     */
    public static final OfInt int_fast32_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = mlx_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = mlx_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_fast16_t
     * }
     */
    public static final OfShort uint_fast16_t = mlx_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_fast32_t
     * }
     */
    public static final OfInt uint_fast32_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = mlx_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = mlx_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = mlx_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = mlx_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = mlx_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long __int64_t
     * }
     */
    public static final OfLong __int64_t = mlx_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = mlx_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_intptr_t
     * }
     */
    public static final OfLong __darwin_intptr_t = mlx_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_natural_t
     * }
     */
    public static final OfInt __darwin_natural_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_ct_rune_t
     * }
     */
    public static final OfInt __darwin_ct_rune_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ptrdiff_t
     * }
     */
    public static final OfLong __darwin_ptrdiff_t = mlx_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_size_t
     * }
     */
    public static final OfLong __darwin_size_t = mlx_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __darwin_va_list
     * }
     */
    public static final AddressLayout __darwin_va_list = mlx_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wchar_t
     * }
     */
    public static final OfInt __darwin_wchar_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wchar_t __darwin_rune_t
     * }
     */
    public static final OfInt __darwin_rune_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wint_t
     * }
     */
    public static final OfInt __darwin_wint_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_clock_t
     * }
     */
    public static final OfLong __darwin_clock_t = mlx_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_socklen_t
     * }
     */
    public static final OfInt __darwin_socklen_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ssize_t
     * }
     */
    public static final OfLong __darwin_ssize_t = mlx_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_time_t
     * }
     */
    public static final OfLong __darwin_time_t = mlx_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_blkcnt_t
     * }
     */
    public static final OfLong __darwin_blkcnt_t = mlx_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_blksize_t
     * }
     */
    public static final OfInt __darwin_blksize_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_dev_t
     * }
     */
    public static final OfInt __darwin_dev_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsblkcnt_t
     * }
     */
    public static final OfInt __darwin_fsblkcnt_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsfilcnt_t
     * }
     */
    public static final OfInt __darwin_fsfilcnt_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_gid_t
     * }
     */
    public static final OfInt __darwin_gid_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_id_t
     * }
     */
    public static final OfInt __darwin_id_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __darwin_ino64_t
     * }
     */
    public static final OfLong __darwin_ino64_t = mlx_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino64_t __darwin_ino_t
     * }
     */
    public static final OfLong __darwin_ino_t = mlx_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_natural_t __darwin_mach_port_name_t
     * }
     */
    public static final OfInt __darwin_mach_port_name_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mach_port_name_t __darwin_mach_port_t
     * }
     */
    public static final OfInt __darwin_mach_port_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __darwin_mode_t
     * }
     */
    public static final OfShort __darwin_mode_t = mlx_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_off_t
     * }
     */
    public static final OfLong __darwin_off_t = mlx_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_pid_t
     * }
     */
    public static final OfInt __darwin_pid_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_sigset_t
     * }
     */
    public static final OfInt __darwin_sigset_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_suseconds_t
     * }
     */
    public static final OfInt __darwin_suseconds_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_uid_t
     * }
     */
    public static final OfInt __darwin_uid_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_useconds_t
     * }
     */
    public static final OfInt __darwin_useconds_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_pthread_key_t
     * }
     */
    public static final OfLong __darwin_pthread_key_t = mlx_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _opaque_pthread_t {
     *     long __sig;
     *     struct __darwin_pthread_handler_rec *__cleanup_stack;
     *     char __opaque[8176];
     * } *__darwin_pthread_t
     * }
     */
    public static final AddressLayout __darwin_pthread_t = mlx_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_intptr_t intptr_t
     * }
     */
    public static final OfLong intptr_t = mlx_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = mlx_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intmax_t
     * }
     */
    public static final OfLong intmax_t = mlx_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintmax_t
     * }
     */
    public static final OfLong uintmax_t = mlx_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_nl_item
     * }
     */
    public static final OfInt __darwin_nl_item = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wctrans_t
     * }
     */
    public static final OfInt __darwin_wctrans_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_wctype_t
     * }
     */
    public static final OfInt __darwin_wctype_t = mlx_h.C_INT;
    private static final int P_ALL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum idtype_t.P_ALL = 0
     * }
     */
    public static int P_ALL() {
        return P_ALL;
    }
    private static final int P_PID = (int)1L;
    /**
     * {@snippet lang=c :
     * enum idtype_t.P_PID = 1
     * }
     */
    public static int P_PID() {
        return P_PID;
    }
    private static final int P_PGID = (int)2L;
    /**
     * {@snippet lang=c :
     * enum idtype_t.P_PGID = 2
     * }
     */
    public static int P_PGID() {
        return P_PGID;
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_pid_t pid_t
     * }
     */
    public static final OfInt pid_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_id_t id_t
     * }
     */
    public static final OfInt id_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int sig_atomic_t
     * }
     */
    public static final OfInt sig_atomic_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_int8_t
     * }
     */
    public static final OfByte u_int8_t = mlx_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_int16_t
     * }
     */
    public static final OfShort u_int16_t = mlx_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int32_t
     * }
     */
    public static final OfInt u_int32_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long u_int64_t
     * }
     */
    public static final OfLong u_int64_t = mlx_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t register_t
     * }
     */
    public static final OfLong register_t = mlx_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_addr_t
     * }
     */
    public static final OfLong user_addr_t = mlx_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_size_t
     * }
     */
    public static final OfLong user_size_t = mlx_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_ssize_t
     * }
     */
    public static final OfLong user_ssize_t = mlx_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_long_t
     * }
     */
    public static final OfLong user_long_t = mlx_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_ulong_t
     * }
     */
    public static final OfLong user_ulong_t = mlx_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_time_t
     * }
     */
    public static final OfLong user_time_t = mlx_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_off_t
     * }
     */
    public static final OfLong user_off_t = mlx_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t syscall_arg_t
     * }
     */
    public static final OfLong syscall_arg_t = mlx_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct __darwin_mcontext64 {
     *     struct __darwin_arm_exception_state64 __es;
     *     struct __darwin_arm_thread_state64 __ss;
     *     struct __darwin_arm_neon_state64 __ns;
     * } *mcontext_t
     * }
     */
    public static final AddressLayout mcontext_t = mlx_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_sigset_t sigset_t
     * }
     */
    public static final OfInt sigset_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t size_t
     * }
     */
    public static final OfLong size_t = mlx_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_uid_t uid_t
     * }
     */
    public static final OfInt uid_t = mlx_h.C_INT;

    private static class signal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static FunctionDescriptor signal$descriptor() {
        return signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MethodHandle signal$handle() {
        return signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MemorySegment signal$address() {
        return signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MemorySegment signal(int x0, MemorySegment x1) {
        var mh$ = signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("signal", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __uint64_t rlim_t
     * }
     */
    public static final OfLong rlim_t = mlx_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef void *rusage_info_t
     * }
     */
    public static final AddressLayout rusage_info_t = mlx_h.C_POINTER;

    private static class getpriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getpriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static FunctionDescriptor getpriority$descriptor() {
        return getpriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static MethodHandle getpriority$handle() {
        return getpriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static MemorySegment getpriority$address() {
        return getpriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static int getpriority(int x0, int x1) {
        var mh$ = getpriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpriority", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getiopolicy_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getiopolicy_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static FunctionDescriptor getiopolicy_np$descriptor() {
        return getiopolicy_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static MethodHandle getiopolicy_np$handle() {
        return getiopolicy_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static MemorySegment getiopolicy_np$address() {
        return getiopolicy_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static int getiopolicy_np(int x0, int x1) {
        var mh$ = getiopolicy_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getiopolicy_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrlimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getrlimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *) asm("_getrlimit")
     * }
     */
    public static FunctionDescriptor getrlimit$descriptor() {
        return getrlimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *) asm("_getrlimit")
     * }
     */
    public static MethodHandle getrlimit$handle() {
        return getrlimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *) asm("_getrlimit")
     * }
     */
    public static MemorySegment getrlimit$address() {
        return getrlimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *) asm("_getrlimit")
     * }
     */
    public static int getrlimit(int x0, MemorySegment x1) {
        var mh$ = getrlimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrlimit", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrusage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getrusage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static FunctionDescriptor getrusage$descriptor() {
        return getrusage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static MethodHandle getrusage$handle() {
        return getrusage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static MemorySegment getrusage$address() {
        return getrusage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static int getrusage(int x0, MemorySegment x1) {
        var mh$ = getrusage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrusage", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setpriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setpriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static FunctionDescriptor setpriority$descriptor() {
        return setpriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static MethodHandle setpriority$handle() {
        return setpriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static MemorySegment setpriority$address() {
        return setpriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static int setpriority(int x0, int x1, int x2) {
        var mh$ = setpriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setpriority", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setiopolicy_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setiopolicy_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static FunctionDescriptor setiopolicy_np$descriptor() {
        return setiopolicy_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static MethodHandle setiopolicy_np$handle() {
        return setiopolicy_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static MemorySegment setiopolicy_np$address() {
        return setiopolicy_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static int setiopolicy_np(int x0, int x1, int x2) {
        var mh$ = setiopolicy_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setiopolicy_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setrlimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setrlimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *) asm("_setrlimit")
     * }
     */
    public static FunctionDescriptor setrlimit$descriptor() {
        return setrlimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *) asm("_setrlimit")
     * }
     */
    public static MethodHandle setrlimit$handle() {
        return setrlimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *) asm("_setrlimit")
     * }
     */
    public static MemorySegment setrlimit$address() {
        return setrlimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *) asm("_setrlimit")
     * }
     */
    public static int setrlimit(int x0, MemorySegment x1) {
        var mh$ = setrlimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setrlimit", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t wait(int *) asm("_wait")
     * }
     */
    public static FunctionDescriptor wait$descriptor() {
        return wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t wait(int *) asm("_wait")
     * }
     */
    public static MethodHandle wait$handle() {
        return wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t wait(int *) asm("_wait")
     * }
     */
    public static MemorySegment wait$address() {
        return wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t wait(int *) asm("_wait")
     * }
     */
    public static int wait(MemorySegment x0) {
        var mh$ = wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waitpid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("waitpid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int) asm("_waitpid")
     * }
     */
    public static FunctionDescriptor waitpid$descriptor() {
        return waitpid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int) asm("_waitpid")
     * }
     */
    public static MethodHandle waitpid$handle() {
        return waitpid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int) asm("_waitpid")
     * }
     */
    public static MemorySegment waitpid$address() {
        return waitpid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int) asm("_waitpid")
     * }
     */
    public static int waitpid(int x0, MemorySegment x1, int x2) {
        var mh$ = waitpid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waitpid", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waitid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("waitid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int) asm("_waitid")
     * }
     */
    public static FunctionDescriptor waitid$descriptor() {
        return waitid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int) asm("_waitid")
     * }
     */
    public static MethodHandle waitid$handle() {
        return waitid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int) asm("_waitid")
     * }
     */
    public static MemorySegment waitid$address() {
        return waitid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int) asm("_waitid")
     * }
     */
    public static int waitid(int x0, int x1, MemorySegment x2, int x3) {
        var mh$ = waitid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waitid", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wait3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static FunctionDescriptor wait3$descriptor() {
        return wait3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static MethodHandle wait3$handle() {
        return wait3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static MemorySegment wait3$address() {
        return wait3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static int wait3(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = wait3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait3", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wait4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static FunctionDescriptor wait4$descriptor() {
        return wait4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static MethodHandle wait4$handle() {
        return wait4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static MemorySegment wait4$address() {
        return wait4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static int wait4(int x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = wait4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait4", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("alloca");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *alloca(size_t __size)
     * }
     */
    public static FunctionDescriptor alloca$descriptor() {
        return alloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *alloca(size_t __size)
     * }
     */
    public static MethodHandle alloca$handle() {
        return alloca.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *alloca(size_t __size)
     * }
     */
    public static MemorySegment alloca$address() {
        return alloca.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *alloca(size_t __size)
     * }
     */
    public static MemorySegment alloca(long __size) {
        var mh$ = alloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alloca", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_ct_rune_t ct_rune_t
     * }
     */
    public static final OfInt ct_rune_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_rune_t rune_t
     * }
     */
    public static final OfInt rune_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wchar_t wchar_t
     * }
     */
    public static final OfInt wchar_t = mlx_h.C_INT;

    private static class __mb_cur_max$constants {
        public static final OfInt LAYOUT = mlx_h.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("__mb_cur_max").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static OfInt __mb_cur_max$layout() {
        return __mb_cur_max$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static MemorySegment __mb_cur_max$segment() {
        return __mb_cur_max$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static int __mb_cur_max() {
        return __mb_cur_max$constants.SEGMENT.get(__mb_cur_max$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static void __mb_cur_max(int varValue) {
        __mb_cur_max$constants.SEGMENT.set(__mb_cur_max$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long long malloc_type_id_t
     * }
     */
    public static final OfLong malloc_type_id_t = mlx_h.C_LONG_LONG;

    private static class malloc_type_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_malloc$descriptor() {
        return malloc_type_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_malloc$handle() {
        return malloc_type_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_malloc$address() {
        return malloc_type_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_malloc(long size, long type_id) {
        var mh$ = malloc_type_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_malloc", size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(size, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG,
            mlx_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_calloc$descriptor() {
        return malloc_type_calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_calloc$handle() {
        return malloc_type_calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_calloc$address() {
        return malloc_type_calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_calloc(long count, long size, long type_id) {
        var mh$ = malloc_type_calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_calloc", count, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(count, size, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_POINTER,
            mlx_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_free$descriptor() {
        return malloc_type_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_free$handle() {
        return malloc_type_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_free$address() {
        return malloc_type_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static void malloc_type_free(MemorySegment ptr, long type_id) {
        var mh$ = malloc_type_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_free", ptr, type_id);
            }
            mh$.invokeExact(ptr, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_realloc$descriptor() {
        return malloc_type_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_realloc$handle() {
        return malloc_type_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_realloc$address() {
        return malloc_type_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_realloc(MemorySegment ptr, long size, long type_id) {
        var mh$ = malloc_type_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_realloc", ptr, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(ptr, size, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_valloc$descriptor() {
        return malloc_type_valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_valloc$handle() {
        return malloc_type_valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_valloc$address() {
        return malloc_type_valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_valloc(long size, long type_id) {
        var mh$ = malloc_type_valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_valloc", size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(size, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG,
            mlx_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_aligned_alloc$descriptor() {
        return malloc_type_aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_aligned_alloc$handle() {
        return malloc_type_aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_aligned_alloc$address() {
        return malloc_type_aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_aligned_alloc(long alignment, long size, long type_id) {
        var mh$ = malloc_type_aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_aligned_alloc", alignment, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(alignment, size, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG,
            mlx_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_posix_memalign$descriptor() {
        return malloc_type_posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_posix_memalign$handle() {
        return malloc_type_posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_posix_memalign$address() {
        return malloc_type_posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static int malloc_type_posix_memalign(MemorySegment memptr, long alignment, long size, long type_id) {
        var mh$ = malloc_type_posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_posix_memalign", memptr, alignment, size, type_id);
            }
            return (int)mh$.invokeExact(memptr, alignment, size, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_zone_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_malloc$descriptor() {
        return malloc_type_zone_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_malloc$handle() {
        return malloc_type_zone_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_malloc$address() {
        return malloc_type_zone_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_malloc(MemorySegment zone, long size, long type_id) {
        var mh$ = malloc_type_zone_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_malloc", zone, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, size, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG,
            mlx_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_zone_calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_calloc$descriptor() {
        return malloc_type_zone_calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_calloc$handle() {
        return malloc_type_zone_calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_calloc$address() {
        return malloc_type_zone_calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_calloc(MemorySegment zone, long count, long size, long type_id) {
        var mh$ = malloc_type_zone_calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_calloc", zone, count, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, count, size, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_zone_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_free$descriptor() {
        return malloc_type_zone_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_free$handle() {
        return malloc_type_zone_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_free$address() {
        return malloc_type_zone_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static void malloc_type_zone_free(MemorySegment zone, MemorySegment ptr, long type_id) {
        var mh$ = malloc_type_zone_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_free", zone, ptr, type_id);
            }
            mh$.invokeExact(zone, ptr, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_zone_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_realloc$descriptor() {
        return malloc_type_zone_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_realloc$handle() {
        return malloc_type_zone_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_realloc$address() {
        return malloc_type_zone_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_realloc(MemorySegment zone, MemorySegment ptr, long size, long type_id) {
        var mh$ = malloc_type_zone_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_realloc", zone, ptr, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, ptr, size, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_zone_valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_valloc$descriptor() {
        return malloc_type_zone_valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_valloc$handle() {
        return malloc_type_zone_valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_valloc$address() {
        return malloc_type_zone_valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_valloc(MemorySegment zone, long size, long type_id) {
        var mh$ = malloc_type_zone_valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_valloc", zone, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, size, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG,
            mlx_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_zone_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_memalign$descriptor() {
        return malloc_type_zone_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_memalign$handle() {
        return malloc_type_zone_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_memalign$address() {
        return malloc_type_zone_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_memalign(MemorySegment zone, long alignment, long size, long type_id) {
        var mh$ = malloc_type_zone_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_memalign", zone, alignment, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, alignment, size, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc$address() {
        return malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc(long __size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MemorySegment calloc$address() {
        return calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MemorySegment calloc(long __count, long __size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", __count, __size);
            }
            return (MemorySegment)mh$.invokeExact(__count, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static MemorySegment free$address() {
        return free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static void free(MemorySegment x0) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc$address() {
        return realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc(MemorySegment __ptr, long __size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reallocf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("reallocf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor reallocf$descriptor() {
        return reallocf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle reallocf$handle() {
        return reallocf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment reallocf$address() {
        return reallocf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment reallocf(MemorySegment __ptr, long __size) {
        var mh$ = reallocf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reallocf", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *valloc(size_t __size)
     * }
     */
    public static FunctionDescriptor valloc$descriptor() {
        return valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *valloc(size_t __size)
     * }
     */
    public static MethodHandle valloc$handle() {
        return valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc$address() {
        return valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc(long __size) {
        var mh$ = valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("valloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor aligned_alloc$descriptor() {
        return aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle aligned_alloc$handle() {
        return aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc$address() {
        return aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc(long __alignment, long __size) {
        var mh$ = aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aligned_alloc", __alignment, __size);
            }
            return (MemorySegment)mh$.invokeExact(__alignment, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor posix_memalign$descriptor() {
        return posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle posix_memalign$handle() {
        return posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment posix_memalign$address() {
        return posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static int posix_memalign(MemorySegment __memptr, long __alignment, long __size) {
        var mh$ = posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_memalign", __memptr, __alignment, __size);
            }
            return (int)mh$.invokeExact(__memptr, __alignment, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("abort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void abort(void)
     * }
     */
    public static FunctionDescriptor abort$descriptor() {
        return abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void abort(void)
     * }
     */
    public static MethodHandle abort$handle() {
        return abort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void abort(void)
     * }
     */
    public static MemorySegment abort$address() {
        return abort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void abort(void)
     * }
     */
    public static void abort() {
        var mh$ = abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abort");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static MemorySegment abs$address() {
        return abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static int abs(int x0) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static MemorySegment atexit$address() {
        return atexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static int atexit(MemorySegment x0) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class at_quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("at_quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void))
     * }
     */
    public static FunctionDescriptor at_quick_exit$descriptor() {
        return at_quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void))
     * }
     */
    public static MethodHandle at_quick_exit$handle() {
        return at_quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void))
     * }
     */
    public static MemorySegment at_quick_exit$address() {
        return at_quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void))
     * }
     */
    public static int at_quick_exit(MemorySegment x0) {
        var mh$ = at_quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("at_quick_exit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_DOUBLE,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static MemorySegment atof$address() {
        return atof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static double atof(MemorySegment x0) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static MemorySegment atoi$address() {
        return atoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static int atoi(MemorySegment x0) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static MemorySegment atol$address() {
        return atol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static long atol(MemorySegment x0) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG_LONG,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static MemorySegment atoll$address() {
        return atoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static long atoll(MemorySegment x0) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch$address() {
        return bsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch(MemorySegment __key, MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", __key, __base, __nel, __width, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            div_t.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MemorySegment div$address() {
        return div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int x0, int x1) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static MemorySegment exit$address() {
        return exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static void exit(int x0) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MemorySegment getenv$address() {
        return getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MemorySegment getenv(MemorySegment x0) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("labs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static MemorySegment labs$address() {
        return labs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static long labs(long x0) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ldiv_t.layout(),
            mlx_h.C_LONG,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MemorySegment ldiv$address() {
        return ldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, long x0, long x1) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG_LONG,
            mlx_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static MemorySegment llabs$address() {
        return llabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static long llabs(long x0) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lldiv_t.layout(),
            mlx_h.C_LONG_LONG,
            mlx_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MemorySegment lldiv$address() {
        return lldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long x0, long x1) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mblen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static MemorySegment mblen$address() {
        return mblen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static int mblen(MemorySegment __s, long __n) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", __s, __n);
            }
            return (int)mh$.invokeExact(__s, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mbstowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t __n)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t __n)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t __n)
     * }
     */
    public static MemorySegment mbstowcs$address() {
        return mbstowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t __n)
     * }
     */
    public static long mbstowcs(MemorySegment x0, MemorySegment x1, long __n) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", x0, x1, __n);
            }
            return (long)mh$.invokeExact(x0, x1, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mbtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t __n)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t __n)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t __n)
     * }
     */
    public static MemorySegment mbtowc$address() {
        return mbtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t __n)
     * }
     */
    public static int mbtowc(MemorySegment x0, MemorySegment x1, long __n) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", x0, x1, __n);
            }
            return (int)mh$.invokeExact(x0, x1, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("qsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment qsort$address() {
        return qsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static void qsort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void quick_exit(int)
     * }
     */
    public static FunctionDescriptor quick_exit$descriptor() {
        return quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void quick_exit(int)
     * }
     */
    public static MethodHandle quick_exit$handle() {
        return quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void quick_exit(int)
     * }
     */
    public static MemorySegment quick_exit$address() {
        return quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void quick_exit(int)
     * }
     */
    public static void quick_exit(int x0) {
        var mh$ = quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("quick_exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rand(void)
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rand(void)
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rand(void)
     * }
     */
    public static MemorySegment rand$address() {
        return rand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rand(void)
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("srand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static MemorySegment srand$address() {
        return srand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static void srand(int x0) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_DOUBLE,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double strtod(const char *, char **) asm("_strtod")
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double strtod(const char *, char **) asm("_strtod")
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double strtod(const char *, char **) asm("_strtod")
     * }
     */
    public static MemorySegment strtod$address() {
        return strtod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double strtod(const char *, char **) asm("_strtod")
     * }
     */
    public static double strtod(MemorySegment x0, MemorySegment x1) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_FLOAT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float strtof(const char *, char **) asm("_strtof")
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float strtof(const char *, char **) asm("_strtof")
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float strtof(const char *, char **) asm("_strtof")
     * }
     */
    public static MemorySegment strtof$address() {
        return strtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float strtof(const char *, char **) asm("_strtof")
     * }
     */
    public static float strtof(MemorySegment x0, MemorySegment x1) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtol$address() {
        return strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtol(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoll$address() {
        return strtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoll(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoul$address() {
        return strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoul(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoull$address() {
        return strtoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoull(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int system(const char *) asm("_system")
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int system(const char *) asm("_system")
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int system(const char *) asm("_system")
     * }
     */
    public static MemorySegment system$address() {
        return system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int system(const char *) asm("_system")
     * }
     */
    public static int system(MemorySegment x0) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t __n)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t __n)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t __n)
     * }
     */
    public static MemorySegment wcstombs$address() {
        return wcstombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t __n)
     * }
     */
    public static long wcstombs(MemorySegment x0, MemorySegment x1, long __n) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", x0, x1, __n);
            }
            return (long)mh$.invokeExact(x0, x1, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wctomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static MemorySegment wctomb$address() {
        return wctomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static int wctomb(MemorySegment x0, int x1) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static void _Exit(int x0) {
        var mh$ = _Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class a64l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("a64l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static FunctionDescriptor a64l$descriptor() {
        return a64l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static MethodHandle a64l$handle() {
        return a64l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static MemorySegment a64l$address() {
        return a64l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static long a64l(MemorySegment x0) {
        var mh$ = a64l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("a64l", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_DOUBLE    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("drand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double drand48(void)
     * }
     */
    public static FunctionDescriptor drand48$descriptor() {
        return drand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double drand48(void)
     * }
     */
    public static MethodHandle drand48$handle() {
        return drand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double drand48(void)
     * }
     */
    public static MemorySegment drand48$address() {
        return drand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double drand48(void)
     * }
     */
    public static double drand48() {
        var mh$ = drand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48");
            }
            return (double)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_DOUBLE,
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment ecvt$address() {
        return ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment ecvt(double x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_DOUBLE,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("erand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double erand48(unsigned short[3])
     * }
     */
    public static FunctionDescriptor erand48$descriptor() {
        return erand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double erand48(unsigned short[3])
     * }
     */
    public static MethodHandle erand48$handle() {
        return erand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double erand48(unsigned short[3])
     * }
     */
    public static MemorySegment erand48$address() {
        return erand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double erand48(unsigned short[3])
     * }
     */
    public static double erand48(MemorySegment x0) {
        var mh$ = erand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_DOUBLE,
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment fcvt$address() {
        return fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment fcvt(double x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_DOUBLE,
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MemorySegment gcvt$address() {
        return gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MemorySegment gcvt(double x0, int x1, MemorySegment x2) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsubopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getsubopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static FunctionDescriptor getsubopt$descriptor() {
        return getsubopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static MethodHandle getsubopt$handle() {
        return getsubopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static MemorySegment getsubopt$address() {
        return getsubopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static int getsubopt(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getsubopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsubopt", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class grantpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("grantpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static FunctionDescriptor grantpt$descriptor() {
        return grantpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static MethodHandle grantpt$handle() {
        return grantpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static MemorySegment grantpt$address() {
        return grantpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static int grantpt(int x0) {
        var mh$ = grantpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("grantpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("initstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t __size)
     * }
     */
    public static FunctionDescriptor initstate$descriptor() {
        return initstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t __size)
     * }
     */
    public static MethodHandle initstate$handle() {
        return initstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t __size)
     * }
     */
    public static MemorySegment initstate$address() {
        return initstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t __size)
     * }
     */
    public static MemorySegment initstate(int x0, MemorySegment x1, long __size) {
        var mh$ = initstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate", x0, x1, __size);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("jrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long jrand48(unsigned short[3])
     * }
     */
    public static FunctionDescriptor jrand48$descriptor() {
        return jrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long jrand48(unsigned short[3])
     * }
     */
    public static MethodHandle jrand48$handle() {
        return jrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long jrand48(unsigned short[3])
     * }
     */
    public static MemorySegment jrand48$address() {
        return jrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long jrand48(unsigned short[3])
     * }
     */
    public static long jrand48(MemorySegment x0) {
        var mh$ = jrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class l64a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("l64a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static FunctionDescriptor l64a$descriptor() {
        return l64a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MethodHandle l64a$handle() {
        return l64a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MemorySegment l64a$address() {
        return l64a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MemorySegment l64a(long x0) {
        var mh$ = l64a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("l64a", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lcong48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void lcong48(unsigned short[7])
     * }
     */
    public static FunctionDescriptor lcong48$descriptor() {
        return lcong48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void lcong48(unsigned short[7])
     * }
     */
    public static MethodHandle lcong48$handle() {
        return lcong48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void lcong48(unsigned short[7])
     * }
     */
    public static MemorySegment lcong48$address() {
        return lcong48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void lcong48(unsigned short[7])
     * }
     */
    public static void lcong48(MemorySegment x0) {
        var mh$ = lcong48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lrand48(void)
     * }
     */
    public static FunctionDescriptor lrand48$descriptor() {
        return lrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lrand48(void)
     * }
     */
    public static MethodHandle lrand48$handle() {
        return lrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lrand48(void)
     * }
     */
    public static MemorySegment lrand48$address() {
        return lrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lrand48(void)
     * }
     */
    public static long lrand48() {
        var mh$ = lrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mktemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static FunctionDescriptor mktemp$descriptor() {
        return mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MethodHandle mktemp$handle() {
        return mktemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MemorySegment mktemp$address() {
        return mktemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MemorySegment mktemp(MemorySegment x0) {
        var mh$ = mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktemp", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mkstemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static FunctionDescriptor mkstemp$descriptor() {
        return mkstemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static MethodHandle mkstemp$handle() {
        return mkstemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static MemorySegment mkstemp$address() {
        return mkstemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static int mkstemp(MemorySegment x0) {
        var mh$ = mkstemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long mrand48(void)
     * }
     */
    public static FunctionDescriptor mrand48$descriptor() {
        return mrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long mrand48(void)
     * }
     */
    public static MethodHandle mrand48$handle() {
        return mrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long mrand48(void)
     * }
     */
    public static MemorySegment mrand48$address() {
        return mrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long mrand48(void)
     * }
     */
    public static long mrand48() {
        var mh$ = mrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long nrand48(unsigned short[3])
     * }
     */
    public static FunctionDescriptor nrand48$descriptor() {
        return nrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long nrand48(unsigned short[3])
     * }
     */
    public static MethodHandle nrand48$handle() {
        return nrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long nrand48(unsigned short[3])
     * }
     */
    public static MemorySegment nrand48$address() {
        return nrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long nrand48(unsigned short[3])
     * }
     */
    public static long nrand48(MemorySegment x0) {
        var mh$ = nrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_openpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("posix_openpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static FunctionDescriptor posix_openpt$descriptor() {
        return posix_openpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static MethodHandle posix_openpt$handle() {
        return posix_openpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static MemorySegment posix_openpt$address() {
        return posix_openpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static int posix_openpt(int x0) {
        var mh$ = posix_openpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_openpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ptsname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ptsname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static FunctionDescriptor ptsname$descriptor() {
        return ptsname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MethodHandle ptsname$handle() {
        return ptsname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MemorySegment ptsname$address() {
        return ptsname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MemorySegment ptsname(int x0) {
        var mh$ = ptsname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ptsname", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ptsname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ptsname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static FunctionDescriptor ptsname_r$descriptor() {
        return ptsname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static MethodHandle ptsname_r$handle() {
        return ptsname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static MemorySegment ptsname_r$address() {
        return ptsname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static int ptsname_r(int fildes, MemorySegment buffer, long buflen) {
        var mh$ = ptsname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ptsname_r", fildes, buffer, buflen);
            }
            return (int)mh$.invokeExact(fildes, buffer, buflen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putenv(char *) asm("_putenv")
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putenv(char *) asm("_putenv")
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putenv(char *) asm("_putenv")
     * }
     */
    public static MemorySegment putenv$address() {
        return putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putenv(char *) asm("_putenv")
     * }
     */
    public static int putenv(MemorySegment x0) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long random(void)
     * }
     */
    public static FunctionDescriptor random$descriptor() {
        return random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long random(void)
     * }
     */
    public static MethodHandle random$handle() {
        return random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long random(void)
     * }
     */
    public static MemorySegment random$address() {
        return random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long random(void)
     * }
     */
    public static long random() {
        var mh$ = random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rand_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static FunctionDescriptor rand_r$descriptor() {
        return rand_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static MethodHandle rand_r$handle() {
        return rand_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static MemorySegment rand_r$address() {
        return rand_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static int rand_r(MemorySegment x0) {
        var mh$ = rand_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand_r", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("realpath$DARWIN_EXTSN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict) asm("_realpath$DARWIN_EXTSN")
     * }
     */
    public static FunctionDescriptor realpath$descriptor() {
        return realpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict) asm("_realpath$DARWIN_EXTSN")
     * }
     */
    public static MethodHandle realpath$handle() {
        return realpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict) asm("_realpath$DARWIN_EXTSN")
     * }
     */
    public static MemorySegment realpath$address() {
        return realpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict) asm("_realpath$DARWIN_EXTSN")
     * }
     */
    public static MemorySegment realpath(MemorySegment x0, MemorySegment x1) {
        var mh$ = realpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realpath", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("seed48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short[3])
     * }
     */
    public static FunctionDescriptor seed48$descriptor() {
        return seed48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short[3])
     * }
     */
    public static MethodHandle seed48$handle() {
        return seed48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short[3])
     * }
     */
    public static MemorySegment seed48$address() {
        return seed48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short[3])
     * }
     */
    public static MemorySegment seed48(MemorySegment x0) {
        var mh$ = seed48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite) asm("_setenv")
     * }
     */
    public static FunctionDescriptor setenv$descriptor() {
        return setenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite) asm("_setenv")
     * }
     */
    public static MethodHandle setenv$handle() {
        return setenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite) asm("_setenv")
     * }
     */
    public static MemorySegment setenv$address() {
        return setenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite) asm("_setenv")
     * }
     */
    public static int setenv(MemorySegment __name, MemorySegment __value, int __overwrite) {
        var mh$ = setenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setenv", __name, __value, __overwrite);
            }
            return (int)mh$.invokeExact(__name, __value, __overwrite);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setkey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setkey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setkey(const char *) asm("_setkey")
     * }
     */
    public static FunctionDescriptor setkey$descriptor() {
        return setkey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setkey(const char *) asm("_setkey")
     * }
     */
    public static MethodHandle setkey$handle() {
        return setkey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setkey(const char *) asm("_setkey")
     * }
     */
    public static MemorySegment setkey$address() {
        return setkey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setkey(const char *) asm("_setkey")
     * }
     */
    public static void setkey(MemorySegment x0) {
        var mh$ = setkey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setkey", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static FunctionDescriptor setstate$descriptor() {
        return setstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MethodHandle setstate$handle() {
        return setstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MemorySegment setstate$address() {
        return setstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MemorySegment setstate(MemorySegment x0) {
        var mh$ = setstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("srand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static FunctionDescriptor srand48$descriptor() {
        return srand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static MethodHandle srand48$handle() {
        return srand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static MemorySegment srand48$address() {
        return srand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static void srand48(long x0) {
        var mh$ = srand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("srandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static FunctionDescriptor srandom$descriptor() {
        return srandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static MethodHandle srandom$handle() {
        return srandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static MemorySegment srandom$address() {
        return srandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static void srandom(int x0) {
        var mh$ = srandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlockpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("unlockpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static FunctionDescriptor unlockpt$descriptor() {
        return unlockpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static MethodHandle unlockpt$handle() {
        return unlockpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static MemorySegment unlockpt$address() {
        return unlockpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static int unlockpt(int x0) {
        var mh$ = unlockpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlockpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unsetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("unsetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unsetenv(const char *) asm("_unsetenv")
     * }
     */
    public static FunctionDescriptor unsetenv$descriptor() {
        return unsetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unsetenv(const char *) asm("_unsetenv")
     * }
     */
    public static MethodHandle unsetenv$handle() {
        return unsetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unsetenv(const char *) asm("_unsetenv")
     * }
     */
    public static MemorySegment unsetenv$address() {
        return unsetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unsetenv(const char *) asm("_unsetenv")
     * }
     */
    public static int unsetenv(MemorySegment x0) {
        var mh$ = unsetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unsetenv", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_dev_t dev_t
     * }
     */
    public static final OfInt dev_t = mlx_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mode_t mode_t
     * }
     */
    public static final OfShort mode_t = mlx_h.C_SHORT;

    private static class arc4random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arc4random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t arc4random(void)
     * }
     */
    public static FunctionDescriptor arc4random$descriptor() {
        return arc4random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t arc4random(void)
     * }
     */
    public static MethodHandle arc4random$handle() {
        return arc4random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t arc4random(void)
     * }
     */
    public static MemorySegment arc4random$address() {
        return arc4random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t arc4random(void)
     * }
     */
    public static int arc4random() {
        var mh$ = arc4random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_addrandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_POINTER,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arc4random_addrandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int __datlen)
     * }
     */
    public static FunctionDescriptor arc4random_addrandom$descriptor() {
        return arc4random_addrandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int __datlen)
     * }
     */
    public static MethodHandle arc4random_addrandom$handle() {
        return arc4random_addrandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int __datlen)
     * }
     */
    public static MemorySegment arc4random_addrandom$address() {
        return arc4random_addrandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int __datlen)
     * }
     */
    public static void arc4random_addrandom(MemorySegment x0, int __datlen) {
        var mh$ = arc4random_addrandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_addrandom", x0, __datlen);
            }
            mh$.invokeExact(x0, __datlen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arc4random_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static FunctionDescriptor arc4random_buf$descriptor() {
        return arc4random_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static MethodHandle arc4random_buf$handle() {
        return arc4random_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static MemorySegment arc4random_buf$address() {
        return arc4random_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static void arc4random_buf(MemorySegment __buf, long __nbytes) {
        var mh$ = arc4random_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_buf", __buf, __nbytes);
            }
            mh$.invokeExact(__buf, __nbytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_stir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arc4random_stir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_stir(void)
     * }
     */
    public static FunctionDescriptor arc4random_stir$descriptor() {
        return arc4random_stir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_stir(void)
     * }
     */
    public static MethodHandle arc4random_stir$handle() {
        return arc4random_stir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_stir(void)
     * }
     */
    public static MemorySegment arc4random_stir$address() {
        return arc4random_stir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_stir(void)
     * }
     */
    public static void arc4random_stir() {
        var mh$ = arc4random_stir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_stir");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_uniform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arc4random_uniform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static FunctionDescriptor arc4random_uniform$descriptor() {
        return arc4random_uniform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static MethodHandle arc4random_uniform$handle() {
        return arc4random_uniform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static MemorySegment arc4random_uniform$address() {
        return arc4random_uniform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static int arc4random_uniform(int __upper_bound) {
        var mh$ = arc4random_uniform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_uniform", __upper_bound);
            }
            return (int)mh$.invokeExact(__upper_bound);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atexit_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static FunctionDescriptor atexit_b$descriptor() {
        return atexit_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static MethodHandle atexit_b$handle() {
        return atexit_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static MemorySegment atexit_b$address() {
        return atexit_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static int atexit_b(MemorySegment x0) {
        var mh$ = atexit_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit_b", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bsearch_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor bsearch_b$descriptor() {
        return bsearch_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle bsearch_b$handle() {
        return bsearch_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch_b$address() {
        return bsearch_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch_b(MemorySegment __key, MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = bsearch_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch_b", __key, __base, __nel, __width, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetcap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetcap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static FunctionDescriptor cgetcap$descriptor() {
        return cgetcap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MethodHandle cgetcap$handle() {
        return cgetcap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MemorySegment cgetcap$address() {
        return cgetcap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MemorySegment cgetcap(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = cgetcap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetcap", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetclose(void)
     * }
     */
    public static FunctionDescriptor cgetclose$descriptor() {
        return cgetclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetclose(void)
     * }
     */
    public static MethodHandle cgetclose$handle() {
        return cgetclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetclose(void)
     * }
     */
    public static MemorySegment cgetclose$address() {
        return cgetclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetclose(void)
     * }
     */
    public static int cgetclose() {
        var mh$ = cgetclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetclose");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static FunctionDescriptor cgetent$descriptor() {
        return cgetent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static MethodHandle cgetent$handle() {
        return cgetent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static MemorySegment cgetent$address() {
        return cgetent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static int cgetent(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetent", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetfirst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetfirst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static FunctionDescriptor cgetfirst$descriptor() {
        return cgetfirst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static MethodHandle cgetfirst$handle() {
        return cgetfirst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static MemorySegment cgetfirst$address() {
        return cgetfirst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static int cgetfirst(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetfirst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetfirst", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static FunctionDescriptor cgetmatch$descriptor() {
        return cgetmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static MethodHandle cgetmatch$handle() {
        return cgetmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static MemorySegment cgetmatch$address() {
        return cgetmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static int cgetmatch(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetmatch", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetnext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetnext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static FunctionDescriptor cgetnext$descriptor() {
        return cgetnext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static MethodHandle cgetnext$handle() {
        return cgetnext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static MemorySegment cgetnext$address() {
        return cgetnext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static int cgetnext(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetnext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetnext", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetnum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetnum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static FunctionDescriptor cgetnum$descriptor() {
        return cgetnum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static MethodHandle cgetnum$handle() {
        return cgetnum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static MemorySegment cgetnum$address() {
        return cgetnum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static int cgetnum(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetnum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetnum", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static FunctionDescriptor cgetset$descriptor() {
        return cgetset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static MethodHandle cgetset$handle() {
        return cgetset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static MemorySegment cgetset$address() {
        return cgetset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static int cgetset(MemorySegment x0) {
        var mh$ = cgetset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetset", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static FunctionDescriptor cgetstr$descriptor() {
        return cgetstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static MethodHandle cgetstr$handle() {
        return cgetstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static MemorySegment cgetstr$address() {
        return cgetstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static int cgetstr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetstr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetustr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetustr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static FunctionDescriptor cgetustr$descriptor() {
        return cgetustr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static MethodHandle cgetustr$handle() {
        return cgetustr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static MemorySegment cgetustr$address() {
        return cgetustr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static int cgetustr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetustr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetustr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class daemon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("daemon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int daemon(int, int) asm("_daemon")
     * }
     */
    public static FunctionDescriptor daemon$descriptor() {
        return daemon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int daemon(int, int) asm("_daemon")
     * }
     */
    public static MethodHandle daemon$handle() {
        return daemon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int daemon(int, int) asm("_daemon")
     * }
     */
    public static MemorySegment daemon$address() {
        return daemon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int daemon(int, int) asm("_daemon")
     * }
     */
    public static int daemon(int x0, int x1) {
        var mh$ = daemon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("daemon", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class devname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_INT,
            mlx_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("devname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static FunctionDescriptor devname$descriptor() {
        return devname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MethodHandle devname$handle() {
        return devname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MemorySegment devname$address() {
        return devname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MemorySegment devname(int x0, short x1) {
        var mh$ = devname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("devname", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class devname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_INT,
            mlx_h.C_SHORT,
            mlx_h.C_POINTER,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("devname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static FunctionDescriptor devname_r$descriptor() {
        return devname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MethodHandle devname_r$handle() {
        return devname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MemorySegment devname_r$address() {
        return devname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MemorySegment devname_r(int x0, short x1, MemorySegment buf, int len) {
        var mh$ = devname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("devname_r", x0, x1, buf, len);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, buf, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getbsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getbsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static FunctionDescriptor getbsize$descriptor() {
        return getbsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MethodHandle getbsize$handle() {
        return getbsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MemorySegment getbsize$address() {
        return getbsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MemorySegment getbsize(MemorySegment x0, MemorySegment x1) {
        var mh$ = getbsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getbsize", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getloadavg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getloadavg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getloadavg(double[], int __nelem)
     * }
     */
    public static FunctionDescriptor getloadavg$descriptor() {
        return getloadavg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getloadavg(double[], int __nelem)
     * }
     */
    public static MethodHandle getloadavg$handle() {
        return getloadavg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getloadavg(double[], int __nelem)
     * }
     */
    public static MemorySegment getloadavg$address() {
        return getloadavg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getloadavg(double[], int __nelem)
     * }
     */
    public static int getloadavg(MemorySegment x0, int __nelem) {
        var mh$ = getloadavg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getloadavg", x0, __nelem);
            }
            return (int)mh$.invokeExact(x0, __nelem);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getprogname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getprogname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *getprogname(void)
     * }
     */
    public static FunctionDescriptor getprogname$descriptor() {
        return getprogname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *getprogname(void)
     * }
     */
    public static MethodHandle getprogname$handle() {
        return getprogname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *getprogname(void)
     * }
     */
    public static MemorySegment getprogname$address() {
        return getprogname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *getprogname(void)
     * }
     */
    public static MemorySegment getprogname() {
        var mh$ = getprogname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getprogname");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setprogname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setprogname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static FunctionDescriptor setprogname$descriptor() {
        return setprogname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static MethodHandle setprogname$handle() {
        return setprogname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static MemorySegment setprogname$address() {
        return setprogname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static void setprogname(MemorySegment x0) {
        var mh$ = setprogname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setprogname", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heapsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("heapsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor heapsort$descriptor() {
        return heapsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle heapsort$handle() {
        return heapsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment heapsort$address() {
        return heapsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static int heapsort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = heapsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heapsort", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heapsort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("heapsort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor heapsort_b$descriptor() {
        return heapsort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle heapsort_b$handle() {
        return heapsort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment heapsort_b$address() {
        return heapsort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static int heapsort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = heapsort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heapsort_b", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mergesort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mergesort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor mergesort$descriptor() {
        return mergesort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle mergesort$handle() {
        return mergesort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment mergesort$address() {
        return mergesort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static int mergesort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = mergesort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mergesort", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mergesort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mergesort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor mergesort_b$descriptor() {
        return mergesort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle mergesort_b$handle() {
        return mergesort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment mergesort_b$address() {
        return mergesort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static int mergesort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = mergesort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mergesort_b", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("psort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort$descriptor() {
        return psort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle psort$handle() {
        return psort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment psort$address() {
        return psort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static void psort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = psort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("psort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort_b$descriptor() {
        return psort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle psort_b$handle() {
        return psort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment psort_b$address() {
        return psort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static void psort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = psort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort_b", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("psort_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort_r$descriptor() {
        return psort_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MethodHandle psort_r$handle() {
        return psort_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MemorySegment psort_r$address() {
        return psort_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static void psort_r(MemorySegment __base, long __nel, long __width, MemorySegment x3, MemorySegment __compar) {
        var mh$ = psort_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort_r", __base, __nel, __width, x3, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, x3, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("qsort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort_b$descriptor() {
        return qsort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle qsort_b$handle() {
        return qsort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment qsort_b$address() {
        return qsort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static void qsort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = qsort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_b", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("qsort_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort_r$descriptor() {
        return qsort_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MethodHandle qsort_r$handle() {
        return qsort_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MemorySegment qsort_r$address() {
        return qsort_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static void qsort_r(MemorySegment __base, long __nel, long __width, MemorySegment x3, MemorySegment __compar) {
        var mh$ = qsort_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_r", __base, __nel, __width, x3, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, x3, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class radixsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("radixsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static FunctionDescriptor radixsort$descriptor() {
        return radixsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MethodHandle radixsort$handle() {
        return radixsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MemorySegment radixsort$address() {
        return radixsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static int radixsort(MemorySegment __base, int __nel, MemorySegment __table, int __endbyte) {
        var mh$ = radixsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("radixsort", __base, __nel, __table, __endbyte);
            }
            return (int)mh$.invokeExact(__base, __nel, __table, __endbyte);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rpmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rpmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static FunctionDescriptor rpmatch$descriptor() {
        return rpmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static MethodHandle rpmatch$handle() {
        return rpmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static MemorySegment rpmatch$address() {
        return rpmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static int rpmatch(MemorySegment x0) {
        var mh$ = rpmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rpmatch", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sradixsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sradixsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static FunctionDescriptor sradixsort$descriptor() {
        return sradixsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MethodHandle sradixsort$handle() {
        return sradixsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MemorySegment sradixsort$address() {
        return sradixsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static int sradixsort(MemorySegment __base, int __nel, MemorySegment __table, int __endbyte) {
        var mh$ = sradixsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sradixsort", __base, __nel, __table, __endbyte);
            }
            return (int)mh$.invokeExact(__base, __nel, __table, __endbyte);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sranddev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sranddev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sranddev(void)
     * }
     */
    public static FunctionDescriptor sranddev$descriptor() {
        return sranddev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sranddev(void)
     * }
     */
    public static MethodHandle sranddev$handle() {
        return sranddev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sranddev(void)
     * }
     */
    public static MemorySegment sranddev$address() {
        return sranddev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sranddev(void)
     * }
     */
    public static void sranddev() {
        var mh$ = sranddev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sranddev");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandomdev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("srandomdev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srandomdev(void)
     * }
     */
    public static FunctionDescriptor srandomdev$descriptor() {
        return srandomdev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srandomdev(void)
     * }
     */
    public static MethodHandle srandomdev$handle() {
        return srandomdev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srandomdev(void)
     * }
     */
    public static MemorySegment srandomdev$address() {
        return srandomdev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srandomdev(void)
     * }
     */
    public static void srandomdev() {
        var mh$ = srandomdev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandomdev");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtonum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG_LONG,
            mlx_h.C_LONG_LONG,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtonum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static FunctionDescriptor strtonum$descriptor() {
        return strtonum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static MethodHandle strtonum$handle() {
        return strtonum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static MemorySegment strtonum$address() {
        return strtonum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static long strtonum(MemorySegment __numstr, long __minval, long __maxval, MemorySegment __errstrp) {
        var mh$ = strtonum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtonum", __numstr, __minval, __maxval, __errstrp);
            }
            return (long)mh$.invokeExact(__numstr, __minval, __maxval, __errstrp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoq$descriptor() {
        return strtoq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoq$handle() {
        return strtoq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoq$address() {
        return strtoq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoq(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoq", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtouq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtouq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtouq$descriptor() {
        return strtouq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtouq$handle() {
        return strtouq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtouq$address() {
        return strtouq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtouq(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtouq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtouq", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class suboptarg$constants {
        public static final AddressLayout LAYOUT = mlx_h.C_POINTER;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("suboptarg").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static AddressLayout suboptarg$layout() {
        return suboptarg$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg$segment() {
        return suboptarg$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg() {
        return suboptarg$constants.SEGMENT.get(suboptarg$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static void suboptarg(MemorySegment varValue) {
        suboptarg$constants.SEGMENT.set(suboptarg$constants.LAYOUT, 0L, varValue);
    }
    private static final int MLX_BOOL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum mlx_dtype_.MLX_BOOL = 0
     * }
     */
    public static int MLX_BOOL() {
        return MLX_BOOL;
    }
    private static final int MLX_UINT8 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum mlx_dtype_.MLX_UINT8 = 1
     * }
     */
    public static int MLX_UINT8() {
        return MLX_UINT8;
    }
    private static final int MLX_UINT16 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum mlx_dtype_.MLX_UINT16 = 2
     * }
     */
    public static int MLX_UINT16() {
        return MLX_UINT16;
    }
    private static final int MLX_UINT32 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum mlx_dtype_.MLX_UINT32 = 3
     * }
     */
    public static int MLX_UINT32() {
        return MLX_UINT32;
    }
    private static final int MLX_UINT64 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum mlx_dtype_.MLX_UINT64 = 4
     * }
     */
    public static int MLX_UINT64() {
        return MLX_UINT64;
    }
    private static final int MLX_INT8 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum mlx_dtype_.MLX_INT8 = 5
     * }
     */
    public static int MLX_INT8() {
        return MLX_INT8;
    }
    private static final int MLX_INT16 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum mlx_dtype_.MLX_INT16 = 6
     * }
     */
    public static int MLX_INT16() {
        return MLX_INT16;
    }
    private static final int MLX_INT32 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum mlx_dtype_.MLX_INT32 = 7
     * }
     */
    public static int MLX_INT32() {
        return MLX_INT32;
    }
    private static final int MLX_INT64 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum mlx_dtype_.MLX_INT64 = 8
     * }
     */
    public static int MLX_INT64() {
        return MLX_INT64;
    }
    private static final int MLX_FLOAT16 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum mlx_dtype_.MLX_FLOAT16 = 9
     * }
     */
    public static int MLX_FLOAT16() {
        return MLX_FLOAT16;
    }
    private static final int MLX_FLOAT32 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum mlx_dtype_.MLX_FLOAT32 = 10
     * }
     */
    public static int MLX_FLOAT32() {
        return MLX_FLOAT32;
    }
    private static final int MLX_FLOAT64 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum mlx_dtype_.MLX_FLOAT64 = 11
     * }
     */
    public static int MLX_FLOAT64() {
        return MLX_FLOAT64;
    }
    private static final int MLX_BFLOAT16 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum mlx_dtype_.MLX_BFLOAT16 = 12
     * }
     */
    public static int MLX_BFLOAT16() {
        return MLX_BFLOAT16;
    }
    private static final int MLX_COMPLEX64 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum mlx_dtype_.MLX_COMPLEX64 = 13
     * }
     */
    public static int MLX_COMPLEX64() {
        return MLX_COMPLEX64;
    }

    private static class mlx_dtype_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_dtype_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mlx_dtype_size(mlx_dtype dtype)
     * }
     */
    public static FunctionDescriptor mlx_dtype_size$descriptor() {
        return mlx_dtype_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mlx_dtype_size(mlx_dtype dtype)
     * }
     */
    public static MethodHandle mlx_dtype_size$handle() {
        return mlx_dtype_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mlx_dtype_size(mlx_dtype dtype)
     * }
     */
    public static MemorySegment mlx_dtype_size$address() {
        return mlx_dtype_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mlx_dtype_size(mlx_dtype dtype)
     * }
     */
    public static long mlx_dtype_size(int dtype) {
        var mh$ = mlx_dtype_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_dtype_size", dtype);
            }
            return (long)mh$.invokeExact(dtype);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_tostring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_tostring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_tostring(mlx_string *str, const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_tostring$descriptor() {
        return mlx_array_tostring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_tostring(mlx_string *str, const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_tostring$handle() {
        return mlx_array_tostring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_tostring(mlx_string *str, const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_tostring$address() {
        return mlx_array_tostring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_tostring(mlx_string *str, const mlx_array arr)
     * }
     */
    public static int mlx_array_tostring(MemorySegment str, MemorySegment arr) {
        var mh$ = mlx_array_tostring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_tostring", str, arr);
            }
            return (int)mh$.invokeExact(str, arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * mlx_array mlx_array_new()
     * }
     */
    public static class mlx_array_new {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_array_.layout()        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_new");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private mlx_array_new(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * mlx_array mlx_array_new()
         * }
         */
        public static mlx_array_new makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new mlx_array_new(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("mlx_array_new", allocator, x0);
                }
                return (MemorySegment) spreader.invokeExact(allocator, x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class mlx_array_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_free(mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_free$descriptor() {
        return mlx_array_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_free(mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_free$handle() {
        return mlx_array_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_free(mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_free$address() {
        return mlx_array_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_free(mlx_array arr)
     * }
     */
    public static int mlx_array_free(MemorySegment arr) {
        var mh$ = mlx_array_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_free", arr);
            }
            return (int)mh$.invokeExact(arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_new_bool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_array_.layout(),
            mlx_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_new_bool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_array mlx_array_new_bool(bool val)
     * }
     */
    public static FunctionDescriptor mlx_array_new_bool$descriptor() {
        return mlx_array_new_bool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_array mlx_array_new_bool(bool val)
     * }
     */
    public static MethodHandle mlx_array_new_bool$handle() {
        return mlx_array_new_bool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_array mlx_array_new_bool(bool val)
     * }
     */
    public static MemorySegment mlx_array_new_bool$address() {
        return mlx_array_new_bool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_array mlx_array_new_bool(bool val)
     * }
     */
    public static MemorySegment mlx_array_new_bool(SegmentAllocator allocator, boolean val) {
        var mh$ = mlx_array_new_bool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_new_bool", allocator, val);
            }
            return (MemorySegment)mh$.invokeExact(allocator, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_new_int {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_array_.layout(),
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_new_int");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_array mlx_array_new_int(int val)
     * }
     */
    public static FunctionDescriptor mlx_array_new_int$descriptor() {
        return mlx_array_new_int.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_array mlx_array_new_int(int val)
     * }
     */
    public static MethodHandle mlx_array_new_int$handle() {
        return mlx_array_new_int.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_array mlx_array_new_int(int val)
     * }
     */
    public static MemorySegment mlx_array_new_int$address() {
        return mlx_array_new_int.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_array mlx_array_new_int(int val)
     * }
     */
    public static MemorySegment mlx_array_new_int(SegmentAllocator allocator, int val) {
        var mh$ = mlx_array_new_int.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_new_int", allocator, val);
            }
            return (MemorySegment)mh$.invokeExact(allocator, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_new_float32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_array_.layout(),
            mlx_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_new_float32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_array mlx_array_new_float32(float val)
     * }
     */
    public static FunctionDescriptor mlx_array_new_float32$descriptor() {
        return mlx_array_new_float32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_array mlx_array_new_float32(float val)
     * }
     */
    public static MethodHandle mlx_array_new_float32$handle() {
        return mlx_array_new_float32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_array mlx_array_new_float32(float val)
     * }
     */
    public static MemorySegment mlx_array_new_float32$address() {
        return mlx_array_new_float32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_array mlx_array_new_float32(float val)
     * }
     */
    public static MemorySegment mlx_array_new_float32(SegmentAllocator allocator, float val) {
        var mh$ = mlx_array_new_float32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_new_float32", allocator, val);
            }
            return (MemorySegment)mh$.invokeExact(allocator, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_new_float {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_array_.layout(),
            mlx_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_new_float");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_array mlx_array_new_float(float val)
     * }
     */
    public static FunctionDescriptor mlx_array_new_float$descriptor() {
        return mlx_array_new_float.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_array mlx_array_new_float(float val)
     * }
     */
    public static MethodHandle mlx_array_new_float$handle() {
        return mlx_array_new_float.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_array mlx_array_new_float(float val)
     * }
     */
    public static MemorySegment mlx_array_new_float$address() {
        return mlx_array_new_float.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_array mlx_array_new_float(float val)
     * }
     */
    public static MemorySegment mlx_array_new_float(SegmentAllocator allocator, float val) {
        var mh$ = mlx_array_new_float.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_new_float", allocator, val);
            }
            return (MemorySegment)mh$.invokeExact(allocator, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_new_float64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_array_.layout(),
            mlx_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_new_float64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_array mlx_array_new_float64(double val)
     * }
     */
    public static FunctionDescriptor mlx_array_new_float64$descriptor() {
        return mlx_array_new_float64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_array mlx_array_new_float64(double val)
     * }
     */
    public static MethodHandle mlx_array_new_float64$handle() {
        return mlx_array_new_float64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_array mlx_array_new_float64(double val)
     * }
     */
    public static MemorySegment mlx_array_new_float64$address() {
        return mlx_array_new_float64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_array mlx_array_new_float64(double val)
     * }
     */
    public static MemorySegment mlx_array_new_float64(SegmentAllocator allocator, double val) {
        var mh$ = mlx_array_new_float64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_new_float64", allocator, val);
            }
            return (MemorySegment)mh$.invokeExact(allocator, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_new_double {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_array_.layout(),
            mlx_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_new_double");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_array mlx_array_new_double(double val)
     * }
     */
    public static FunctionDescriptor mlx_array_new_double$descriptor() {
        return mlx_array_new_double.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_array mlx_array_new_double(double val)
     * }
     */
    public static MethodHandle mlx_array_new_double$handle() {
        return mlx_array_new_double.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_array mlx_array_new_double(double val)
     * }
     */
    public static MemorySegment mlx_array_new_double$address() {
        return mlx_array_new_double.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_array mlx_array_new_double(double val)
     * }
     */
    public static MemorySegment mlx_array_new_double(SegmentAllocator allocator, double val) {
        var mh$ = mlx_array_new_double.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_new_double", allocator, val);
            }
            return (MemorySegment)mh$.invokeExact(allocator, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_new_complex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_array_.layout(),
            mlx_h.C_FLOAT,
            mlx_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_new_complex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_array mlx_array_new_complex(float real_val, float imag_val)
     * }
     */
    public static FunctionDescriptor mlx_array_new_complex$descriptor() {
        return mlx_array_new_complex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_array mlx_array_new_complex(float real_val, float imag_val)
     * }
     */
    public static MethodHandle mlx_array_new_complex$handle() {
        return mlx_array_new_complex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_array mlx_array_new_complex(float real_val, float imag_val)
     * }
     */
    public static MemorySegment mlx_array_new_complex$address() {
        return mlx_array_new_complex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_array mlx_array_new_complex(float real_val, float imag_val)
     * }
     */
    public static MemorySegment mlx_array_new_complex(SegmentAllocator allocator, float real_val, float imag_val) {
        var mh$ = mlx_array_new_complex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_new_complex", allocator, real_val, imag_val);
            }
            return (MemorySegment)mh$.invokeExact(allocator, real_val, imag_val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_new_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_INT,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_new_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_array mlx_array_new_data(const void *data, const int *shape, int dim, mlx_dtype dtype)
     * }
     */
    public static FunctionDescriptor mlx_array_new_data$descriptor() {
        return mlx_array_new_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_array mlx_array_new_data(const void *data, const int *shape, int dim, mlx_dtype dtype)
     * }
     */
    public static MethodHandle mlx_array_new_data$handle() {
        return mlx_array_new_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_array mlx_array_new_data(const void *data, const int *shape, int dim, mlx_dtype dtype)
     * }
     */
    public static MemorySegment mlx_array_new_data$address() {
        return mlx_array_new_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_array mlx_array_new_data(const void *data, const int *shape, int dim, mlx_dtype dtype)
     * }
     */
    public static MemorySegment mlx_array_new_data(SegmentAllocator allocator, MemorySegment data, MemorySegment shape, int dim, int dtype) {
        var mh$ = mlx_array_new_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_new_data", allocator, data, shape, dim, dtype);
            }
            return (MemorySegment)mh$.invokeExact(allocator, data, shape, dim, dtype);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_set(mlx_array *arr, const mlx_array src)
     * }
     */
    public static FunctionDescriptor mlx_array_set$descriptor() {
        return mlx_array_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_set(mlx_array *arr, const mlx_array src)
     * }
     */
    public static MethodHandle mlx_array_set$handle() {
        return mlx_array_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_set(mlx_array *arr, const mlx_array src)
     * }
     */
    public static MemorySegment mlx_array_set$address() {
        return mlx_array_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_set(mlx_array *arr, const mlx_array src)
     * }
     */
    public static int mlx_array_set(MemorySegment arr, MemorySegment src) {
        var mh$ = mlx_array_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_set", arr, src);
            }
            return (int)mh$.invokeExact(arr, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_set_bool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_set_bool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_set_bool(mlx_array *arr, bool val)
     * }
     */
    public static FunctionDescriptor mlx_array_set_bool$descriptor() {
        return mlx_array_set_bool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_set_bool(mlx_array *arr, bool val)
     * }
     */
    public static MethodHandle mlx_array_set_bool$handle() {
        return mlx_array_set_bool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_set_bool(mlx_array *arr, bool val)
     * }
     */
    public static MemorySegment mlx_array_set_bool$address() {
        return mlx_array_set_bool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_set_bool(mlx_array *arr, bool val)
     * }
     */
    public static int mlx_array_set_bool(MemorySegment arr, boolean val) {
        var mh$ = mlx_array_set_bool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_set_bool", arr, val);
            }
            return (int)mh$.invokeExact(arr, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_set_int {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_set_int");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_set_int(mlx_array *arr, int val)
     * }
     */
    public static FunctionDescriptor mlx_array_set_int$descriptor() {
        return mlx_array_set_int.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_set_int(mlx_array *arr, int val)
     * }
     */
    public static MethodHandle mlx_array_set_int$handle() {
        return mlx_array_set_int.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_set_int(mlx_array *arr, int val)
     * }
     */
    public static MemorySegment mlx_array_set_int$address() {
        return mlx_array_set_int.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_set_int(mlx_array *arr, int val)
     * }
     */
    public static int mlx_array_set_int(MemorySegment arr, int val) {
        var mh$ = mlx_array_set_int.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_set_int", arr, val);
            }
            return (int)mh$.invokeExact(arr, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_set_float32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_set_float32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_set_float32(mlx_array *arr, float val)
     * }
     */
    public static FunctionDescriptor mlx_array_set_float32$descriptor() {
        return mlx_array_set_float32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_set_float32(mlx_array *arr, float val)
     * }
     */
    public static MethodHandle mlx_array_set_float32$handle() {
        return mlx_array_set_float32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_set_float32(mlx_array *arr, float val)
     * }
     */
    public static MemorySegment mlx_array_set_float32$address() {
        return mlx_array_set_float32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_set_float32(mlx_array *arr, float val)
     * }
     */
    public static int mlx_array_set_float32(MemorySegment arr, float val) {
        var mh$ = mlx_array_set_float32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_set_float32", arr, val);
            }
            return (int)mh$.invokeExact(arr, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_set_float {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_set_float");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_set_float(mlx_array *arr, float val)
     * }
     */
    public static FunctionDescriptor mlx_array_set_float$descriptor() {
        return mlx_array_set_float.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_set_float(mlx_array *arr, float val)
     * }
     */
    public static MethodHandle mlx_array_set_float$handle() {
        return mlx_array_set_float.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_set_float(mlx_array *arr, float val)
     * }
     */
    public static MemorySegment mlx_array_set_float$address() {
        return mlx_array_set_float.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_set_float(mlx_array *arr, float val)
     * }
     */
    public static int mlx_array_set_float(MemorySegment arr, float val) {
        var mh$ = mlx_array_set_float.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_set_float", arr, val);
            }
            return (int)mh$.invokeExact(arr, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_set_float64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_set_float64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_set_float64(mlx_array *arr, double val)
     * }
     */
    public static FunctionDescriptor mlx_array_set_float64$descriptor() {
        return mlx_array_set_float64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_set_float64(mlx_array *arr, double val)
     * }
     */
    public static MethodHandle mlx_array_set_float64$handle() {
        return mlx_array_set_float64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_set_float64(mlx_array *arr, double val)
     * }
     */
    public static MemorySegment mlx_array_set_float64$address() {
        return mlx_array_set_float64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_set_float64(mlx_array *arr, double val)
     * }
     */
    public static int mlx_array_set_float64(MemorySegment arr, double val) {
        var mh$ = mlx_array_set_float64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_set_float64", arr, val);
            }
            return (int)mh$.invokeExact(arr, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_set_double {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_set_double");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_set_double(mlx_array *arr, double val)
     * }
     */
    public static FunctionDescriptor mlx_array_set_double$descriptor() {
        return mlx_array_set_double.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_set_double(mlx_array *arr, double val)
     * }
     */
    public static MethodHandle mlx_array_set_double$handle() {
        return mlx_array_set_double.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_set_double(mlx_array *arr, double val)
     * }
     */
    public static MemorySegment mlx_array_set_double$address() {
        return mlx_array_set_double.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_set_double(mlx_array *arr, double val)
     * }
     */
    public static int mlx_array_set_double(MemorySegment arr, double val) {
        var mh$ = mlx_array_set_double.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_set_double", arr, val);
            }
            return (int)mh$.invokeExact(arr, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_set_complex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_FLOAT,
            mlx_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_set_complex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_set_complex(mlx_array *arr, float real_val, float imag_val)
     * }
     */
    public static FunctionDescriptor mlx_array_set_complex$descriptor() {
        return mlx_array_set_complex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_set_complex(mlx_array *arr, float real_val, float imag_val)
     * }
     */
    public static MethodHandle mlx_array_set_complex$handle() {
        return mlx_array_set_complex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_set_complex(mlx_array *arr, float real_val, float imag_val)
     * }
     */
    public static MemorySegment mlx_array_set_complex$address() {
        return mlx_array_set_complex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_set_complex(mlx_array *arr, float real_val, float imag_val)
     * }
     */
    public static int mlx_array_set_complex(MemorySegment arr, float real_val, float imag_val) {
        var mh$ = mlx_array_set_complex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_set_complex", arr, real_val, imag_val);
            }
            return (int)mh$.invokeExact(arr, real_val, imag_val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_set_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_INT,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_set_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_set_data(mlx_array *arr, const void *data, const int *shape, int dim, mlx_dtype dtype)
     * }
     */
    public static FunctionDescriptor mlx_array_set_data$descriptor() {
        return mlx_array_set_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_set_data(mlx_array *arr, const void *data, const int *shape, int dim, mlx_dtype dtype)
     * }
     */
    public static MethodHandle mlx_array_set_data$handle() {
        return mlx_array_set_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_set_data(mlx_array *arr, const void *data, const int *shape, int dim, mlx_dtype dtype)
     * }
     */
    public static MemorySegment mlx_array_set_data$address() {
        return mlx_array_set_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_set_data(mlx_array *arr, const void *data, const int *shape, int dim, mlx_dtype dtype)
     * }
     */
    public static int mlx_array_set_data(MemorySegment arr, MemorySegment data, MemorySegment shape, int dim, int dtype) {
        var mh$ = mlx_array_set_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_set_data", arr, data, shape, dim, dtype);
            }
            return (int)mh$.invokeExact(arr, data, shape, dim, dtype);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_itemsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_itemsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mlx_array_itemsize(const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_itemsize$descriptor() {
        return mlx_array_itemsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mlx_array_itemsize(const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_itemsize$handle() {
        return mlx_array_itemsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mlx_array_itemsize(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_itemsize$address() {
        return mlx_array_itemsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mlx_array_itemsize(const mlx_array arr)
     * }
     */
    public static long mlx_array_itemsize(MemorySegment arr) {
        var mh$ = mlx_array_itemsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_itemsize", arr);
            }
            return (long)mh$.invokeExact(arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mlx_array_size(const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_size$descriptor() {
        return mlx_array_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mlx_array_size(const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_size$handle() {
        return mlx_array_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mlx_array_size(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_size$address() {
        return mlx_array_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mlx_array_size(const mlx_array arr)
     * }
     */
    public static long mlx_array_size(MemorySegment arr) {
        var mh$ = mlx_array_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_size", arr);
            }
            return (long)mh$.invokeExact(arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_nbytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_nbytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mlx_array_nbytes(const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_nbytes$descriptor() {
        return mlx_array_nbytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mlx_array_nbytes(const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_nbytes$handle() {
        return mlx_array_nbytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mlx_array_nbytes(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_nbytes$address() {
        return mlx_array_nbytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mlx_array_nbytes(const mlx_array arr)
     * }
     */
    public static long mlx_array_nbytes(MemorySegment arr) {
        var mh$ = mlx_array_nbytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_nbytes", arr);
            }
            return (long)mh$.invokeExact(arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_ndim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_ndim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mlx_array_ndim(const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_ndim$descriptor() {
        return mlx_array_ndim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mlx_array_ndim(const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_ndim$handle() {
        return mlx_array_ndim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mlx_array_ndim(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_ndim$address() {
        return mlx_array_ndim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mlx_array_ndim(const mlx_array arr)
     * }
     */
    public static long mlx_array_ndim(MemorySegment arr) {
        var mh$ = mlx_array_ndim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_ndim", arr);
            }
            return (long)mh$.invokeExact(arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_shape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_shape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const int *mlx_array_shape(const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_shape$descriptor() {
        return mlx_array_shape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const int *mlx_array_shape(const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_shape$handle() {
        return mlx_array_shape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const int *mlx_array_shape(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_shape$address() {
        return mlx_array_shape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const int *mlx_array_shape(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_shape(MemorySegment arr) {
        var mh$ = mlx_array_shape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_shape", arr);
            }
            return (MemorySegment)mh$.invokeExact(arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_strides {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_strides");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const size_t *mlx_array_strides(const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_strides$descriptor() {
        return mlx_array_strides.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const size_t *mlx_array_strides(const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_strides$handle() {
        return mlx_array_strides.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const size_t *mlx_array_strides(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_strides$address() {
        return mlx_array_strides.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const size_t *mlx_array_strides(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_strides(MemorySegment arr) {
        var mh$ = mlx_array_strides.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_strides", arr);
            }
            return (MemorySegment)mh$.invokeExact(arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_dim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_array_.layout(),
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_dim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_dim(const mlx_array arr, int dim)
     * }
     */
    public static FunctionDescriptor mlx_array_dim$descriptor() {
        return mlx_array_dim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_dim(const mlx_array arr, int dim)
     * }
     */
    public static MethodHandle mlx_array_dim$handle() {
        return mlx_array_dim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_dim(const mlx_array arr, int dim)
     * }
     */
    public static MemorySegment mlx_array_dim$address() {
        return mlx_array_dim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_dim(const mlx_array arr, int dim)
     * }
     */
    public static int mlx_array_dim(MemorySegment arr, int dim) {
        var mh$ = mlx_array_dim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_dim", arr, dim);
            }
            return (int)mh$.invokeExact(arr, dim);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_dtype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_dtype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_dtype mlx_array_dtype(const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_dtype$descriptor() {
        return mlx_array_dtype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_dtype mlx_array_dtype(const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_dtype$handle() {
        return mlx_array_dtype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_dtype mlx_array_dtype(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_dtype$address() {
        return mlx_array_dtype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_dtype mlx_array_dtype(const mlx_array arr)
     * }
     */
    public static int mlx_array_dtype(MemorySegment arr) {
        var mh$ = mlx_array_dtype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_dtype", arr);
            }
            return (int)mh$.invokeExact(arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_eval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_eval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_eval(mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_eval$descriptor() {
        return mlx_array_eval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_eval(mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_eval$handle() {
        return mlx_array_eval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_eval(mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_eval$address() {
        return mlx_array_eval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_eval(mlx_array arr)
     * }
     */
    public static int mlx_array_eval(MemorySegment arr) {
        var mh$ = mlx_array_eval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_eval", arr);
            }
            return (int)mh$.invokeExact(arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_item_bool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_item_bool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_item_bool(bool *res, const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_item_bool$descriptor() {
        return mlx_array_item_bool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_item_bool(bool *res, const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_item_bool$handle() {
        return mlx_array_item_bool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_item_bool(bool *res, const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_item_bool$address() {
        return mlx_array_item_bool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_item_bool(bool *res, const mlx_array arr)
     * }
     */
    public static int mlx_array_item_bool(MemorySegment res, MemorySegment arr) {
        var mh$ = mlx_array_item_bool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_item_bool", res, arr);
            }
            return (int)mh$.invokeExact(res, arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_item_uint8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_item_uint8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_item_uint8(uint8_t *res, const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_item_uint8$descriptor() {
        return mlx_array_item_uint8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_item_uint8(uint8_t *res, const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_item_uint8$handle() {
        return mlx_array_item_uint8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_item_uint8(uint8_t *res, const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_item_uint8$address() {
        return mlx_array_item_uint8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_item_uint8(uint8_t *res, const mlx_array arr)
     * }
     */
    public static int mlx_array_item_uint8(MemorySegment res, MemorySegment arr) {
        var mh$ = mlx_array_item_uint8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_item_uint8", res, arr);
            }
            return (int)mh$.invokeExact(res, arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_item_uint16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_item_uint16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_item_uint16(uint16_t *res, const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_item_uint16$descriptor() {
        return mlx_array_item_uint16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_item_uint16(uint16_t *res, const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_item_uint16$handle() {
        return mlx_array_item_uint16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_item_uint16(uint16_t *res, const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_item_uint16$address() {
        return mlx_array_item_uint16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_item_uint16(uint16_t *res, const mlx_array arr)
     * }
     */
    public static int mlx_array_item_uint16(MemorySegment res, MemorySegment arr) {
        var mh$ = mlx_array_item_uint16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_item_uint16", res, arr);
            }
            return (int)mh$.invokeExact(res, arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_item_uint32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_item_uint32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_item_uint32(uint32_t *res, const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_item_uint32$descriptor() {
        return mlx_array_item_uint32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_item_uint32(uint32_t *res, const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_item_uint32$handle() {
        return mlx_array_item_uint32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_item_uint32(uint32_t *res, const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_item_uint32$address() {
        return mlx_array_item_uint32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_item_uint32(uint32_t *res, const mlx_array arr)
     * }
     */
    public static int mlx_array_item_uint32(MemorySegment res, MemorySegment arr) {
        var mh$ = mlx_array_item_uint32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_item_uint32", res, arr);
            }
            return (int)mh$.invokeExact(res, arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_item_uint64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_item_uint64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_item_uint64(uint64_t *res, const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_item_uint64$descriptor() {
        return mlx_array_item_uint64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_item_uint64(uint64_t *res, const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_item_uint64$handle() {
        return mlx_array_item_uint64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_item_uint64(uint64_t *res, const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_item_uint64$address() {
        return mlx_array_item_uint64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_item_uint64(uint64_t *res, const mlx_array arr)
     * }
     */
    public static int mlx_array_item_uint64(MemorySegment res, MemorySegment arr) {
        var mh$ = mlx_array_item_uint64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_item_uint64", res, arr);
            }
            return (int)mh$.invokeExact(res, arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_item_int8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_item_int8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_item_int8(int8_t *res, const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_item_int8$descriptor() {
        return mlx_array_item_int8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_item_int8(int8_t *res, const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_item_int8$handle() {
        return mlx_array_item_int8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_item_int8(int8_t *res, const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_item_int8$address() {
        return mlx_array_item_int8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_item_int8(int8_t *res, const mlx_array arr)
     * }
     */
    public static int mlx_array_item_int8(MemorySegment res, MemorySegment arr) {
        var mh$ = mlx_array_item_int8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_item_int8", res, arr);
            }
            return (int)mh$.invokeExact(res, arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_item_int16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_item_int16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_item_int16(int16_t *res, const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_item_int16$descriptor() {
        return mlx_array_item_int16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_item_int16(int16_t *res, const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_item_int16$handle() {
        return mlx_array_item_int16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_item_int16(int16_t *res, const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_item_int16$address() {
        return mlx_array_item_int16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_item_int16(int16_t *res, const mlx_array arr)
     * }
     */
    public static int mlx_array_item_int16(MemorySegment res, MemorySegment arr) {
        var mh$ = mlx_array_item_int16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_item_int16", res, arr);
            }
            return (int)mh$.invokeExact(res, arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_item_int32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_item_int32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_item_int32(int32_t *res, const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_item_int32$descriptor() {
        return mlx_array_item_int32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_item_int32(int32_t *res, const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_item_int32$handle() {
        return mlx_array_item_int32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_item_int32(int32_t *res, const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_item_int32$address() {
        return mlx_array_item_int32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_item_int32(int32_t *res, const mlx_array arr)
     * }
     */
    public static int mlx_array_item_int32(MemorySegment res, MemorySegment arr) {
        var mh$ = mlx_array_item_int32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_item_int32", res, arr);
            }
            return (int)mh$.invokeExact(res, arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_item_int64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_item_int64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_item_int64(int64_t *res, const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_item_int64$descriptor() {
        return mlx_array_item_int64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_item_int64(int64_t *res, const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_item_int64$handle() {
        return mlx_array_item_int64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_item_int64(int64_t *res, const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_item_int64$address() {
        return mlx_array_item_int64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_item_int64(int64_t *res, const mlx_array arr)
     * }
     */
    public static int mlx_array_item_int64(MemorySegment res, MemorySegment arr) {
        var mh$ = mlx_array_item_int64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_item_int64", res, arr);
            }
            return (int)mh$.invokeExact(res, arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_item_float32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_item_float32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_item_float32(float *res, const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_item_float32$descriptor() {
        return mlx_array_item_float32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_item_float32(float *res, const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_item_float32$handle() {
        return mlx_array_item_float32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_item_float32(float *res, const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_item_float32$address() {
        return mlx_array_item_float32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_item_float32(float *res, const mlx_array arr)
     * }
     */
    public static int mlx_array_item_float32(MemorySegment res, MemorySegment arr) {
        var mh$ = mlx_array_item_float32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_item_float32", res, arr);
            }
            return (int)mh$.invokeExact(res, arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_item_float64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_item_float64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_item_float64(double *res, const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_item_float64$descriptor() {
        return mlx_array_item_float64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_item_float64(double *res, const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_item_float64$handle() {
        return mlx_array_item_float64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_item_float64(double *res, const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_item_float64$address() {
        return mlx_array_item_float64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_item_float64(double *res, const mlx_array arr)
     * }
     */
    public static int mlx_array_item_float64(MemorySegment res, MemorySegment arr) {
        var mh$ = mlx_array_item_float64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_item_float64", res, arr);
            }
            return (int)mh$.invokeExact(res, arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_item_complex64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_item_complex64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_item_complex64(_Complex float *res, const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_item_complex64$descriptor() {
        return mlx_array_item_complex64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_item_complex64(_Complex float *res, const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_item_complex64$handle() {
        return mlx_array_item_complex64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_item_complex64(_Complex float *res, const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_item_complex64$address() {
        return mlx_array_item_complex64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_item_complex64(_Complex float *res, const mlx_array arr)
     * }
     */
    public static int mlx_array_item_complex64(MemorySegment res, MemorySegment arr) {
        var mh$ = mlx_array_item_complex64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_item_complex64", res, arr);
            }
            return (int)mh$.invokeExact(res, arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_item_float16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_item_float16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_item_float16(float16_t *res, const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_item_float16$descriptor() {
        return mlx_array_item_float16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_item_float16(float16_t *res, const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_item_float16$handle() {
        return mlx_array_item_float16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_item_float16(float16_t *res, const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_item_float16$address() {
        return mlx_array_item_float16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_item_float16(float16_t *res, const mlx_array arr)
     * }
     */
    public static int mlx_array_item_float16(MemorySegment res, MemorySegment arr) {
        var mh$ = mlx_array_item_float16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_item_float16", res, arr);
            }
            return (int)mh$.invokeExact(res, arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_item_bfloat16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_item_bfloat16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_item_bfloat16(bfloat16_t *res, const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_item_bfloat16$descriptor() {
        return mlx_array_item_bfloat16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_item_bfloat16(bfloat16_t *res, const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_item_bfloat16$handle() {
        return mlx_array_item_bfloat16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_item_bfloat16(bfloat16_t *res, const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_item_bfloat16$address() {
        return mlx_array_item_bfloat16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_item_bfloat16(bfloat16_t *res, const mlx_array arr)
     * }
     */
    public static int mlx_array_item_bfloat16(MemorySegment res, MemorySegment arr) {
        var mh$ = mlx_array_item_bfloat16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_item_bfloat16", res, arr);
            }
            return (int)mh$.invokeExact(res, arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_data_bool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_data_bool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const bool *mlx_array_data_bool(const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_data_bool$descriptor() {
        return mlx_array_data_bool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const bool *mlx_array_data_bool(const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_data_bool$handle() {
        return mlx_array_data_bool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const bool *mlx_array_data_bool(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_bool$address() {
        return mlx_array_data_bool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const bool *mlx_array_data_bool(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_bool(MemorySegment arr) {
        var mh$ = mlx_array_data_bool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_data_bool", arr);
            }
            return (MemorySegment)mh$.invokeExact(arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_data_uint8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_data_uint8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const uint8_t *mlx_array_data_uint8(const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_data_uint8$descriptor() {
        return mlx_array_data_uint8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const uint8_t *mlx_array_data_uint8(const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_data_uint8$handle() {
        return mlx_array_data_uint8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const uint8_t *mlx_array_data_uint8(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_uint8$address() {
        return mlx_array_data_uint8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const uint8_t *mlx_array_data_uint8(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_uint8(MemorySegment arr) {
        var mh$ = mlx_array_data_uint8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_data_uint8", arr);
            }
            return (MemorySegment)mh$.invokeExact(arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_data_uint16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_data_uint16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const uint16_t *mlx_array_data_uint16(const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_data_uint16$descriptor() {
        return mlx_array_data_uint16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const uint16_t *mlx_array_data_uint16(const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_data_uint16$handle() {
        return mlx_array_data_uint16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const uint16_t *mlx_array_data_uint16(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_uint16$address() {
        return mlx_array_data_uint16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const uint16_t *mlx_array_data_uint16(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_uint16(MemorySegment arr) {
        var mh$ = mlx_array_data_uint16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_data_uint16", arr);
            }
            return (MemorySegment)mh$.invokeExact(arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_data_uint32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_data_uint32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const uint32_t *mlx_array_data_uint32(const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_data_uint32$descriptor() {
        return mlx_array_data_uint32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const uint32_t *mlx_array_data_uint32(const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_data_uint32$handle() {
        return mlx_array_data_uint32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const uint32_t *mlx_array_data_uint32(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_uint32$address() {
        return mlx_array_data_uint32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const uint32_t *mlx_array_data_uint32(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_uint32(MemorySegment arr) {
        var mh$ = mlx_array_data_uint32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_data_uint32", arr);
            }
            return (MemorySegment)mh$.invokeExact(arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_data_uint64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_data_uint64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const uint64_t *mlx_array_data_uint64(const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_data_uint64$descriptor() {
        return mlx_array_data_uint64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const uint64_t *mlx_array_data_uint64(const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_data_uint64$handle() {
        return mlx_array_data_uint64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const uint64_t *mlx_array_data_uint64(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_uint64$address() {
        return mlx_array_data_uint64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const uint64_t *mlx_array_data_uint64(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_uint64(MemorySegment arr) {
        var mh$ = mlx_array_data_uint64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_data_uint64", arr);
            }
            return (MemorySegment)mh$.invokeExact(arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_data_int8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_data_int8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const int8_t *mlx_array_data_int8(const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_data_int8$descriptor() {
        return mlx_array_data_int8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const int8_t *mlx_array_data_int8(const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_data_int8$handle() {
        return mlx_array_data_int8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const int8_t *mlx_array_data_int8(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_int8$address() {
        return mlx_array_data_int8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const int8_t *mlx_array_data_int8(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_int8(MemorySegment arr) {
        var mh$ = mlx_array_data_int8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_data_int8", arr);
            }
            return (MemorySegment)mh$.invokeExact(arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_data_int16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_data_int16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const int16_t *mlx_array_data_int16(const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_data_int16$descriptor() {
        return mlx_array_data_int16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const int16_t *mlx_array_data_int16(const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_data_int16$handle() {
        return mlx_array_data_int16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const int16_t *mlx_array_data_int16(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_int16$address() {
        return mlx_array_data_int16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const int16_t *mlx_array_data_int16(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_int16(MemorySegment arr) {
        var mh$ = mlx_array_data_int16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_data_int16", arr);
            }
            return (MemorySegment)mh$.invokeExact(arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_data_int32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_data_int32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const int32_t *mlx_array_data_int32(const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_data_int32$descriptor() {
        return mlx_array_data_int32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const int32_t *mlx_array_data_int32(const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_data_int32$handle() {
        return mlx_array_data_int32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const int32_t *mlx_array_data_int32(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_int32$address() {
        return mlx_array_data_int32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const int32_t *mlx_array_data_int32(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_int32(MemorySegment arr) {
        var mh$ = mlx_array_data_int32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_data_int32", arr);
            }
            return (MemorySegment)mh$.invokeExact(arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_data_int64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_data_int64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const int64_t *mlx_array_data_int64(const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_data_int64$descriptor() {
        return mlx_array_data_int64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const int64_t *mlx_array_data_int64(const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_data_int64$handle() {
        return mlx_array_data_int64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const int64_t *mlx_array_data_int64(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_int64$address() {
        return mlx_array_data_int64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const int64_t *mlx_array_data_int64(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_int64(MemorySegment arr) {
        var mh$ = mlx_array_data_int64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_data_int64", arr);
            }
            return (MemorySegment)mh$.invokeExact(arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_data_float32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_data_float32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const float *mlx_array_data_float32(const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_data_float32$descriptor() {
        return mlx_array_data_float32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const float *mlx_array_data_float32(const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_data_float32$handle() {
        return mlx_array_data_float32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const float *mlx_array_data_float32(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_float32$address() {
        return mlx_array_data_float32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const float *mlx_array_data_float32(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_float32(MemorySegment arr) {
        var mh$ = mlx_array_data_float32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_data_float32", arr);
            }
            return (MemorySegment)mh$.invokeExact(arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_data_float64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_data_float64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const double *mlx_array_data_float64(const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_data_float64$descriptor() {
        return mlx_array_data_float64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const double *mlx_array_data_float64(const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_data_float64$handle() {
        return mlx_array_data_float64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const double *mlx_array_data_float64(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_float64$address() {
        return mlx_array_data_float64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const double *mlx_array_data_float64(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_float64(MemorySegment arr) {
        var mh$ = mlx_array_data_float64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_data_float64", arr);
            }
            return (MemorySegment)mh$.invokeExact(arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_data_complex64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_data_complex64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const _Complex float *mlx_array_data_complex64(const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_data_complex64$descriptor() {
        return mlx_array_data_complex64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const _Complex float *mlx_array_data_complex64(const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_data_complex64$handle() {
        return mlx_array_data_complex64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const _Complex float *mlx_array_data_complex64(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_complex64$address() {
        return mlx_array_data_complex64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const _Complex float *mlx_array_data_complex64(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_complex64(MemorySegment arr) {
        var mh$ = mlx_array_data_complex64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_data_complex64", arr);
            }
            return (MemorySegment)mh$.invokeExact(arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_data_float16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_data_float16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const float16_t *mlx_array_data_float16(const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_data_float16$descriptor() {
        return mlx_array_data_float16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const float16_t *mlx_array_data_float16(const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_data_float16$handle() {
        return mlx_array_data_float16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const float16_t *mlx_array_data_float16(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_float16$address() {
        return mlx_array_data_float16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const float16_t *mlx_array_data_float16(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_float16(MemorySegment arr) {
        var mh$ = mlx_array_data_float16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_data_float16", arr);
            }
            return (MemorySegment)mh$.invokeExact(arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_data_bfloat16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_data_bfloat16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const bfloat16_t *mlx_array_data_bfloat16(const mlx_array arr)
     * }
     */
    public static FunctionDescriptor mlx_array_data_bfloat16$descriptor() {
        return mlx_array_data_bfloat16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const bfloat16_t *mlx_array_data_bfloat16(const mlx_array arr)
     * }
     */
    public static MethodHandle mlx_array_data_bfloat16$handle() {
        return mlx_array_data_bfloat16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const bfloat16_t *mlx_array_data_bfloat16(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_bfloat16$address() {
        return mlx_array_data_bfloat16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const bfloat16_t *mlx_array_data_bfloat16(const mlx_array arr)
     * }
     */
    public static MemorySegment mlx_array_data_bfloat16(MemorySegment arr) {
        var mh$ = mlx_array_data_bfloat16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_data_bfloat16", arr);
            }
            return (MemorySegment)mh$.invokeExact(arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mlx_array_is_available {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mlx_array_is_available");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _mlx_array_is_available(bool *res, const mlx_array arr)
     * }
     */
    public static FunctionDescriptor _mlx_array_is_available$descriptor() {
        return _mlx_array_is_available.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _mlx_array_is_available(bool *res, const mlx_array arr)
     * }
     */
    public static MethodHandle _mlx_array_is_available$handle() {
        return _mlx_array_is_available.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _mlx_array_is_available(bool *res, const mlx_array arr)
     * }
     */
    public static MemorySegment _mlx_array_is_available$address() {
        return _mlx_array_is_available.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _mlx_array_is_available(bool *res, const mlx_array arr)
     * }
     */
    public static int _mlx_array_is_available(MemorySegment res, MemorySegment arr) {
        var mh$ = _mlx_array_is_available.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mlx_array_is_available", res, arr);
            }
            return (int)mh$.invokeExact(res, arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mlx_array_wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mlx_array_wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _mlx_array_wait(const mlx_array arr)
     * }
     */
    public static FunctionDescriptor _mlx_array_wait$descriptor() {
        return _mlx_array_wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _mlx_array_wait(const mlx_array arr)
     * }
     */
    public static MethodHandle _mlx_array_wait$handle() {
        return _mlx_array_wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _mlx_array_wait(const mlx_array arr)
     * }
     */
    public static MemorySegment _mlx_array_wait$address() {
        return _mlx_array_wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _mlx_array_wait(const mlx_array arr)
     * }
     */
    public static int _mlx_array_wait(MemorySegment arr) {
        var mh$ = _mlx_array_wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mlx_array_wait", arr);
            }
            return (int)mh$.invokeExact(arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mlx_array_is_contiguous {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mlx_array_is_contiguous");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _mlx_array_is_contiguous(bool *res, const mlx_array arr)
     * }
     */
    public static FunctionDescriptor _mlx_array_is_contiguous$descriptor() {
        return _mlx_array_is_contiguous.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _mlx_array_is_contiguous(bool *res, const mlx_array arr)
     * }
     */
    public static MethodHandle _mlx_array_is_contiguous$handle() {
        return _mlx_array_is_contiguous.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _mlx_array_is_contiguous(bool *res, const mlx_array arr)
     * }
     */
    public static MemorySegment _mlx_array_is_contiguous$address() {
        return _mlx_array_is_contiguous.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _mlx_array_is_contiguous(bool *res, const mlx_array arr)
     * }
     */
    public static int _mlx_array_is_contiguous(MemorySegment res, MemorySegment arr) {
        var mh$ = _mlx_array_is_contiguous.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mlx_array_is_contiguous", res, arr);
            }
            return (int)mh$.invokeExact(res, arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mlx_array_is_row_contiguous {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mlx_array_is_row_contiguous");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _mlx_array_is_row_contiguous(bool *res, const mlx_array arr)
     * }
     */
    public static FunctionDescriptor _mlx_array_is_row_contiguous$descriptor() {
        return _mlx_array_is_row_contiguous.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _mlx_array_is_row_contiguous(bool *res, const mlx_array arr)
     * }
     */
    public static MethodHandle _mlx_array_is_row_contiguous$handle() {
        return _mlx_array_is_row_contiguous.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _mlx_array_is_row_contiguous(bool *res, const mlx_array arr)
     * }
     */
    public static MemorySegment _mlx_array_is_row_contiguous$address() {
        return _mlx_array_is_row_contiguous.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _mlx_array_is_row_contiguous(bool *res, const mlx_array arr)
     * }
     */
    public static int _mlx_array_is_row_contiguous(MemorySegment res, MemorySegment arr) {
        var mh$ = _mlx_array_is_row_contiguous.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mlx_array_is_row_contiguous", res, arr);
            }
            return (int)mh$.invokeExact(res, arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mlx_array_is_col_contiguous {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mlx_array_is_col_contiguous");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _mlx_array_is_col_contiguous(bool *res, const mlx_array arr)
     * }
     */
    public static FunctionDescriptor _mlx_array_is_col_contiguous$descriptor() {
        return _mlx_array_is_col_contiguous.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _mlx_array_is_col_contiguous(bool *res, const mlx_array arr)
     * }
     */
    public static MethodHandle _mlx_array_is_col_contiguous$handle() {
        return _mlx_array_is_col_contiguous.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _mlx_array_is_col_contiguous(bool *res, const mlx_array arr)
     * }
     */
    public static MemorySegment _mlx_array_is_col_contiguous$address() {
        return _mlx_array_is_col_contiguous.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _mlx_array_is_col_contiguous(bool *res, const mlx_array arr)
     * }
     */
    public static int _mlx_array_is_col_contiguous(MemorySegment res, MemorySegment arr) {
        var mh$ = _mlx_array_is_col_contiguous.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mlx_array_is_col_contiguous", res, arr);
            }
            return (int)mh$.invokeExact(res, arr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_map_string_to_array_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_map_string_to_array_.layout()    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_map_string_to_array_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_map_string_to_array mlx_map_string_to_array_new(void)
     * }
     */
    public static FunctionDescriptor mlx_map_string_to_array_new$descriptor() {
        return mlx_map_string_to_array_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_map_string_to_array mlx_map_string_to_array_new(void)
     * }
     */
    public static MethodHandle mlx_map_string_to_array_new$handle() {
        return mlx_map_string_to_array_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_map_string_to_array mlx_map_string_to_array_new(void)
     * }
     */
    public static MemorySegment mlx_map_string_to_array_new$address() {
        return mlx_map_string_to_array_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_map_string_to_array mlx_map_string_to_array_new(void)
     * }
     */
    public static MemorySegment mlx_map_string_to_array_new(SegmentAllocator allocator) {
        var mh$ = mlx_map_string_to_array_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_map_string_to_array_new", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_map_string_to_array_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_map_string_to_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_map_string_to_array_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_map_string_to_array_set(mlx_map_string_to_array *map, const mlx_map_string_to_array src)
     * }
     */
    public static FunctionDescriptor mlx_map_string_to_array_set$descriptor() {
        return mlx_map_string_to_array_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_map_string_to_array_set(mlx_map_string_to_array *map, const mlx_map_string_to_array src)
     * }
     */
    public static MethodHandle mlx_map_string_to_array_set$handle() {
        return mlx_map_string_to_array_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_map_string_to_array_set(mlx_map_string_to_array *map, const mlx_map_string_to_array src)
     * }
     */
    public static MemorySegment mlx_map_string_to_array_set$address() {
        return mlx_map_string_to_array_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_map_string_to_array_set(mlx_map_string_to_array *map, const mlx_map_string_to_array src)
     * }
     */
    public static int mlx_map_string_to_array_set(MemorySegment map, MemorySegment src) {
        var mh$ = mlx_map_string_to_array_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_map_string_to_array_set", map, src);
            }
            return (int)mh$.invokeExact(map, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_map_string_to_array_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_map_string_to_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_map_string_to_array_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_map_string_to_array_free(mlx_map_string_to_array map)
     * }
     */
    public static FunctionDescriptor mlx_map_string_to_array_free$descriptor() {
        return mlx_map_string_to_array_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_map_string_to_array_free(mlx_map_string_to_array map)
     * }
     */
    public static MethodHandle mlx_map_string_to_array_free$handle() {
        return mlx_map_string_to_array_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_map_string_to_array_free(mlx_map_string_to_array map)
     * }
     */
    public static MemorySegment mlx_map_string_to_array_free$address() {
        return mlx_map_string_to_array_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_map_string_to_array_free(mlx_map_string_to_array map)
     * }
     */
    public static int mlx_map_string_to_array_free(MemorySegment map) {
        var mh$ = mlx_map_string_to_array_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_map_string_to_array_free", map);
            }
            return (int)mh$.invokeExact(map);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_map_string_to_array_insert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_map_string_to_array_.layout(),
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_map_string_to_array_insert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_map_string_to_array_insert(mlx_map_string_to_array map, const char *key, const mlx_array value)
     * }
     */
    public static FunctionDescriptor mlx_map_string_to_array_insert$descriptor() {
        return mlx_map_string_to_array_insert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_map_string_to_array_insert(mlx_map_string_to_array map, const char *key, const mlx_array value)
     * }
     */
    public static MethodHandle mlx_map_string_to_array_insert$handle() {
        return mlx_map_string_to_array_insert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_map_string_to_array_insert(mlx_map_string_to_array map, const char *key, const mlx_array value)
     * }
     */
    public static MemorySegment mlx_map_string_to_array_insert$address() {
        return mlx_map_string_to_array_insert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_map_string_to_array_insert(mlx_map_string_to_array map, const char *key, const mlx_array value)
     * }
     */
    public static int mlx_map_string_to_array_insert(MemorySegment map, MemorySegment key, MemorySegment value) {
        var mh$ = mlx_map_string_to_array_insert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_map_string_to_array_insert", map, key, value);
            }
            return (int)mh$.invokeExact(map, key, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_map_string_to_array_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_map_string_to_array_.layout(),
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_map_string_to_array_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_map_string_to_array_get(mlx_array *value, const mlx_map_string_to_array map, const char *key)
     * }
     */
    public static FunctionDescriptor mlx_map_string_to_array_get$descriptor() {
        return mlx_map_string_to_array_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_map_string_to_array_get(mlx_array *value, const mlx_map_string_to_array map, const char *key)
     * }
     */
    public static MethodHandle mlx_map_string_to_array_get$handle() {
        return mlx_map_string_to_array_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_map_string_to_array_get(mlx_array *value, const mlx_map_string_to_array map, const char *key)
     * }
     */
    public static MemorySegment mlx_map_string_to_array_get$address() {
        return mlx_map_string_to_array_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_map_string_to_array_get(mlx_array *value, const mlx_map_string_to_array map, const char *key)
     * }
     */
    public static int mlx_map_string_to_array_get(MemorySegment value, MemorySegment map, MemorySegment key) {
        var mh$ = mlx_map_string_to_array_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_map_string_to_array_get", value, map, key);
            }
            return (int)mh$.invokeExact(value, map, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_map_string_to_array_iterator_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_map_string_to_array_iterator_.layout(),
            mlx_map_string_to_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_map_string_to_array_iterator_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_map_string_to_array_iterator mlx_map_string_to_array_iterator_new(mlx_map_string_to_array map)
     * }
     */
    public static FunctionDescriptor mlx_map_string_to_array_iterator_new$descriptor() {
        return mlx_map_string_to_array_iterator_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_map_string_to_array_iterator mlx_map_string_to_array_iterator_new(mlx_map_string_to_array map)
     * }
     */
    public static MethodHandle mlx_map_string_to_array_iterator_new$handle() {
        return mlx_map_string_to_array_iterator_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_map_string_to_array_iterator mlx_map_string_to_array_iterator_new(mlx_map_string_to_array map)
     * }
     */
    public static MemorySegment mlx_map_string_to_array_iterator_new$address() {
        return mlx_map_string_to_array_iterator_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_map_string_to_array_iterator mlx_map_string_to_array_iterator_new(mlx_map_string_to_array map)
     * }
     */
    public static MemorySegment mlx_map_string_to_array_iterator_new(SegmentAllocator allocator, MemorySegment map) {
        var mh$ = mlx_map_string_to_array_iterator_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_map_string_to_array_iterator_new", allocator, map);
            }
            return (MemorySegment)mh$.invokeExact(allocator, map);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_map_string_to_array_iterator_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_map_string_to_array_iterator_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_map_string_to_array_iterator_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_map_string_to_array_iterator_free(mlx_map_string_to_array_iterator it)
     * }
     */
    public static FunctionDescriptor mlx_map_string_to_array_iterator_free$descriptor() {
        return mlx_map_string_to_array_iterator_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_map_string_to_array_iterator_free(mlx_map_string_to_array_iterator it)
     * }
     */
    public static MethodHandle mlx_map_string_to_array_iterator_free$handle() {
        return mlx_map_string_to_array_iterator_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_map_string_to_array_iterator_free(mlx_map_string_to_array_iterator it)
     * }
     */
    public static MemorySegment mlx_map_string_to_array_iterator_free$address() {
        return mlx_map_string_to_array_iterator_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_map_string_to_array_iterator_free(mlx_map_string_to_array_iterator it)
     * }
     */
    public static int mlx_map_string_to_array_iterator_free(MemorySegment it) {
        var mh$ = mlx_map_string_to_array_iterator_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_map_string_to_array_iterator_free", it);
            }
            return (int)mh$.invokeExact(it);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_map_string_to_array_iterator_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_map_string_to_array_iterator_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_map_string_to_array_iterator_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_map_string_to_array_iterator_next(const char **key, mlx_array *value, mlx_map_string_to_array_iterator it)
     * }
     */
    public static FunctionDescriptor mlx_map_string_to_array_iterator_next$descriptor() {
        return mlx_map_string_to_array_iterator_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_map_string_to_array_iterator_next(const char **key, mlx_array *value, mlx_map_string_to_array_iterator it)
     * }
     */
    public static MethodHandle mlx_map_string_to_array_iterator_next$handle() {
        return mlx_map_string_to_array_iterator_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_map_string_to_array_iterator_next(const char **key, mlx_array *value, mlx_map_string_to_array_iterator it)
     * }
     */
    public static MemorySegment mlx_map_string_to_array_iterator_next$address() {
        return mlx_map_string_to_array_iterator_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_map_string_to_array_iterator_next(const char **key, mlx_array *value, mlx_map_string_to_array_iterator it)
     * }
     */
    public static int mlx_map_string_to_array_iterator_next(MemorySegment key, MemorySegment value, MemorySegment it) {
        var mh$ = mlx_map_string_to_array_iterator_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_map_string_to_array_iterator_next", key, value, it);
            }
            return (int)mh$.invokeExact(key, value, it);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_map_string_to_string_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_map_string_to_string_.layout()    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_map_string_to_string_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_map_string_to_string mlx_map_string_to_string_new(void)
     * }
     */
    public static FunctionDescriptor mlx_map_string_to_string_new$descriptor() {
        return mlx_map_string_to_string_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_map_string_to_string mlx_map_string_to_string_new(void)
     * }
     */
    public static MethodHandle mlx_map_string_to_string_new$handle() {
        return mlx_map_string_to_string_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_map_string_to_string mlx_map_string_to_string_new(void)
     * }
     */
    public static MemorySegment mlx_map_string_to_string_new$address() {
        return mlx_map_string_to_string_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_map_string_to_string mlx_map_string_to_string_new(void)
     * }
     */
    public static MemorySegment mlx_map_string_to_string_new(SegmentAllocator allocator) {
        var mh$ = mlx_map_string_to_string_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_map_string_to_string_new", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_map_string_to_string_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_map_string_to_string_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_map_string_to_string_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_map_string_to_string_set(mlx_map_string_to_string *map, const mlx_map_string_to_string src)
     * }
     */
    public static FunctionDescriptor mlx_map_string_to_string_set$descriptor() {
        return mlx_map_string_to_string_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_map_string_to_string_set(mlx_map_string_to_string *map, const mlx_map_string_to_string src)
     * }
     */
    public static MethodHandle mlx_map_string_to_string_set$handle() {
        return mlx_map_string_to_string_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_map_string_to_string_set(mlx_map_string_to_string *map, const mlx_map_string_to_string src)
     * }
     */
    public static MemorySegment mlx_map_string_to_string_set$address() {
        return mlx_map_string_to_string_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_map_string_to_string_set(mlx_map_string_to_string *map, const mlx_map_string_to_string src)
     * }
     */
    public static int mlx_map_string_to_string_set(MemorySegment map, MemorySegment src) {
        var mh$ = mlx_map_string_to_string_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_map_string_to_string_set", map, src);
            }
            return (int)mh$.invokeExact(map, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_map_string_to_string_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_map_string_to_string_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_map_string_to_string_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_map_string_to_string_free(mlx_map_string_to_string map)
     * }
     */
    public static FunctionDescriptor mlx_map_string_to_string_free$descriptor() {
        return mlx_map_string_to_string_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_map_string_to_string_free(mlx_map_string_to_string map)
     * }
     */
    public static MethodHandle mlx_map_string_to_string_free$handle() {
        return mlx_map_string_to_string_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_map_string_to_string_free(mlx_map_string_to_string map)
     * }
     */
    public static MemorySegment mlx_map_string_to_string_free$address() {
        return mlx_map_string_to_string_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_map_string_to_string_free(mlx_map_string_to_string map)
     * }
     */
    public static int mlx_map_string_to_string_free(MemorySegment map) {
        var mh$ = mlx_map_string_to_string_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_map_string_to_string_free", map);
            }
            return (int)mh$.invokeExact(map);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_map_string_to_string_insert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_map_string_to_string_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_map_string_to_string_insert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_map_string_to_string_insert(mlx_map_string_to_string map, const char *key, const char *value)
     * }
     */
    public static FunctionDescriptor mlx_map_string_to_string_insert$descriptor() {
        return mlx_map_string_to_string_insert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_map_string_to_string_insert(mlx_map_string_to_string map, const char *key, const char *value)
     * }
     */
    public static MethodHandle mlx_map_string_to_string_insert$handle() {
        return mlx_map_string_to_string_insert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_map_string_to_string_insert(mlx_map_string_to_string map, const char *key, const char *value)
     * }
     */
    public static MemorySegment mlx_map_string_to_string_insert$address() {
        return mlx_map_string_to_string_insert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_map_string_to_string_insert(mlx_map_string_to_string map, const char *key, const char *value)
     * }
     */
    public static int mlx_map_string_to_string_insert(MemorySegment map, MemorySegment key, MemorySegment value) {
        var mh$ = mlx_map_string_to_string_insert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_map_string_to_string_insert", map, key, value);
            }
            return (int)mh$.invokeExact(map, key, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_map_string_to_string_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_map_string_to_string_.layout(),
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_map_string_to_string_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_map_string_to_string_get(const char **value, const mlx_map_string_to_string map, const char *key)
     * }
     */
    public static FunctionDescriptor mlx_map_string_to_string_get$descriptor() {
        return mlx_map_string_to_string_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_map_string_to_string_get(const char **value, const mlx_map_string_to_string map, const char *key)
     * }
     */
    public static MethodHandle mlx_map_string_to_string_get$handle() {
        return mlx_map_string_to_string_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_map_string_to_string_get(const char **value, const mlx_map_string_to_string map, const char *key)
     * }
     */
    public static MemorySegment mlx_map_string_to_string_get$address() {
        return mlx_map_string_to_string_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_map_string_to_string_get(const char **value, const mlx_map_string_to_string map, const char *key)
     * }
     */
    public static int mlx_map_string_to_string_get(MemorySegment value, MemorySegment map, MemorySegment key) {
        var mh$ = mlx_map_string_to_string_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_map_string_to_string_get", value, map, key);
            }
            return (int)mh$.invokeExact(value, map, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_map_string_to_string_iterator_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_map_string_to_string_iterator_.layout(),
            mlx_map_string_to_string_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_map_string_to_string_iterator_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_map_string_to_string_iterator mlx_map_string_to_string_iterator_new(mlx_map_string_to_string map)
     * }
     */
    public static FunctionDescriptor mlx_map_string_to_string_iterator_new$descriptor() {
        return mlx_map_string_to_string_iterator_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_map_string_to_string_iterator mlx_map_string_to_string_iterator_new(mlx_map_string_to_string map)
     * }
     */
    public static MethodHandle mlx_map_string_to_string_iterator_new$handle() {
        return mlx_map_string_to_string_iterator_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_map_string_to_string_iterator mlx_map_string_to_string_iterator_new(mlx_map_string_to_string map)
     * }
     */
    public static MemorySegment mlx_map_string_to_string_iterator_new$address() {
        return mlx_map_string_to_string_iterator_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_map_string_to_string_iterator mlx_map_string_to_string_iterator_new(mlx_map_string_to_string map)
     * }
     */
    public static MemorySegment mlx_map_string_to_string_iterator_new(SegmentAllocator allocator, MemorySegment map) {
        var mh$ = mlx_map_string_to_string_iterator_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_map_string_to_string_iterator_new", allocator, map);
            }
            return (MemorySegment)mh$.invokeExact(allocator, map);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_map_string_to_string_iterator_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_map_string_to_string_iterator_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_map_string_to_string_iterator_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_map_string_to_string_iterator_free(mlx_map_string_to_string_iterator it)
     * }
     */
    public static FunctionDescriptor mlx_map_string_to_string_iterator_free$descriptor() {
        return mlx_map_string_to_string_iterator_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_map_string_to_string_iterator_free(mlx_map_string_to_string_iterator it)
     * }
     */
    public static MethodHandle mlx_map_string_to_string_iterator_free$handle() {
        return mlx_map_string_to_string_iterator_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_map_string_to_string_iterator_free(mlx_map_string_to_string_iterator it)
     * }
     */
    public static MemorySegment mlx_map_string_to_string_iterator_free$address() {
        return mlx_map_string_to_string_iterator_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_map_string_to_string_iterator_free(mlx_map_string_to_string_iterator it)
     * }
     */
    public static int mlx_map_string_to_string_iterator_free(MemorySegment it) {
        var mh$ = mlx_map_string_to_string_iterator_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_map_string_to_string_iterator_free", it);
            }
            return (int)mh$.invokeExact(it);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_map_string_to_string_iterator_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_map_string_to_string_iterator_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_map_string_to_string_iterator_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_map_string_to_string_iterator_next(const char **key, const char **value, mlx_map_string_to_string_iterator it)
     * }
     */
    public static FunctionDescriptor mlx_map_string_to_string_iterator_next$descriptor() {
        return mlx_map_string_to_string_iterator_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_map_string_to_string_iterator_next(const char **key, const char **value, mlx_map_string_to_string_iterator it)
     * }
     */
    public static MethodHandle mlx_map_string_to_string_iterator_next$handle() {
        return mlx_map_string_to_string_iterator_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_map_string_to_string_iterator_next(const char **key, const char **value, mlx_map_string_to_string_iterator it)
     * }
     */
    public static MemorySegment mlx_map_string_to_string_iterator_next$address() {
        return mlx_map_string_to_string_iterator_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_map_string_to_string_iterator_next(const char **key, const char **value, mlx_map_string_to_string_iterator it)
     * }
     */
    public static int mlx_map_string_to_string_iterator_next(MemorySegment key, MemorySegment value, MemorySegment it) {
        var mh$ = mlx_map_string_to_string_iterator_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_map_string_to_string_iterator_next", key, value, it);
            }
            return (int)mh$.invokeExact(key, value, it);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int MLX_CPU = (int)0L;
    /**
     * {@snippet lang=c :
     * enum mlx_device_type_.MLX_CPU = 0
     * }
     */
    public static int MLX_CPU() {
        return MLX_CPU;
    }
    private static final int MLX_GPU = (int)1L;
    /**
     * {@snippet lang=c :
     * enum mlx_device_type_.MLX_GPU = 1
     * }
     */
    public static int MLX_GPU() {
        return MLX_GPU;
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * mlx_device mlx_device_new()
     * }
     */
    public static class mlx_device_new {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_device_.layout()        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_device_new");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private mlx_device_new(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * mlx_device mlx_device_new()
         * }
         */
        public static mlx_device_new makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new mlx_device_new(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("mlx_device_new", allocator, x0);
                }
                return (MemorySegment) spreader.invokeExact(allocator, x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class mlx_device_new_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_device_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_device_new_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_device mlx_device_new_type(mlx_device_type type, int index)
     * }
     */
    public static FunctionDescriptor mlx_device_new_type$descriptor() {
        return mlx_device_new_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_device mlx_device_new_type(mlx_device_type type, int index)
     * }
     */
    public static MethodHandle mlx_device_new_type$handle() {
        return mlx_device_new_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_device mlx_device_new_type(mlx_device_type type, int index)
     * }
     */
    public static MemorySegment mlx_device_new_type$address() {
        return mlx_device_new_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_device mlx_device_new_type(mlx_device_type type, int index)
     * }
     */
    public static MemorySegment mlx_device_new_type(SegmentAllocator allocator, int type, int index) {
        var mh$ = mlx_device_new_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_device_new_type", allocator, type, index);
            }
            return (MemorySegment)mh$.invokeExact(allocator, type, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_device_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_device_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_device_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_device_free(mlx_device dev)
     * }
     */
    public static FunctionDescriptor mlx_device_free$descriptor() {
        return mlx_device_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_device_free(mlx_device dev)
     * }
     */
    public static MethodHandle mlx_device_free$handle() {
        return mlx_device_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_device_free(mlx_device dev)
     * }
     */
    public static MemorySegment mlx_device_free$address() {
        return mlx_device_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_device_free(mlx_device dev)
     * }
     */
    public static int mlx_device_free(MemorySegment dev) {
        var mh$ = mlx_device_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_device_free", dev);
            }
            return (int)mh$.invokeExact(dev);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_device_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_device_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_device_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_device_set(mlx_device *dev, const mlx_device src)
     * }
     */
    public static FunctionDescriptor mlx_device_set$descriptor() {
        return mlx_device_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_device_set(mlx_device *dev, const mlx_device src)
     * }
     */
    public static MethodHandle mlx_device_set$handle() {
        return mlx_device_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_device_set(mlx_device *dev, const mlx_device src)
     * }
     */
    public static MemorySegment mlx_device_set$address() {
        return mlx_device_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_device_set(mlx_device *dev, const mlx_device src)
     * }
     */
    public static int mlx_device_set(MemorySegment dev, MemorySegment src) {
        var mh$ = mlx_device_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_device_set", dev, src);
            }
            return (int)mh$.invokeExact(dev, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_device_tostring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_device_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_device_tostring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_device_tostring(mlx_string *str, mlx_device dev)
     * }
     */
    public static FunctionDescriptor mlx_device_tostring$descriptor() {
        return mlx_device_tostring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_device_tostring(mlx_string *str, mlx_device dev)
     * }
     */
    public static MethodHandle mlx_device_tostring$handle() {
        return mlx_device_tostring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_device_tostring(mlx_string *str, mlx_device dev)
     * }
     */
    public static MemorySegment mlx_device_tostring$address() {
        return mlx_device_tostring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_device_tostring(mlx_string *str, mlx_device dev)
     * }
     */
    public static int mlx_device_tostring(MemorySegment str, MemorySegment dev) {
        var mh$ = mlx_device_tostring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_device_tostring", str, dev);
            }
            return (int)mh$.invokeExact(str, dev);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_device_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_BOOL,
            mlx_device_.layout(),
            mlx_device_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_device_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool mlx_device_equal(mlx_device lhs, mlx_device rhs)
     * }
     */
    public static FunctionDescriptor mlx_device_equal$descriptor() {
        return mlx_device_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool mlx_device_equal(mlx_device lhs, mlx_device rhs)
     * }
     */
    public static MethodHandle mlx_device_equal$handle() {
        return mlx_device_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool mlx_device_equal(mlx_device lhs, mlx_device rhs)
     * }
     */
    public static MemorySegment mlx_device_equal$address() {
        return mlx_device_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool mlx_device_equal(mlx_device lhs, mlx_device rhs)
     * }
     */
    public static boolean mlx_device_equal(MemorySegment lhs, MemorySegment rhs) {
        var mh$ = mlx_device_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_device_equal", lhs, rhs);
            }
            return (boolean)mh$.invokeExact(lhs, rhs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_device_get_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_device_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_device_get_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_device_get_index(int *index, mlx_device dev)
     * }
     */
    public static FunctionDescriptor mlx_device_get_index$descriptor() {
        return mlx_device_get_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_device_get_index(int *index, mlx_device dev)
     * }
     */
    public static MethodHandle mlx_device_get_index$handle() {
        return mlx_device_get_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_device_get_index(int *index, mlx_device dev)
     * }
     */
    public static MemorySegment mlx_device_get_index$address() {
        return mlx_device_get_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_device_get_index(int *index, mlx_device dev)
     * }
     */
    public static int mlx_device_get_index(MemorySegment index, MemorySegment dev) {
        var mh$ = mlx_device_get_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_device_get_index", index, dev);
            }
            return (int)mh$.invokeExact(index, dev);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_device_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_device_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_device_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_device_get_type(mlx_device_type *type, mlx_device dev)
     * }
     */
    public static FunctionDescriptor mlx_device_get_type$descriptor() {
        return mlx_device_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_device_get_type(mlx_device_type *type, mlx_device dev)
     * }
     */
    public static MethodHandle mlx_device_get_type$handle() {
        return mlx_device_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_device_get_type(mlx_device_type *type, mlx_device dev)
     * }
     */
    public static MemorySegment mlx_device_get_type$address() {
        return mlx_device_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_device_get_type(mlx_device_type *type, mlx_device dev)
     * }
     */
    public static int mlx_device_get_type(MemorySegment type, MemorySegment dev) {
        var mh$ = mlx_device_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_device_get_type", type, dev);
            }
            return (int)mh$.invokeExact(type, dev);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_get_default_device {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_get_default_device");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_get_default_device(mlx_device *dev)
     * }
     */
    public static FunctionDescriptor mlx_get_default_device$descriptor() {
        return mlx_get_default_device.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_get_default_device(mlx_device *dev)
     * }
     */
    public static MethodHandle mlx_get_default_device$handle() {
        return mlx_get_default_device.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_get_default_device(mlx_device *dev)
     * }
     */
    public static MemorySegment mlx_get_default_device$address() {
        return mlx_get_default_device.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_get_default_device(mlx_device *dev)
     * }
     */
    public static int mlx_get_default_device(MemorySegment dev) {
        var mh$ = mlx_get_default_device.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_get_default_device", dev);
            }
            return (int)mh$.invokeExact(dev);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_set_default_device {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_device_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_set_default_device");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_set_default_device(mlx_device dev)
     * }
     */
    public static FunctionDescriptor mlx_set_default_device$descriptor() {
        return mlx_set_default_device.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_set_default_device(mlx_device dev)
     * }
     */
    public static MethodHandle mlx_set_default_device$handle() {
        return mlx_set_default_device.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_set_default_device(mlx_device dev)
     * }
     */
    public static MemorySegment mlx_set_default_device$address() {
        return mlx_set_default_device.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_set_default_device(mlx_device dev)
     * }
     */
    public static int mlx_set_default_device(MemorySegment dev) {
        var mh$ = mlx_set_default_device.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_set_default_device", dev);
            }
            return (int)mh$.invokeExact(dev);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * mlx_stream mlx_stream_new()
     * }
     */
    public static class mlx_stream_new {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_stream_.layout()        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_stream_new");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private mlx_stream_new(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * mlx_stream mlx_stream_new()
         * }
         */
        public static mlx_stream_new makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new mlx_stream_new(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("mlx_stream_new", allocator, x0);
                }
                return (MemorySegment) spreader.invokeExact(allocator, x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class mlx_stream_new_device {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_stream_.layout(),
            mlx_device_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_stream_new_device");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_stream mlx_stream_new_device(mlx_device dev)
     * }
     */
    public static FunctionDescriptor mlx_stream_new_device$descriptor() {
        return mlx_stream_new_device.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_stream mlx_stream_new_device(mlx_device dev)
     * }
     */
    public static MethodHandle mlx_stream_new_device$handle() {
        return mlx_stream_new_device.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_stream mlx_stream_new_device(mlx_device dev)
     * }
     */
    public static MemorySegment mlx_stream_new_device$address() {
        return mlx_stream_new_device.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_stream mlx_stream_new_device(mlx_device dev)
     * }
     */
    public static MemorySegment mlx_stream_new_device(SegmentAllocator allocator, MemorySegment dev) {
        var mh$ = mlx_stream_new_device.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_stream_new_device", allocator, dev);
            }
            return (MemorySegment)mh$.invokeExact(allocator, dev);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_stream_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_stream_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_stream_set(mlx_stream *stream, const mlx_stream src)
     * }
     */
    public static FunctionDescriptor mlx_stream_set$descriptor() {
        return mlx_stream_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_stream_set(mlx_stream *stream, const mlx_stream src)
     * }
     */
    public static MethodHandle mlx_stream_set$handle() {
        return mlx_stream_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_stream_set(mlx_stream *stream, const mlx_stream src)
     * }
     */
    public static MemorySegment mlx_stream_set$address() {
        return mlx_stream_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_stream_set(mlx_stream *stream, const mlx_stream src)
     * }
     */
    public static int mlx_stream_set(MemorySegment stream, MemorySegment src) {
        var mh$ = mlx_stream_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_stream_set", stream, src);
            }
            return (int)mh$.invokeExact(stream, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_stream_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_stream_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_stream_free(mlx_stream stream)
     * }
     */
    public static FunctionDescriptor mlx_stream_free$descriptor() {
        return mlx_stream_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_stream_free(mlx_stream stream)
     * }
     */
    public static MethodHandle mlx_stream_free$handle() {
        return mlx_stream_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_stream_free(mlx_stream stream)
     * }
     */
    public static MemorySegment mlx_stream_free$address() {
        return mlx_stream_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_stream_free(mlx_stream stream)
     * }
     */
    public static int mlx_stream_free(MemorySegment stream) {
        var mh$ = mlx_stream_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_stream_free", stream);
            }
            return (int)mh$.invokeExact(stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_stream_tostring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_stream_tostring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_stream_tostring(mlx_string *str, mlx_stream stream)
     * }
     */
    public static FunctionDescriptor mlx_stream_tostring$descriptor() {
        return mlx_stream_tostring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_stream_tostring(mlx_string *str, mlx_stream stream)
     * }
     */
    public static MethodHandle mlx_stream_tostring$handle() {
        return mlx_stream_tostring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_stream_tostring(mlx_string *str, mlx_stream stream)
     * }
     */
    public static MemorySegment mlx_stream_tostring$address() {
        return mlx_stream_tostring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_stream_tostring(mlx_string *str, mlx_stream stream)
     * }
     */
    public static int mlx_stream_tostring(MemorySegment str, MemorySegment stream) {
        var mh$ = mlx_stream_tostring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_stream_tostring", str, stream);
            }
            return (int)mh$.invokeExact(str, stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_stream_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_BOOL,
            mlx_stream_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_stream_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool mlx_stream_equal(mlx_stream lhs, mlx_stream rhs)
     * }
     */
    public static FunctionDescriptor mlx_stream_equal$descriptor() {
        return mlx_stream_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool mlx_stream_equal(mlx_stream lhs, mlx_stream rhs)
     * }
     */
    public static MethodHandle mlx_stream_equal$handle() {
        return mlx_stream_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool mlx_stream_equal(mlx_stream lhs, mlx_stream rhs)
     * }
     */
    public static MemorySegment mlx_stream_equal$address() {
        return mlx_stream_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool mlx_stream_equal(mlx_stream lhs, mlx_stream rhs)
     * }
     */
    public static boolean mlx_stream_equal(MemorySegment lhs, MemorySegment rhs) {
        var mh$ = mlx_stream_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_stream_equal", lhs, rhs);
            }
            return (boolean)mh$.invokeExact(lhs, rhs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_stream_get_device {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_stream_get_device");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_stream_get_device(mlx_device *dev, mlx_stream stream)
     * }
     */
    public static FunctionDescriptor mlx_stream_get_device$descriptor() {
        return mlx_stream_get_device.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_stream_get_device(mlx_device *dev, mlx_stream stream)
     * }
     */
    public static MethodHandle mlx_stream_get_device$handle() {
        return mlx_stream_get_device.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_stream_get_device(mlx_device *dev, mlx_stream stream)
     * }
     */
    public static MemorySegment mlx_stream_get_device$address() {
        return mlx_stream_get_device.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_stream_get_device(mlx_device *dev, mlx_stream stream)
     * }
     */
    public static int mlx_stream_get_device(MemorySegment dev, MemorySegment stream) {
        var mh$ = mlx_stream_get_device.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_stream_get_device", dev, stream);
            }
            return (int)mh$.invokeExact(dev, stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_stream_get_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_stream_get_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_stream_get_index(int *index, mlx_stream stream)
     * }
     */
    public static FunctionDescriptor mlx_stream_get_index$descriptor() {
        return mlx_stream_get_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_stream_get_index(int *index, mlx_stream stream)
     * }
     */
    public static MethodHandle mlx_stream_get_index$handle() {
        return mlx_stream_get_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_stream_get_index(int *index, mlx_stream stream)
     * }
     */
    public static MemorySegment mlx_stream_get_index$address() {
        return mlx_stream_get_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_stream_get_index(int *index, mlx_stream stream)
     * }
     */
    public static int mlx_stream_get_index(MemorySegment index, MemorySegment stream) {
        var mh$ = mlx_stream_get_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_stream_get_index", index, stream);
            }
            return (int)mh$.invokeExact(index, stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_synchronize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_synchronize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_synchronize(mlx_stream stream)
     * }
     */
    public static FunctionDescriptor mlx_synchronize$descriptor() {
        return mlx_synchronize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_synchronize(mlx_stream stream)
     * }
     */
    public static MethodHandle mlx_synchronize$handle() {
        return mlx_synchronize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_synchronize(mlx_stream stream)
     * }
     */
    public static MemorySegment mlx_synchronize$address() {
        return mlx_synchronize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_synchronize(mlx_stream stream)
     * }
     */
    public static int mlx_synchronize(MemorySegment stream) {
        var mh$ = mlx_synchronize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_synchronize", stream);
            }
            return (int)mh$.invokeExact(stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_get_default_stream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_device_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_get_default_stream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_get_default_stream(mlx_stream *stream, mlx_device dev)
     * }
     */
    public static FunctionDescriptor mlx_get_default_stream$descriptor() {
        return mlx_get_default_stream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_get_default_stream(mlx_stream *stream, mlx_device dev)
     * }
     */
    public static MethodHandle mlx_get_default_stream$handle() {
        return mlx_get_default_stream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_get_default_stream(mlx_stream *stream, mlx_device dev)
     * }
     */
    public static MemorySegment mlx_get_default_stream$address() {
        return mlx_get_default_stream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_get_default_stream(mlx_stream *stream, mlx_device dev)
     * }
     */
    public static int mlx_get_default_stream(MemorySegment stream, MemorySegment dev) {
        var mh$ = mlx_get_default_stream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_get_default_stream", stream, dev);
            }
            return (int)mh$.invokeExact(stream, dev);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_set_default_stream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_set_default_stream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_set_default_stream(mlx_stream stream)
     * }
     */
    public static FunctionDescriptor mlx_set_default_stream$descriptor() {
        return mlx_set_default_stream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_set_default_stream(mlx_stream stream)
     * }
     */
    public static MethodHandle mlx_set_default_stream$handle() {
        return mlx_set_default_stream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_set_default_stream(mlx_stream stream)
     * }
     */
    public static MemorySegment mlx_set_default_stream$address() {
        return mlx_set_default_stream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_set_default_stream(mlx_stream stream)
     * }
     */
    public static int mlx_set_default_stream(MemorySegment stream) {
        var mh$ = mlx_set_default_stream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_set_default_stream", stream);
            }
            return (int)mh$.invokeExact(stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * mlx_stream mlx_default_cpu_stream_new()
     * }
     */
    public static class mlx_default_cpu_stream_new {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_stream_.layout()        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_default_cpu_stream_new");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private mlx_default_cpu_stream_new(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * mlx_stream mlx_default_cpu_stream_new()
         * }
         */
        public static mlx_default_cpu_stream_new makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new mlx_default_cpu_stream_new(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("mlx_default_cpu_stream_new", allocator, x0);
                }
                return (MemorySegment) spreader.invokeExact(allocator, x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * mlx_stream mlx_default_gpu_stream_new()
     * }
     */
    public static class mlx_default_gpu_stream_new {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_stream_.layout()        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_default_gpu_stream_new");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private mlx_default_gpu_stream_new(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * mlx_stream mlx_default_gpu_stream_new()
         * }
         */
        public static mlx_default_gpu_stream_new makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new mlx_default_gpu_stream_new(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("mlx_default_gpu_stream_new", allocator, x0);
                }
                return (MemorySegment) spreader.invokeExact(allocator, x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * mlx_vector_array mlx_vector_array_new()
     * }
     */
    public static class mlx_vector_array_new {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_vector_array_.layout()        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_array_new");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private mlx_vector_array_new(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * mlx_vector_array mlx_vector_array_new()
         * }
         */
        public static mlx_vector_array_new makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new mlx_vector_array_new(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("mlx_vector_array_new", allocator, x0);
                }
                return (MemorySegment) spreader.invokeExact(allocator, x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class mlx_vector_array_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_vector_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_array_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_array_set(mlx_vector_array *vec, const mlx_vector_array src)
     * }
     */
    public static FunctionDescriptor mlx_vector_array_set$descriptor() {
        return mlx_vector_array_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_array_set(mlx_vector_array *vec, const mlx_vector_array src)
     * }
     */
    public static MethodHandle mlx_vector_array_set$handle() {
        return mlx_vector_array_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_array_set(mlx_vector_array *vec, const mlx_vector_array src)
     * }
     */
    public static MemorySegment mlx_vector_array_set$address() {
        return mlx_vector_array_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_array_set(mlx_vector_array *vec, const mlx_vector_array src)
     * }
     */
    public static int mlx_vector_array_set(MemorySegment vec, MemorySegment src) {
        var mh$ = mlx_vector_array_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_array_set", vec, src);
            }
            return (int)mh$.invokeExact(vec, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_array_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_vector_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_array_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_array_free(mlx_vector_array vec)
     * }
     */
    public static FunctionDescriptor mlx_vector_array_free$descriptor() {
        return mlx_vector_array_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_array_free(mlx_vector_array vec)
     * }
     */
    public static MethodHandle mlx_vector_array_free$handle() {
        return mlx_vector_array_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_array_free(mlx_vector_array vec)
     * }
     */
    public static MemorySegment mlx_vector_array_free$address() {
        return mlx_vector_array_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_array_free(mlx_vector_array vec)
     * }
     */
    public static int mlx_vector_array_free(MemorySegment vec) {
        var mh$ = mlx_vector_array_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_array_free", vec);
            }
            return (int)mh$.invokeExact(vec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_array_new_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_vector_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_array_new_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_vector_array mlx_vector_array_new_data(const mlx_array *data, size_t size)
     * }
     */
    public static FunctionDescriptor mlx_vector_array_new_data$descriptor() {
        return mlx_vector_array_new_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_vector_array mlx_vector_array_new_data(const mlx_array *data, size_t size)
     * }
     */
    public static MethodHandle mlx_vector_array_new_data$handle() {
        return mlx_vector_array_new_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_vector_array mlx_vector_array_new_data(const mlx_array *data, size_t size)
     * }
     */
    public static MemorySegment mlx_vector_array_new_data$address() {
        return mlx_vector_array_new_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_vector_array mlx_vector_array_new_data(const mlx_array *data, size_t size)
     * }
     */
    public static MemorySegment mlx_vector_array_new_data(SegmentAllocator allocator, MemorySegment data, long size) {
        var mh$ = mlx_vector_array_new_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_array_new_data", allocator, data, size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, data, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_array_new_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_vector_array_.layout(),
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_array_new_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_vector_array mlx_vector_array_new_value(const mlx_array val)
     * }
     */
    public static FunctionDescriptor mlx_vector_array_new_value$descriptor() {
        return mlx_vector_array_new_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_vector_array mlx_vector_array_new_value(const mlx_array val)
     * }
     */
    public static MethodHandle mlx_vector_array_new_value$handle() {
        return mlx_vector_array_new_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_vector_array mlx_vector_array_new_value(const mlx_array val)
     * }
     */
    public static MemorySegment mlx_vector_array_new_value$address() {
        return mlx_vector_array_new_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_vector_array mlx_vector_array_new_value(const mlx_array val)
     * }
     */
    public static MemorySegment mlx_vector_array_new_value(SegmentAllocator allocator, MemorySegment val) {
        var mh$ = mlx_vector_array_new_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_array_new_value", allocator, val);
            }
            return (MemorySegment)mh$.invokeExact(allocator, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_array_set_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_array_set_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_array_set_data(mlx_vector_array *vec, const mlx_array *data, size_t size)
     * }
     */
    public static FunctionDescriptor mlx_vector_array_set_data$descriptor() {
        return mlx_vector_array_set_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_array_set_data(mlx_vector_array *vec, const mlx_array *data, size_t size)
     * }
     */
    public static MethodHandle mlx_vector_array_set_data$handle() {
        return mlx_vector_array_set_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_array_set_data(mlx_vector_array *vec, const mlx_array *data, size_t size)
     * }
     */
    public static MemorySegment mlx_vector_array_set_data$address() {
        return mlx_vector_array_set_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_array_set_data(mlx_vector_array *vec, const mlx_array *data, size_t size)
     * }
     */
    public static int mlx_vector_array_set_data(MemorySegment vec, MemorySegment data, long size) {
        var mh$ = mlx_vector_array_set_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_array_set_data", vec, data, size);
            }
            return (int)mh$.invokeExact(vec, data, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_array_set_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_array_set_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_array_set_value(mlx_vector_array *vec, const mlx_array val)
     * }
     */
    public static FunctionDescriptor mlx_vector_array_set_value$descriptor() {
        return mlx_vector_array_set_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_array_set_value(mlx_vector_array *vec, const mlx_array val)
     * }
     */
    public static MethodHandle mlx_vector_array_set_value$handle() {
        return mlx_vector_array_set_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_array_set_value(mlx_vector_array *vec, const mlx_array val)
     * }
     */
    public static MemorySegment mlx_vector_array_set_value$address() {
        return mlx_vector_array_set_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_array_set_value(mlx_vector_array *vec, const mlx_array val)
     * }
     */
    public static int mlx_vector_array_set_value(MemorySegment vec, MemorySegment val) {
        var mh$ = mlx_vector_array_set_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_array_set_value", vec, val);
            }
            return (int)mh$.invokeExact(vec, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_array_append_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_vector_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_array_append_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_array_append_data(mlx_vector_array vec, const mlx_array *data, size_t size)
     * }
     */
    public static FunctionDescriptor mlx_vector_array_append_data$descriptor() {
        return mlx_vector_array_append_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_array_append_data(mlx_vector_array vec, const mlx_array *data, size_t size)
     * }
     */
    public static MethodHandle mlx_vector_array_append_data$handle() {
        return mlx_vector_array_append_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_array_append_data(mlx_vector_array vec, const mlx_array *data, size_t size)
     * }
     */
    public static MemorySegment mlx_vector_array_append_data$address() {
        return mlx_vector_array_append_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_array_append_data(mlx_vector_array vec, const mlx_array *data, size_t size)
     * }
     */
    public static int mlx_vector_array_append_data(MemorySegment vec, MemorySegment data, long size) {
        var mh$ = mlx_vector_array_append_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_array_append_data", vec, data, size);
            }
            return (int)mh$.invokeExact(vec, data, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_array_append_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_vector_array_.layout(),
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_array_append_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_array_append_value(mlx_vector_array vec, const mlx_array val)
     * }
     */
    public static FunctionDescriptor mlx_vector_array_append_value$descriptor() {
        return mlx_vector_array_append_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_array_append_value(mlx_vector_array vec, const mlx_array val)
     * }
     */
    public static MethodHandle mlx_vector_array_append_value$handle() {
        return mlx_vector_array_append_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_array_append_value(mlx_vector_array vec, const mlx_array val)
     * }
     */
    public static MemorySegment mlx_vector_array_append_value$address() {
        return mlx_vector_array_append_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_array_append_value(mlx_vector_array vec, const mlx_array val)
     * }
     */
    public static int mlx_vector_array_append_value(MemorySegment vec, MemorySegment val) {
        var mh$ = mlx_vector_array_append_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_array_append_value", vec, val);
            }
            return (int)mh$.invokeExact(vec, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_array_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG,
            mlx_vector_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_array_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mlx_vector_array_size(mlx_vector_array vec)
     * }
     */
    public static FunctionDescriptor mlx_vector_array_size$descriptor() {
        return mlx_vector_array_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mlx_vector_array_size(mlx_vector_array vec)
     * }
     */
    public static MethodHandle mlx_vector_array_size$handle() {
        return mlx_vector_array_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mlx_vector_array_size(mlx_vector_array vec)
     * }
     */
    public static MemorySegment mlx_vector_array_size$address() {
        return mlx_vector_array_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mlx_vector_array_size(mlx_vector_array vec)
     * }
     */
    public static long mlx_vector_array_size(MemorySegment vec) {
        var mh$ = mlx_vector_array_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_array_size", vec);
            }
            return (long)mh$.invokeExact(vec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_array_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_vector_array_.layout(),
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_array_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_array_get(mlx_array *res, const mlx_vector_array vec, size_t idx)
     * }
     */
    public static FunctionDescriptor mlx_vector_array_get$descriptor() {
        return mlx_vector_array_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_array_get(mlx_array *res, const mlx_vector_array vec, size_t idx)
     * }
     */
    public static MethodHandle mlx_vector_array_get$handle() {
        return mlx_vector_array_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_array_get(mlx_array *res, const mlx_vector_array vec, size_t idx)
     * }
     */
    public static MemorySegment mlx_vector_array_get$address() {
        return mlx_vector_array_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_array_get(mlx_array *res, const mlx_vector_array vec, size_t idx)
     * }
     */
    public static int mlx_vector_array_get(MemorySegment res, MemorySegment vec, long idx) {
        var mh$ = mlx_vector_array_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_array_get", res, vec, idx);
            }
            return (int)mh$.invokeExact(res, vec, idx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * mlx_vector_vector_array mlx_vector_vector_array_new()
     * }
     */
    public static class mlx_vector_vector_array_new {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_vector_vector_array_.layout()        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_vector_array_new");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private mlx_vector_vector_array_new(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * mlx_vector_vector_array mlx_vector_vector_array_new()
         * }
         */
        public static mlx_vector_vector_array_new makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new mlx_vector_vector_array_new(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("mlx_vector_vector_array_new", allocator, x0);
                }
                return (MemorySegment) spreader.invokeExact(allocator, x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class mlx_vector_vector_array_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_vector_vector_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_vector_array_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_vector_array_set(mlx_vector_vector_array *vec, const mlx_vector_vector_array src)
     * }
     */
    public static FunctionDescriptor mlx_vector_vector_array_set$descriptor() {
        return mlx_vector_vector_array_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_vector_array_set(mlx_vector_vector_array *vec, const mlx_vector_vector_array src)
     * }
     */
    public static MethodHandle mlx_vector_vector_array_set$handle() {
        return mlx_vector_vector_array_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_vector_array_set(mlx_vector_vector_array *vec, const mlx_vector_vector_array src)
     * }
     */
    public static MemorySegment mlx_vector_vector_array_set$address() {
        return mlx_vector_vector_array_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_vector_array_set(mlx_vector_vector_array *vec, const mlx_vector_vector_array src)
     * }
     */
    public static int mlx_vector_vector_array_set(MemorySegment vec, MemorySegment src) {
        var mh$ = mlx_vector_vector_array_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_vector_array_set", vec, src);
            }
            return (int)mh$.invokeExact(vec, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

