// Generated by jextract

package mlx;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class mlx_h extends mlx_h_1 {

    mlx_h() {
        // Should not be called directly
    }

    private static class mlx_vector_vector_array_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_vector_vector_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_vector_array_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_vector_array_free(mlx_vector_vector_array vec)
     * }
     */
    public static FunctionDescriptor mlx_vector_vector_array_free$descriptor() {
        return mlx_vector_vector_array_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_vector_array_free(mlx_vector_vector_array vec)
     * }
     */
    public static MethodHandle mlx_vector_vector_array_free$handle() {
        return mlx_vector_vector_array_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_vector_array_free(mlx_vector_vector_array vec)
     * }
     */
    public static MemorySegment mlx_vector_vector_array_free$address() {
        return mlx_vector_vector_array_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_vector_array_free(mlx_vector_vector_array vec)
     * }
     */
    public static int mlx_vector_vector_array_free(MemorySegment vec) {
        var mh$ = mlx_vector_vector_array_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_vector_array_free", vec);
            }
            return (int)mh$.invokeExact(vec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_vector_array_new_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_vector_vector_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_vector_array_new_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_vector_vector_array mlx_vector_vector_array_new_data(const mlx_vector_array *data, size_t size)
     * }
     */
    public static FunctionDescriptor mlx_vector_vector_array_new_data$descriptor() {
        return mlx_vector_vector_array_new_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_vector_vector_array mlx_vector_vector_array_new_data(const mlx_vector_array *data, size_t size)
     * }
     */
    public static MethodHandle mlx_vector_vector_array_new_data$handle() {
        return mlx_vector_vector_array_new_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_vector_vector_array mlx_vector_vector_array_new_data(const mlx_vector_array *data, size_t size)
     * }
     */
    public static MemorySegment mlx_vector_vector_array_new_data$address() {
        return mlx_vector_vector_array_new_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_vector_vector_array mlx_vector_vector_array_new_data(const mlx_vector_array *data, size_t size)
     * }
     */
    public static MemorySegment mlx_vector_vector_array_new_data(SegmentAllocator allocator, MemorySegment data, long size) {
        var mh$ = mlx_vector_vector_array_new_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_vector_array_new_data", allocator, data, size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, data, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_vector_array_new_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_vector_vector_array_.layout(),
            mlx_vector_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_vector_array_new_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_vector_vector_array mlx_vector_vector_array_new_value(const mlx_vector_array val)
     * }
     */
    public static FunctionDescriptor mlx_vector_vector_array_new_value$descriptor() {
        return mlx_vector_vector_array_new_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_vector_vector_array mlx_vector_vector_array_new_value(const mlx_vector_array val)
     * }
     */
    public static MethodHandle mlx_vector_vector_array_new_value$handle() {
        return mlx_vector_vector_array_new_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_vector_vector_array mlx_vector_vector_array_new_value(const mlx_vector_array val)
     * }
     */
    public static MemorySegment mlx_vector_vector_array_new_value$address() {
        return mlx_vector_vector_array_new_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_vector_vector_array mlx_vector_vector_array_new_value(const mlx_vector_array val)
     * }
     */
    public static MemorySegment mlx_vector_vector_array_new_value(SegmentAllocator allocator, MemorySegment val) {
        var mh$ = mlx_vector_vector_array_new_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_vector_array_new_value", allocator, val);
            }
            return (MemorySegment)mh$.invokeExact(allocator, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_vector_array_set_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_vector_array_set_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_vector_array_set_data(mlx_vector_vector_array *vec, const mlx_vector_array *data, size_t size)
     * }
     */
    public static FunctionDescriptor mlx_vector_vector_array_set_data$descriptor() {
        return mlx_vector_vector_array_set_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_vector_array_set_data(mlx_vector_vector_array *vec, const mlx_vector_array *data, size_t size)
     * }
     */
    public static MethodHandle mlx_vector_vector_array_set_data$handle() {
        return mlx_vector_vector_array_set_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_vector_array_set_data(mlx_vector_vector_array *vec, const mlx_vector_array *data, size_t size)
     * }
     */
    public static MemorySegment mlx_vector_vector_array_set_data$address() {
        return mlx_vector_vector_array_set_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_vector_array_set_data(mlx_vector_vector_array *vec, const mlx_vector_array *data, size_t size)
     * }
     */
    public static int mlx_vector_vector_array_set_data(MemorySegment vec, MemorySegment data, long size) {
        var mh$ = mlx_vector_vector_array_set_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_vector_array_set_data", vec, data, size);
            }
            return (int)mh$.invokeExact(vec, data, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_vector_array_set_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_vector_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_vector_array_set_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_vector_array_set_value(mlx_vector_vector_array *vec, const mlx_vector_array val)
     * }
     */
    public static FunctionDescriptor mlx_vector_vector_array_set_value$descriptor() {
        return mlx_vector_vector_array_set_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_vector_array_set_value(mlx_vector_vector_array *vec, const mlx_vector_array val)
     * }
     */
    public static MethodHandle mlx_vector_vector_array_set_value$handle() {
        return mlx_vector_vector_array_set_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_vector_array_set_value(mlx_vector_vector_array *vec, const mlx_vector_array val)
     * }
     */
    public static MemorySegment mlx_vector_vector_array_set_value$address() {
        return mlx_vector_vector_array_set_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_vector_array_set_value(mlx_vector_vector_array *vec, const mlx_vector_array val)
     * }
     */
    public static int mlx_vector_vector_array_set_value(MemorySegment vec, MemorySegment val) {
        var mh$ = mlx_vector_vector_array_set_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_vector_array_set_value", vec, val);
            }
            return (int)mh$.invokeExact(vec, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_vector_array_append_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_vector_vector_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_vector_array_append_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_vector_array_append_data(mlx_vector_vector_array vec, const mlx_vector_array *data, size_t size)
     * }
     */
    public static FunctionDescriptor mlx_vector_vector_array_append_data$descriptor() {
        return mlx_vector_vector_array_append_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_vector_array_append_data(mlx_vector_vector_array vec, const mlx_vector_array *data, size_t size)
     * }
     */
    public static MethodHandle mlx_vector_vector_array_append_data$handle() {
        return mlx_vector_vector_array_append_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_vector_array_append_data(mlx_vector_vector_array vec, const mlx_vector_array *data, size_t size)
     * }
     */
    public static MemorySegment mlx_vector_vector_array_append_data$address() {
        return mlx_vector_vector_array_append_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_vector_array_append_data(mlx_vector_vector_array vec, const mlx_vector_array *data, size_t size)
     * }
     */
    public static int mlx_vector_vector_array_append_data(MemorySegment vec, MemorySegment data, long size) {
        var mh$ = mlx_vector_vector_array_append_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_vector_array_append_data", vec, data, size);
            }
            return (int)mh$.invokeExact(vec, data, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_vector_array_append_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_vector_vector_array_.layout(),
            mlx_vector_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_vector_array_append_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_vector_array_append_value(mlx_vector_vector_array vec, const mlx_vector_array val)
     * }
     */
    public static FunctionDescriptor mlx_vector_vector_array_append_value$descriptor() {
        return mlx_vector_vector_array_append_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_vector_array_append_value(mlx_vector_vector_array vec, const mlx_vector_array val)
     * }
     */
    public static MethodHandle mlx_vector_vector_array_append_value$handle() {
        return mlx_vector_vector_array_append_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_vector_array_append_value(mlx_vector_vector_array vec, const mlx_vector_array val)
     * }
     */
    public static MemorySegment mlx_vector_vector_array_append_value$address() {
        return mlx_vector_vector_array_append_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_vector_array_append_value(mlx_vector_vector_array vec, const mlx_vector_array val)
     * }
     */
    public static int mlx_vector_vector_array_append_value(MemorySegment vec, MemorySegment val) {
        var mh$ = mlx_vector_vector_array_append_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_vector_array_append_value", vec, val);
            }
            return (int)mh$.invokeExact(vec, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_vector_array_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG,
            mlx_vector_vector_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_vector_array_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mlx_vector_vector_array_size(mlx_vector_vector_array vec)
     * }
     */
    public static FunctionDescriptor mlx_vector_vector_array_size$descriptor() {
        return mlx_vector_vector_array_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mlx_vector_vector_array_size(mlx_vector_vector_array vec)
     * }
     */
    public static MethodHandle mlx_vector_vector_array_size$handle() {
        return mlx_vector_vector_array_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mlx_vector_vector_array_size(mlx_vector_vector_array vec)
     * }
     */
    public static MemorySegment mlx_vector_vector_array_size$address() {
        return mlx_vector_vector_array_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mlx_vector_vector_array_size(mlx_vector_vector_array vec)
     * }
     */
    public static long mlx_vector_vector_array_size(MemorySegment vec) {
        var mh$ = mlx_vector_vector_array_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_vector_array_size", vec);
            }
            return (long)mh$.invokeExact(vec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_vector_array_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_vector_vector_array_.layout(),
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_vector_array_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_vector_array_get(mlx_vector_array *res, const mlx_vector_vector_array vec, size_t idx)
     * }
     */
    public static FunctionDescriptor mlx_vector_vector_array_get$descriptor() {
        return mlx_vector_vector_array_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_vector_array_get(mlx_vector_array *res, const mlx_vector_vector_array vec, size_t idx)
     * }
     */
    public static MethodHandle mlx_vector_vector_array_get$handle() {
        return mlx_vector_vector_array_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_vector_array_get(mlx_vector_array *res, const mlx_vector_vector_array vec, size_t idx)
     * }
     */
    public static MemorySegment mlx_vector_vector_array_get$address() {
        return mlx_vector_vector_array_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_vector_array_get(mlx_vector_array *res, const mlx_vector_vector_array vec, size_t idx)
     * }
     */
    public static int mlx_vector_vector_array_get(MemorySegment res, MemorySegment vec, long idx) {
        var mh$ = mlx_vector_vector_array_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_vector_array_get", res, vec, idx);
            }
            return (int)mh$.invokeExact(res, vec, idx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * mlx_vector_int mlx_vector_int_new()
     * }
     */
    public static class mlx_vector_int_new {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_vector_int_.layout()        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_int_new");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private mlx_vector_int_new(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * mlx_vector_int mlx_vector_int_new()
         * }
         */
        public static mlx_vector_int_new makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new mlx_vector_int_new(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("mlx_vector_int_new", allocator, x0);
                }
                return (MemorySegment) spreader.invokeExact(allocator, x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class mlx_vector_int_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_vector_int_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_int_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_int_set(mlx_vector_int *vec, const mlx_vector_int src)
     * }
     */
    public static FunctionDescriptor mlx_vector_int_set$descriptor() {
        return mlx_vector_int_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_int_set(mlx_vector_int *vec, const mlx_vector_int src)
     * }
     */
    public static MethodHandle mlx_vector_int_set$handle() {
        return mlx_vector_int_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_int_set(mlx_vector_int *vec, const mlx_vector_int src)
     * }
     */
    public static MemorySegment mlx_vector_int_set$address() {
        return mlx_vector_int_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_int_set(mlx_vector_int *vec, const mlx_vector_int src)
     * }
     */
    public static int mlx_vector_int_set(MemorySegment vec, MemorySegment src) {
        var mh$ = mlx_vector_int_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_int_set", vec, src);
            }
            return (int)mh$.invokeExact(vec, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_int_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_vector_int_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_int_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_int_free(mlx_vector_int vec)
     * }
     */
    public static FunctionDescriptor mlx_vector_int_free$descriptor() {
        return mlx_vector_int_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_int_free(mlx_vector_int vec)
     * }
     */
    public static MethodHandle mlx_vector_int_free$handle() {
        return mlx_vector_int_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_int_free(mlx_vector_int vec)
     * }
     */
    public static MemorySegment mlx_vector_int_free$address() {
        return mlx_vector_int_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_int_free(mlx_vector_int vec)
     * }
     */
    public static int mlx_vector_int_free(MemorySegment vec) {
        var mh$ = mlx_vector_int_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_int_free", vec);
            }
            return (int)mh$.invokeExact(vec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_int_new_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_vector_int_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_int_new_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_vector_int mlx_vector_int_new_data(int *data, size_t size)
     * }
     */
    public static FunctionDescriptor mlx_vector_int_new_data$descriptor() {
        return mlx_vector_int_new_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_vector_int mlx_vector_int_new_data(int *data, size_t size)
     * }
     */
    public static MethodHandle mlx_vector_int_new_data$handle() {
        return mlx_vector_int_new_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_vector_int mlx_vector_int_new_data(int *data, size_t size)
     * }
     */
    public static MemorySegment mlx_vector_int_new_data$address() {
        return mlx_vector_int_new_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_vector_int mlx_vector_int_new_data(int *data, size_t size)
     * }
     */
    public static MemorySegment mlx_vector_int_new_data(SegmentAllocator allocator, MemorySegment data, long size) {
        var mh$ = mlx_vector_int_new_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_int_new_data", allocator, data, size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, data, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_int_new_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_vector_int_.layout(),
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_int_new_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_vector_int mlx_vector_int_new_value(int val)
     * }
     */
    public static FunctionDescriptor mlx_vector_int_new_value$descriptor() {
        return mlx_vector_int_new_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_vector_int mlx_vector_int_new_value(int val)
     * }
     */
    public static MethodHandle mlx_vector_int_new_value$handle() {
        return mlx_vector_int_new_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_vector_int mlx_vector_int_new_value(int val)
     * }
     */
    public static MemorySegment mlx_vector_int_new_value$address() {
        return mlx_vector_int_new_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_vector_int mlx_vector_int_new_value(int val)
     * }
     */
    public static MemorySegment mlx_vector_int_new_value(SegmentAllocator allocator, int val) {
        var mh$ = mlx_vector_int_new_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_int_new_value", allocator, val);
            }
            return (MemorySegment)mh$.invokeExact(allocator, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_int_set_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_int_set_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_int_set_data(mlx_vector_int *vec, int *data, size_t size)
     * }
     */
    public static FunctionDescriptor mlx_vector_int_set_data$descriptor() {
        return mlx_vector_int_set_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_int_set_data(mlx_vector_int *vec, int *data, size_t size)
     * }
     */
    public static MethodHandle mlx_vector_int_set_data$handle() {
        return mlx_vector_int_set_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_int_set_data(mlx_vector_int *vec, int *data, size_t size)
     * }
     */
    public static MemorySegment mlx_vector_int_set_data$address() {
        return mlx_vector_int_set_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_int_set_data(mlx_vector_int *vec, int *data, size_t size)
     * }
     */
    public static int mlx_vector_int_set_data(MemorySegment vec, MemorySegment data, long size) {
        var mh$ = mlx_vector_int_set_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_int_set_data", vec, data, size);
            }
            return (int)mh$.invokeExact(vec, data, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_int_set_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_int_set_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_int_set_value(mlx_vector_int *vec, int val)
     * }
     */
    public static FunctionDescriptor mlx_vector_int_set_value$descriptor() {
        return mlx_vector_int_set_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_int_set_value(mlx_vector_int *vec, int val)
     * }
     */
    public static MethodHandle mlx_vector_int_set_value$handle() {
        return mlx_vector_int_set_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_int_set_value(mlx_vector_int *vec, int val)
     * }
     */
    public static MemorySegment mlx_vector_int_set_value$address() {
        return mlx_vector_int_set_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_int_set_value(mlx_vector_int *vec, int val)
     * }
     */
    public static int mlx_vector_int_set_value(MemorySegment vec, int val) {
        var mh$ = mlx_vector_int_set_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_int_set_value", vec, val);
            }
            return (int)mh$.invokeExact(vec, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_int_append_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_vector_int_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_int_append_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_int_append_data(mlx_vector_int vec, int *data, size_t size)
     * }
     */
    public static FunctionDescriptor mlx_vector_int_append_data$descriptor() {
        return mlx_vector_int_append_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_int_append_data(mlx_vector_int vec, int *data, size_t size)
     * }
     */
    public static MethodHandle mlx_vector_int_append_data$handle() {
        return mlx_vector_int_append_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_int_append_data(mlx_vector_int vec, int *data, size_t size)
     * }
     */
    public static MemorySegment mlx_vector_int_append_data$address() {
        return mlx_vector_int_append_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_int_append_data(mlx_vector_int vec, int *data, size_t size)
     * }
     */
    public static int mlx_vector_int_append_data(MemorySegment vec, MemorySegment data, long size) {
        var mh$ = mlx_vector_int_append_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_int_append_data", vec, data, size);
            }
            return (int)mh$.invokeExact(vec, data, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_int_append_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_vector_int_.layout(),
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_int_append_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_int_append_value(mlx_vector_int vec, int val)
     * }
     */
    public static FunctionDescriptor mlx_vector_int_append_value$descriptor() {
        return mlx_vector_int_append_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_int_append_value(mlx_vector_int vec, int val)
     * }
     */
    public static MethodHandle mlx_vector_int_append_value$handle() {
        return mlx_vector_int_append_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_int_append_value(mlx_vector_int vec, int val)
     * }
     */
    public static MemorySegment mlx_vector_int_append_value$address() {
        return mlx_vector_int_append_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_int_append_value(mlx_vector_int vec, int val)
     * }
     */
    public static int mlx_vector_int_append_value(MemorySegment vec, int val) {
        var mh$ = mlx_vector_int_append_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_int_append_value", vec, val);
            }
            return (int)mh$.invokeExact(vec, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_int_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG,
            mlx_vector_int_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_int_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mlx_vector_int_size(mlx_vector_int vec)
     * }
     */
    public static FunctionDescriptor mlx_vector_int_size$descriptor() {
        return mlx_vector_int_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mlx_vector_int_size(mlx_vector_int vec)
     * }
     */
    public static MethodHandle mlx_vector_int_size$handle() {
        return mlx_vector_int_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mlx_vector_int_size(mlx_vector_int vec)
     * }
     */
    public static MemorySegment mlx_vector_int_size$address() {
        return mlx_vector_int_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mlx_vector_int_size(mlx_vector_int vec)
     * }
     */
    public static long mlx_vector_int_size(MemorySegment vec) {
        var mh$ = mlx_vector_int_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_int_size", vec);
            }
            return (long)mh$.invokeExact(vec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_int_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_vector_int_.layout(),
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_int_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_int_get(int *res, const mlx_vector_int vec, size_t idx)
     * }
     */
    public static FunctionDescriptor mlx_vector_int_get$descriptor() {
        return mlx_vector_int_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_int_get(int *res, const mlx_vector_int vec, size_t idx)
     * }
     */
    public static MethodHandle mlx_vector_int_get$handle() {
        return mlx_vector_int_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_int_get(int *res, const mlx_vector_int vec, size_t idx)
     * }
     */
    public static MemorySegment mlx_vector_int_get$address() {
        return mlx_vector_int_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_int_get(int *res, const mlx_vector_int vec, size_t idx)
     * }
     */
    public static int mlx_vector_int_get(MemorySegment res, MemorySegment vec, long idx) {
        var mh$ = mlx_vector_int_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_int_get", res, vec, idx);
            }
            return (int)mh$.invokeExact(res, vec, idx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * mlx_vector_string mlx_vector_string_new()
     * }
     */
    public static class mlx_vector_string_new {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_vector_string_.layout()        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_string_new");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private mlx_vector_string_new(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * mlx_vector_string mlx_vector_string_new()
         * }
         */
        public static mlx_vector_string_new makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new mlx_vector_string_new(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("mlx_vector_string_new", allocator, x0);
                }
                return (MemorySegment) spreader.invokeExact(allocator, x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class mlx_vector_string_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_vector_string_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_string_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_string_set(mlx_vector_string *vec, const mlx_vector_string src)
     * }
     */
    public static FunctionDescriptor mlx_vector_string_set$descriptor() {
        return mlx_vector_string_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_string_set(mlx_vector_string *vec, const mlx_vector_string src)
     * }
     */
    public static MethodHandle mlx_vector_string_set$handle() {
        return mlx_vector_string_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_string_set(mlx_vector_string *vec, const mlx_vector_string src)
     * }
     */
    public static MemorySegment mlx_vector_string_set$address() {
        return mlx_vector_string_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_string_set(mlx_vector_string *vec, const mlx_vector_string src)
     * }
     */
    public static int mlx_vector_string_set(MemorySegment vec, MemorySegment src) {
        var mh$ = mlx_vector_string_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_string_set", vec, src);
            }
            return (int)mh$.invokeExact(vec, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_string_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_vector_string_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_string_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_string_free(mlx_vector_string vec)
     * }
     */
    public static FunctionDescriptor mlx_vector_string_free$descriptor() {
        return mlx_vector_string_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_string_free(mlx_vector_string vec)
     * }
     */
    public static MethodHandle mlx_vector_string_free$handle() {
        return mlx_vector_string_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_string_free(mlx_vector_string vec)
     * }
     */
    public static MemorySegment mlx_vector_string_free$address() {
        return mlx_vector_string_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_string_free(mlx_vector_string vec)
     * }
     */
    public static int mlx_vector_string_free(MemorySegment vec) {
        var mh$ = mlx_vector_string_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_string_free", vec);
            }
            return (int)mh$.invokeExact(vec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_string_new_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_vector_string_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_string_new_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_vector_string mlx_vector_string_new_data(const char **data, size_t size)
     * }
     */
    public static FunctionDescriptor mlx_vector_string_new_data$descriptor() {
        return mlx_vector_string_new_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_vector_string mlx_vector_string_new_data(const char **data, size_t size)
     * }
     */
    public static MethodHandle mlx_vector_string_new_data$handle() {
        return mlx_vector_string_new_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_vector_string mlx_vector_string_new_data(const char **data, size_t size)
     * }
     */
    public static MemorySegment mlx_vector_string_new_data$address() {
        return mlx_vector_string_new_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_vector_string mlx_vector_string_new_data(const char **data, size_t size)
     * }
     */
    public static MemorySegment mlx_vector_string_new_data(SegmentAllocator allocator, MemorySegment data, long size) {
        var mh$ = mlx_vector_string_new_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_string_new_data", allocator, data, size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, data, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_string_new_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_vector_string_.layout(),
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_string_new_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_vector_string mlx_vector_string_new_value(const char *val)
     * }
     */
    public static FunctionDescriptor mlx_vector_string_new_value$descriptor() {
        return mlx_vector_string_new_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_vector_string mlx_vector_string_new_value(const char *val)
     * }
     */
    public static MethodHandle mlx_vector_string_new_value$handle() {
        return mlx_vector_string_new_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_vector_string mlx_vector_string_new_value(const char *val)
     * }
     */
    public static MemorySegment mlx_vector_string_new_value$address() {
        return mlx_vector_string_new_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_vector_string mlx_vector_string_new_value(const char *val)
     * }
     */
    public static MemorySegment mlx_vector_string_new_value(SegmentAllocator allocator, MemorySegment val) {
        var mh$ = mlx_vector_string_new_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_string_new_value", allocator, val);
            }
            return (MemorySegment)mh$.invokeExact(allocator, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_string_set_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_string_set_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_string_set_data(mlx_vector_string *vec, const char **data, size_t size)
     * }
     */
    public static FunctionDescriptor mlx_vector_string_set_data$descriptor() {
        return mlx_vector_string_set_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_string_set_data(mlx_vector_string *vec, const char **data, size_t size)
     * }
     */
    public static MethodHandle mlx_vector_string_set_data$handle() {
        return mlx_vector_string_set_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_string_set_data(mlx_vector_string *vec, const char **data, size_t size)
     * }
     */
    public static MemorySegment mlx_vector_string_set_data$address() {
        return mlx_vector_string_set_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_string_set_data(mlx_vector_string *vec, const char **data, size_t size)
     * }
     */
    public static int mlx_vector_string_set_data(MemorySegment vec, MemorySegment data, long size) {
        var mh$ = mlx_vector_string_set_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_string_set_data", vec, data, size);
            }
            return (int)mh$.invokeExact(vec, data, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_string_set_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_string_set_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_string_set_value(mlx_vector_string *vec, const char *val)
     * }
     */
    public static FunctionDescriptor mlx_vector_string_set_value$descriptor() {
        return mlx_vector_string_set_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_string_set_value(mlx_vector_string *vec, const char *val)
     * }
     */
    public static MethodHandle mlx_vector_string_set_value$handle() {
        return mlx_vector_string_set_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_string_set_value(mlx_vector_string *vec, const char *val)
     * }
     */
    public static MemorySegment mlx_vector_string_set_value$address() {
        return mlx_vector_string_set_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_string_set_value(mlx_vector_string *vec, const char *val)
     * }
     */
    public static int mlx_vector_string_set_value(MemorySegment vec, MemorySegment val) {
        var mh$ = mlx_vector_string_set_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_string_set_value", vec, val);
            }
            return (int)mh$.invokeExact(vec, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_string_append_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_vector_string_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_string_append_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_string_append_data(mlx_vector_string vec, const char **data, size_t size)
     * }
     */
    public static FunctionDescriptor mlx_vector_string_append_data$descriptor() {
        return mlx_vector_string_append_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_string_append_data(mlx_vector_string vec, const char **data, size_t size)
     * }
     */
    public static MethodHandle mlx_vector_string_append_data$handle() {
        return mlx_vector_string_append_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_string_append_data(mlx_vector_string vec, const char **data, size_t size)
     * }
     */
    public static MemorySegment mlx_vector_string_append_data$address() {
        return mlx_vector_string_append_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_string_append_data(mlx_vector_string vec, const char **data, size_t size)
     * }
     */
    public static int mlx_vector_string_append_data(MemorySegment vec, MemorySegment data, long size) {
        var mh$ = mlx_vector_string_append_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_string_append_data", vec, data, size);
            }
            return (int)mh$.invokeExact(vec, data, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_string_append_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_vector_string_.layout(),
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_string_append_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_string_append_value(mlx_vector_string vec, const char *val)
     * }
     */
    public static FunctionDescriptor mlx_vector_string_append_value$descriptor() {
        return mlx_vector_string_append_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_string_append_value(mlx_vector_string vec, const char *val)
     * }
     */
    public static MethodHandle mlx_vector_string_append_value$handle() {
        return mlx_vector_string_append_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_string_append_value(mlx_vector_string vec, const char *val)
     * }
     */
    public static MemorySegment mlx_vector_string_append_value$address() {
        return mlx_vector_string_append_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_string_append_value(mlx_vector_string vec, const char *val)
     * }
     */
    public static int mlx_vector_string_append_value(MemorySegment vec, MemorySegment val) {
        var mh$ = mlx_vector_string_append_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_string_append_value", vec, val);
            }
            return (int)mh$.invokeExact(vec, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_string_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG,
            mlx_vector_string_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_string_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mlx_vector_string_size(mlx_vector_string vec)
     * }
     */
    public static FunctionDescriptor mlx_vector_string_size$descriptor() {
        return mlx_vector_string_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mlx_vector_string_size(mlx_vector_string vec)
     * }
     */
    public static MethodHandle mlx_vector_string_size$handle() {
        return mlx_vector_string_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mlx_vector_string_size(mlx_vector_string vec)
     * }
     */
    public static MemorySegment mlx_vector_string_size$address() {
        return mlx_vector_string_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mlx_vector_string_size(mlx_vector_string vec)
     * }
     */
    public static long mlx_vector_string_size(MemorySegment vec) {
        var mh$ = mlx_vector_string_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_string_size", vec);
            }
            return (long)mh$.invokeExact(vec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vector_string_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_vector_string_.layout(),
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vector_string_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vector_string_get(char **res, const mlx_vector_string vec, size_t idx)
     * }
     */
    public static FunctionDescriptor mlx_vector_string_get$descriptor() {
        return mlx_vector_string_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vector_string_get(char **res, const mlx_vector_string vec, size_t idx)
     * }
     */
    public static MethodHandle mlx_vector_string_get$handle() {
        return mlx_vector_string_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vector_string_get(char **res, const mlx_vector_string vec, size_t idx)
     * }
     */
    public static MemorySegment mlx_vector_string_get$address() {
        return mlx_vector_string_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vector_string_get(char **res, const mlx_vector_string vec, size_t idx)
     * }
     */
    public static int mlx_vector_string_get(MemorySegment res, MemorySegment vec, long idx) {
        var mh$ = mlx_vector_string_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vector_string_get", res, vec, idx);
            }
            return (int)mh$.invokeExact(res, vec, idx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * mlx_closure mlx_closure_new()
     * }
     */
    public static class mlx_closure_new {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_closure_.layout()        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_new");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private mlx_closure_new(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * mlx_closure mlx_closure_new()
         * }
         */
        public static mlx_closure_new makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new mlx_closure_new(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("mlx_closure_new", allocator, x0);
                }
                return (MemorySegment) spreader.invokeExact(allocator, x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class mlx_closure_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_closure_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_closure_free(mlx_closure cls)
     * }
     */
    public static FunctionDescriptor mlx_closure_free$descriptor() {
        return mlx_closure_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_closure_free(mlx_closure cls)
     * }
     */
    public static MethodHandle mlx_closure_free$handle() {
        return mlx_closure_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_closure_free(mlx_closure cls)
     * }
     */
    public static MemorySegment mlx_closure_free$address() {
        return mlx_closure_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_closure_free(mlx_closure cls)
     * }
     */
    public static int mlx_closure_free(MemorySegment cls) {
        var mh$ = mlx_closure_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_free", cls);
            }
            return (int)mh$.invokeExact(cls);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_closure_new_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_closure_.layout(),
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_new_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_closure mlx_closure_new_func(int (*fun)(mlx_vector_array *, const mlx_vector_array))
     * }
     */
    public static FunctionDescriptor mlx_closure_new_func$descriptor() {
        return mlx_closure_new_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_closure mlx_closure_new_func(int (*fun)(mlx_vector_array *, const mlx_vector_array))
     * }
     */
    public static MethodHandle mlx_closure_new_func$handle() {
        return mlx_closure_new_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_closure mlx_closure_new_func(int (*fun)(mlx_vector_array *, const mlx_vector_array))
     * }
     */
    public static MemorySegment mlx_closure_new_func$address() {
        return mlx_closure_new_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_closure mlx_closure_new_func(int (*fun)(mlx_vector_array *, const mlx_vector_array))
     * }
     */
    public static MemorySegment mlx_closure_new_func(SegmentAllocator allocator, MemorySegment fun) {
        var mh$ = mlx_closure_new_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_new_func", allocator, fun);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fun);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_closure_new_func_payload {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_closure_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_new_func_payload");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_closure mlx_closure_new_func_payload(int (*fun)(mlx_vector_array *, const mlx_vector_array, void *), void *payload, void (*dtor)(void *))
     * }
     */
    public static FunctionDescriptor mlx_closure_new_func_payload$descriptor() {
        return mlx_closure_new_func_payload.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_closure mlx_closure_new_func_payload(int (*fun)(mlx_vector_array *, const mlx_vector_array, void *), void *payload, void (*dtor)(void *))
     * }
     */
    public static MethodHandle mlx_closure_new_func_payload$handle() {
        return mlx_closure_new_func_payload.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_closure mlx_closure_new_func_payload(int (*fun)(mlx_vector_array *, const mlx_vector_array, void *), void *payload, void (*dtor)(void *))
     * }
     */
    public static MemorySegment mlx_closure_new_func_payload$address() {
        return mlx_closure_new_func_payload.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_closure mlx_closure_new_func_payload(int (*fun)(mlx_vector_array *, const mlx_vector_array, void *), void *payload, void (*dtor)(void *))
     * }
     */
    public static MemorySegment mlx_closure_new_func_payload(SegmentAllocator allocator, MemorySegment fun, MemorySegment payload, MemorySegment dtor) {
        var mh$ = mlx_closure_new_func_payload.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_new_func_payload", allocator, fun, payload, dtor);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fun, payload, dtor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_closure_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_closure_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_closure_set(mlx_closure *cls, const mlx_closure src)
     * }
     */
    public static FunctionDescriptor mlx_closure_set$descriptor() {
        return mlx_closure_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_closure_set(mlx_closure *cls, const mlx_closure src)
     * }
     */
    public static MethodHandle mlx_closure_set$handle() {
        return mlx_closure_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_closure_set(mlx_closure *cls, const mlx_closure src)
     * }
     */
    public static MemorySegment mlx_closure_set$address() {
        return mlx_closure_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_closure_set(mlx_closure *cls, const mlx_closure src)
     * }
     */
    public static int mlx_closure_set(MemorySegment cls, MemorySegment src) {
        var mh$ = mlx_closure_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_set", cls, src);
            }
            return (int)mh$.invokeExact(cls, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_closure_apply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_closure_.layout(),
            mlx_vector_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_apply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_closure_apply(mlx_vector_array *res, mlx_closure cls, const mlx_vector_array input)
     * }
     */
    public static FunctionDescriptor mlx_closure_apply$descriptor() {
        return mlx_closure_apply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_closure_apply(mlx_vector_array *res, mlx_closure cls, const mlx_vector_array input)
     * }
     */
    public static MethodHandle mlx_closure_apply$handle() {
        return mlx_closure_apply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_closure_apply(mlx_vector_array *res, mlx_closure cls, const mlx_vector_array input)
     * }
     */
    public static MemorySegment mlx_closure_apply$address() {
        return mlx_closure_apply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_closure_apply(mlx_vector_array *res, mlx_closure cls, const mlx_vector_array input)
     * }
     */
    public static int mlx_closure_apply(MemorySegment res, MemorySegment cls, MemorySegment input) {
        var mh$ = mlx_closure_apply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_apply", res, cls, input);
            }
            return (int)mh$.invokeExact(res, cls, input);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_closure_new_unary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_closure_.layout(),
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_new_unary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_closure mlx_closure_new_unary(int (*fun)(mlx_array *, const mlx_array))
     * }
     */
    public static FunctionDescriptor mlx_closure_new_unary$descriptor() {
        return mlx_closure_new_unary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_closure mlx_closure_new_unary(int (*fun)(mlx_array *, const mlx_array))
     * }
     */
    public static MethodHandle mlx_closure_new_unary$handle() {
        return mlx_closure_new_unary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_closure mlx_closure_new_unary(int (*fun)(mlx_array *, const mlx_array))
     * }
     */
    public static MemorySegment mlx_closure_new_unary$address() {
        return mlx_closure_new_unary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_closure mlx_closure_new_unary(int (*fun)(mlx_array *, const mlx_array))
     * }
     */
    public static MemorySegment mlx_closure_new_unary(SegmentAllocator allocator, MemorySegment fun) {
        var mh$ = mlx_closure_new_unary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_new_unary", allocator, fun);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fun);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * mlx_closure_kwargs mlx_closure_kwargs_new()
     * }
     */
    public static class mlx_closure_kwargs_new {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_closure_kwargs_.layout()        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_kwargs_new");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private mlx_closure_kwargs_new(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * mlx_closure_kwargs mlx_closure_kwargs_new()
         * }
         */
        public static mlx_closure_kwargs_new makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new mlx_closure_kwargs_new(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("mlx_closure_kwargs_new", allocator, x0);
                }
                return (MemorySegment) spreader.invokeExact(allocator, x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class mlx_closure_kwargs_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_closure_kwargs_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_kwargs_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_closure_kwargs_free(mlx_closure_kwargs cls)
     * }
     */
    public static FunctionDescriptor mlx_closure_kwargs_free$descriptor() {
        return mlx_closure_kwargs_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_closure_kwargs_free(mlx_closure_kwargs cls)
     * }
     */
    public static MethodHandle mlx_closure_kwargs_free$handle() {
        return mlx_closure_kwargs_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_closure_kwargs_free(mlx_closure_kwargs cls)
     * }
     */
    public static MemorySegment mlx_closure_kwargs_free$address() {
        return mlx_closure_kwargs_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_closure_kwargs_free(mlx_closure_kwargs cls)
     * }
     */
    public static int mlx_closure_kwargs_free(MemorySegment cls) {
        var mh$ = mlx_closure_kwargs_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_kwargs_free", cls);
            }
            return (int)mh$.invokeExact(cls);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_closure_kwargs_new_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_closure_kwargs_.layout(),
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_kwargs_new_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_closure_kwargs mlx_closure_kwargs_new_func(int (*fun)(mlx_vector_array *, const mlx_vector_array, const mlx_map_string_to_array))
     * }
     */
    public static FunctionDescriptor mlx_closure_kwargs_new_func$descriptor() {
        return mlx_closure_kwargs_new_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_closure_kwargs mlx_closure_kwargs_new_func(int (*fun)(mlx_vector_array *, const mlx_vector_array, const mlx_map_string_to_array))
     * }
     */
    public static MethodHandle mlx_closure_kwargs_new_func$handle() {
        return mlx_closure_kwargs_new_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_closure_kwargs mlx_closure_kwargs_new_func(int (*fun)(mlx_vector_array *, const mlx_vector_array, const mlx_map_string_to_array))
     * }
     */
    public static MemorySegment mlx_closure_kwargs_new_func$address() {
        return mlx_closure_kwargs_new_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_closure_kwargs mlx_closure_kwargs_new_func(int (*fun)(mlx_vector_array *, const mlx_vector_array, const mlx_map_string_to_array))
     * }
     */
    public static MemorySegment mlx_closure_kwargs_new_func(SegmentAllocator allocator, MemorySegment fun) {
        var mh$ = mlx_closure_kwargs_new_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_kwargs_new_func", allocator, fun);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fun);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_closure_kwargs_new_func_payload {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_closure_kwargs_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_kwargs_new_func_payload");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_closure_kwargs mlx_closure_kwargs_new_func_payload(int (*fun)(mlx_vector_array *, const mlx_vector_array, const mlx_map_string_to_array, void *), void *payload, void (*dtor)(void *))
     * }
     */
    public static FunctionDescriptor mlx_closure_kwargs_new_func_payload$descriptor() {
        return mlx_closure_kwargs_new_func_payload.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_closure_kwargs mlx_closure_kwargs_new_func_payload(int (*fun)(mlx_vector_array *, const mlx_vector_array, const mlx_map_string_to_array, void *), void *payload, void (*dtor)(void *))
     * }
     */
    public static MethodHandle mlx_closure_kwargs_new_func_payload$handle() {
        return mlx_closure_kwargs_new_func_payload.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_closure_kwargs mlx_closure_kwargs_new_func_payload(int (*fun)(mlx_vector_array *, const mlx_vector_array, const mlx_map_string_to_array, void *), void *payload, void (*dtor)(void *))
     * }
     */
    public static MemorySegment mlx_closure_kwargs_new_func_payload$address() {
        return mlx_closure_kwargs_new_func_payload.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_closure_kwargs mlx_closure_kwargs_new_func_payload(int (*fun)(mlx_vector_array *, const mlx_vector_array, const mlx_map_string_to_array, void *), void *payload, void (*dtor)(void *))
     * }
     */
    public static MemorySegment mlx_closure_kwargs_new_func_payload(SegmentAllocator allocator, MemorySegment fun, MemorySegment payload, MemorySegment dtor) {
        var mh$ = mlx_closure_kwargs_new_func_payload.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_kwargs_new_func_payload", allocator, fun, payload, dtor);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fun, payload, dtor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_closure_kwargs_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_closure_kwargs_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_kwargs_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_closure_kwargs_set(mlx_closure_kwargs *cls, const mlx_closure_kwargs src)
     * }
     */
    public static FunctionDescriptor mlx_closure_kwargs_set$descriptor() {
        return mlx_closure_kwargs_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_closure_kwargs_set(mlx_closure_kwargs *cls, const mlx_closure_kwargs src)
     * }
     */
    public static MethodHandle mlx_closure_kwargs_set$handle() {
        return mlx_closure_kwargs_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_closure_kwargs_set(mlx_closure_kwargs *cls, const mlx_closure_kwargs src)
     * }
     */
    public static MemorySegment mlx_closure_kwargs_set$address() {
        return mlx_closure_kwargs_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_closure_kwargs_set(mlx_closure_kwargs *cls, const mlx_closure_kwargs src)
     * }
     */
    public static int mlx_closure_kwargs_set(MemorySegment cls, MemorySegment src) {
        var mh$ = mlx_closure_kwargs_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_kwargs_set", cls, src);
            }
            return (int)mh$.invokeExact(cls, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_closure_kwargs_apply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_closure_kwargs_.layout(),
            mlx_vector_array_.layout(),
            mlx_map_string_to_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_kwargs_apply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_closure_kwargs_apply(mlx_vector_array *res, mlx_closure_kwargs cls, const mlx_vector_array input_0, const mlx_map_string_to_array input_1)
     * }
     */
    public static FunctionDescriptor mlx_closure_kwargs_apply$descriptor() {
        return mlx_closure_kwargs_apply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_closure_kwargs_apply(mlx_vector_array *res, mlx_closure_kwargs cls, const mlx_vector_array input_0, const mlx_map_string_to_array input_1)
     * }
     */
    public static MethodHandle mlx_closure_kwargs_apply$handle() {
        return mlx_closure_kwargs_apply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_closure_kwargs_apply(mlx_vector_array *res, mlx_closure_kwargs cls, const mlx_vector_array input_0, const mlx_map_string_to_array input_1)
     * }
     */
    public static MemorySegment mlx_closure_kwargs_apply$address() {
        return mlx_closure_kwargs_apply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_closure_kwargs_apply(mlx_vector_array *res, mlx_closure_kwargs cls, const mlx_vector_array input_0, const mlx_map_string_to_array input_1)
     * }
     */
    public static int mlx_closure_kwargs_apply(MemorySegment res, MemorySegment cls, MemorySegment input_0, MemorySegment input_1) {
        var mh$ = mlx_closure_kwargs_apply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_kwargs_apply", res, cls, input_0, input_1);
            }
            return (int)mh$.invokeExact(res, cls, input_0, input_1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * mlx_closure_value_and_grad mlx_closure_value_and_grad_new()
     * }
     */
    public static class mlx_closure_value_and_grad_new {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_closure_value_and_grad_.layout()        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_value_and_grad_new");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private mlx_closure_value_and_grad_new(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * mlx_closure_value_and_grad mlx_closure_value_and_grad_new()
         * }
         */
        public static mlx_closure_value_and_grad_new makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new mlx_closure_value_and_grad_new(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("mlx_closure_value_and_grad_new", allocator, x0);
                }
                return (MemorySegment) spreader.invokeExact(allocator, x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class mlx_closure_value_and_grad_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_closure_value_and_grad_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_value_and_grad_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_closure_value_and_grad_free(mlx_closure_value_and_grad cls)
     * }
     */
    public static FunctionDescriptor mlx_closure_value_and_grad_free$descriptor() {
        return mlx_closure_value_and_grad_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_closure_value_and_grad_free(mlx_closure_value_and_grad cls)
     * }
     */
    public static MethodHandle mlx_closure_value_and_grad_free$handle() {
        return mlx_closure_value_and_grad_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_closure_value_and_grad_free(mlx_closure_value_and_grad cls)
     * }
     */
    public static MemorySegment mlx_closure_value_and_grad_free$address() {
        return mlx_closure_value_and_grad_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_closure_value_and_grad_free(mlx_closure_value_and_grad cls)
     * }
     */
    public static int mlx_closure_value_and_grad_free(MemorySegment cls) {
        var mh$ = mlx_closure_value_and_grad_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_value_and_grad_free", cls);
            }
            return (int)mh$.invokeExact(cls);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_closure_value_and_grad_new_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_closure_value_and_grad_.layout(),
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_value_and_grad_new_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_closure_value_and_grad mlx_closure_value_and_grad_new_func(int (*fun)(mlx_vector_array *, mlx_vector_array *, const mlx_vector_array))
     * }
     */
    public static FunctionDescriptor mlx_closure_value_and_grad_new_func$descriptor() {
        return mlx_closure_value_and_grad_new_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_closure_value_and_grad mlx_closure_value_and_grad_new_func(int (*fun)(mlx_vector_array *, mlx_vector_array *, const mlx_vector_array))
     * }
     */
    public static MethodHandle mlx_closure_value_and_grad_new_func$handle() {
        return mlx_closure_value_and_grad_new_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_closure_value_and_grad mlx_closure_value_and_grad_new_func(int (*fun)(mlx_vector_array *, mlx_vector_array *, const mlx_vector_array))
     * }
     */
    public static MemorySegment mlx_closure_value_and_grad_new_func$address() {
        return mlx_closure_value_and_grad_new_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_closure_value_and_grad mlx_closure_value_and_grad_new_func(int (*fun)(mlx_vector_array *, mlx_vector_array *, const mlx_vector_array))
     * }
     */
    public static MemorySegment mlx_closure_value_and_grad_new_func(SegmentAllocator allocator, MemorySegment fun) {
        var mh$ = mlx_closure_value_and_grad_new_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_value_and_grad_new_func", allocator, fun);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fun);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_closure_value_and_grad_new_func_payload {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_closure_value_and_grad_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_value_and_grad_new_func_payload");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_closure_value_and_grad mlx_closure_value_and_grad_new_func_payload(int (*fun)(mlx_vector_array *, mlx_vector_array *, const mlx_vector_array, void *), void *payload, void (*dtor)(void *))
     * }
     */
    public static FunctionDescriptor mlx_closure_value_and_grad_new_func_payload$descriptor() {
        return mlx_closure_value_and_grad_new_func_payload.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_closure_value_and_grad mlx_closure_value_and_grad_new_func_payload(int (*fun)(mlx_vector_array *, mlx_vector_array *, const mlx_vector_array, void *), void *payload, void (*dtor)(void *))
     * }
     */
    public static MethodHandle mlx_closure_value_and_grad_new_func_payload$handle() {
        return mlx_closure_value_and_grad_new_func_payload.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_closure_value_and_grad mlx_closure_value_and_grad_new_func_payload(int (*fun)(mlx_vector_array *, mlx_vector_array *, const mlx_vector_array, void *), void *payload, void (*dtor)(void *))
     * }
     */
    public static MemorySegment mlx_closure_value_and_grad_new_func_payload$address() {
        return mlx_closure_value_and_grad_new_func_payload.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_closure_value_and_grad mlx_closure_value_and_grad_new_func_payload(int (*fun)(mlx_vector_array *, mlx_vector_array *, const mlx_vector_array, void *), void *payload, void (*dtor)(void *))
     * }
     */
    public static MemorySegment mlx_closure_value_and_grad_new_func_payload(SegmentAllocator allocator, MemorySegment fun, MemorySegment payload, MemorySegment dtor) {
        var mh$ = mlx_closure_value_and_grad_new_func_payload.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_value_and_grad_new_func_payload", allocator, fun, payload, dtor);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fun, payload, dtor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_closure_value_and_grad_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_closure_value_and_grad_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_value_and_grad_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_closure_value_and_grad_set(mlx_closure_value_and_grad *cls, const mlx_closure_value_and_grad src)
     * }
     */
    public static FunctionDescriptor mlx_closure_value_and_grad_set$descriptor() {
        return mlx_closure_value_and_grad_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_closure_value_and_grad_set(mlx_closure_value_and_grad *cls, const mlx_closure_value_and_grad src)
     * }
     */
    public static MethodHandle mlx_closure_value_and_grad_set$handle() {
        return mlx_closure_value_and_grad_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_closure_value_and_grad_set(mlx_closure_value_and_grad *cls, const mlx_closure_value_and_grad src)
     * }
     */
    public static MemorySegment mlx_closure_value_and_grad_set$address() {
        return mlx_closure_value_and_grad_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_closure_value_and_grad_set(mlx_closure_value_and_grad *cls, const mlx_closure_value_and_grad src)
     * }
     */
    public static int mlx_closure_value_and_grad_set(MemorySegment cls, MemorySegment src) {
        var mh$ = mlx_closure_value_and_grad_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_value_and_grad_set", cls, src);
            }
            return (int)mh$.invokeExact(cls, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_closure_value_and_grad_apply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_closure_value_and_grad_.layout(),
            mlx_vector_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_value_and_grad_apply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_closure_value_and_grad_apply(mlx_vector_array *res_0, mlx_vector_array *res_1, mlx_closure_value_and_grad cls, const mlx_vector_array input)
     * }
     */
    public static FunctionDescriptor mlx_closure_value_and_grad_apply$descriptor() {
        return mlx_closure_value_and_grad_apply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_closure_value_and_grad_apply(mlx_vector_array *res_0, mlx_vector_array *res_1, mlx_closure_value_and_grad cls, const mlx_vector_array input)
     * }
     */
    public static MethodHandle mlx_closure_value_and_grad_apply$handle() {
        return mlx_closure_value_and_grad_apply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_closure_value_and_grad_apply(mlx_vector_array *res_0, mlx_vector_array *res_1, mlx_closure_value_and_grad cls, const mlx_vector_array input)
     * }
     */
    public static MemorySegment mlx_closure_value_and_grad_apply$address() {
        return mlx_closure_value_and_grad_apply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_closure_value_and_grad_apply(mlx_vector_array *res_0, mlx_vector_array *res_1, mlx_closure_value_and_grad cls, const mlx_vector_array input)
     * }
     */
    public static int mlx_closure_value_and_grad_apply(MemorySegment res_0, MemorySegment res_1, MemorySegment cls, MemorySegment input) {
        var mh$ = mlx_closure_value_and_grad_apply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_value_and_grad_apply", res_0, res_1, cls, input);
            }
            return (int)mh$.invokeExact(res_0, res_1, cls, input);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * mlx_closure_custom mlx_closure_custom_new()
     * }
     */
    public static class mlx_closure_custom_new {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_closure_custom_.layout()        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_custom_new");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private mlx_closure_custom_new(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * mlx_closure_custom mlx_closure_custom_new()
         * }
         */
        public static mlx_closure_custom_new makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new mlx_closure_custom_new(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("mlx_closure_custom_new", allocator, x0);
                }
                return (MemorySegment) spreader.invokeExact(allocator, x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class mlx_closure_custom_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_closure_custom_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_custom_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_closure_custom_free(mlx_closure_custom cls)
     * }
     */
    public static FunctionDescriptor mlx_closure_custom_free$descriptor() {
        return mlx_closure_custom_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_closure_custom_free(mlx_closure_custom cls)
     * }
     */
    public static MethodHandle mlx_closure_custom_free$handle() {
        return mlx_closure_custom_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_closure_custom_free(mlx_closure_custom cls)
     * }
     */
    public static MemorySegment mlx_closure_custom_free$address() {
        return mlx_closure_custom_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_closure_custom_free(mlx_closure_custom cls)
     * }
     */
    public static int mlx_closure_custom_free(MemorySegment cls) {
        var mh$ = mlx_closure_custom_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_custom_free", cls);
            }
            return (int)mh$.invokeExact(cls);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_closure_custom_new_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_closure_custom_.layout(),
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_custom_new_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_closure_custom mlx_closure_custom_new_func(int (*fun)(mlx_vector_array *, const mlx_vector_array, const mlx_vector_array, const mlx_vector_array))
     * }
     */
    public static FunctionDescriptor mlx_closure_custom_new_func$descriptor() {
        return mlx_closure_custom_new_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_closure_custom mlx_closure_custom_new_func(int (*fun)(mlx_vector_array *, const mlx_vector_array, const mlx_vector_array, const mlx_vector_array))
     * }
     */
    public static MethodHandle mlx_closure_custom_new_func$handle() {
        return mlx_closure_custom_new_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_closure_custom mlx_closure_custom_new_func(int (*fun)(mlx_vector_array *, const mlx_vector_array, const mlx_vector_array, const mlx_vector_array))
     * }
     */
    public static MemorySegment mlx_closure_custom_new_func$address() {
        return mlx_closure_custom_new_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_closure_custom mlx_closure_custom_new_func(int (*fun)(mlx_vector_array *, const mlx_vector_array, const mlx_vector_array, const mlx_vector_array))
     * }
     */
    public static MemorySegment mlx_closure_custom_new_func(SegmentAllocator allocator, MemorySegment fun) {
        var mh$ = mlx_closure_custom_new_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_custom_new_func", allocator, fun);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fun);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_closure_custom_new_func_payload {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_closure_custom_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_custom_new_func_payload");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_closure_custom mlx_closure_custom_new_func_payload(int (*fun)(mlx_vector_array *, const mlx_vector_array, const mlx_vector_array, const mlx_vector_array, void *), void *payload, void (*dtor)(void *))
     * }
     */
    public static FunctionDescriptor mlx_closure_custom_new_func_payload$descriptor() {
        return mlx_closure_custom_new_func_payload.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_closure_custom mlx_closure_custom_new_func_payload(int (*fun)(mlx_vector_array *, const mlx_vector_array, const mlx_vector_array, const mlx_vector_array, void *), void *payload, void (*dtor)(void *))
     * }
     */
    public static MethodHandle mlx_closure_custom_new_func_payload$handle() {
        return mlx_closure_custom_new_func_payload.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_closure_custom mlx_closure_custom_new_func_payload(int (*fun)(mlx_vector_array *, const mlx_vector_array, const mlx_vector_array, const mlx_vector_array, void *), void *payload, void (*dtor)(void *))
     * }
     */
    public static MemorySegment mlx_closure_custom_new_func_payload$address() {
        return mlx_closure_custom_new_func_payload.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_closure_custom mlx_closure_custom_new_func_payload(int (*fun)(mlx_vector_array *, const mlx_vector_array, const mlx_vector_array, const mlx_vector_array, void *), void *payload, void (*dtor)(void *))
     * }
     */
    public static MemorySegment mlx_closure_custom_new_func_payload(SegmentAllocator allocator, MemorySegment fun, MemorySegment payload, MemorySegment dtor) {
        var mh$ = mlx_closure_custom_new_func_payload.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_custom_new_func_payload", allocator, fun, payload, dtor);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fun, payload, dtor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_closure_custom_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_closure_custom_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_custom_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_closure_custom_set(mlx_closure_custom *cls, const mlx_closure_custom src)
     * }
     */
    public static FunctionDescriptor mlx_closure_custom_set$descriptor() {
        return mlx_closure_custom_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_closure_custom_set(mlx_closure_custom *cls, const mlx_closure_custom src)
     * }
     */
    public static MethodHandle mlx_closure_custom_set$handle() {
        return mlx_closure_custom_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_closure_custom_set(mlx_closure_custom *cls, const mlx_closure_custom src)
     * }
     */
    public static MemorySegment mlx_closure_custom_set$address() {
        return mlx_closure_custom_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_closure_custom_set(mlx_closure_custom *cls, const mlx_closure_custom src)
     * }
     */
    public static int mlx_closure_custom_set(MemorySegment cls, MemorySegment src) {
        var mh$ = mlx_closure_custom_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_custom_set", cls, src);
            }
            return (int)mh$.invokeExact(cls, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_closure_custom_apply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_closure_custom_.layout(),
            mlx_vector_array_.layout(),
            mlx_vector_array_.layout(),
            mlx_vector_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_custom_apply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_closure_custom_apply(mlx_vector_array *res, mlx_closure_custom cls, const mlx_vector_array input_0, const mlx_vector_array input_1, const mlx_vector_array input_2)
     * }
     */
    public static FunctionDescriptor mlx_closure_custom_apply$descriptor() {
        return mlx_closure_custom_apply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_closure_custom_apply(mlx_vector_array *res, mlx_closure_custom cls, const mlx_vector_array input_0, const mlx_vector_array input_1, const mlx_vector_array input_2)
     * }
     */
    public static MethodHandle mlx_closure_custom_apply$handle() {
        return mlx_closure_custom_apply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_closure_custom_apply(mlx_vector_array *res, mlx_closure_custom cls, const mlx_vector_array input_0, const mlx_vector_array input_1, const mlx_vector_array input_2)
     * }
     */
    public static MemorySegment mlx_closure_custom_apply$address() {
        return mlx_closure_custom_apply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_closure_custom_apply(mlx_vector_array *res, mlx_closure_custom cls, const mlx_vector_array input_0, const mlx_vector_array input_1, const mlx_vector_array input_2)
     * }
     */
    public static int mlx_closure_custom_apply(MemorySegment res, MemorySegment cls, MemorySegment input_0, MemorySegment input_1, MemorySegment input_2) {
        var mh$ = mlx_closure_custom_apply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_custom_apply", res, cls, input_0, input_1, input_2);
            }
            return (int)mh$.invokeExact(res, cls, input_0, input_1, input_2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * mlx_closure_custom_jvp mlx_closure_custom_jvp_new()
     * }
     */
    public static class mlx_closure_custom_jvp_new {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_closure_custom_jvp_.layout()        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_custom_jvp_new");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private mlx_closure_custom_jvp_new(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * mlx_closure_custom_jvp mlx_closure_custom_jvp_new()
         * }
         */
        public static mlx_closure_custom_jvp_new makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new mlx_closure_custom_jvp_new(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("mlx_closure_custom_jvp_new", allocator, x0);
                }
                return (MemorySegment) spreader.invokeExact(allocator, x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class mlx_closure_custom_jvp_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_closure_custom_jvp_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_custom_jvp_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_closure_custom_jvp_free(mlx_closure_custom_jvp cls)
     * }
     */
    public static FunctionDescriptor mlx_closure_custom_jvp_free$descriptor() {
        return mlx_closure_custom_jvp_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_closure_custom_jvp_free(mlx_closure_custom_jvp cls)
     * }
     */
    public static MethodHandle mlx_closure_custom_jvp_free$handle() {
        return mlx_closure_custom_jvp_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_closure_custom_jvp_free(mlx_closure_custom_jvp cls)
     * }
     */
    public static MemorySegment mlx_closure_custom_jvp_free$address() {
        return mlx_closure_custom_jvp_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_closure_custom_jvp_free(mlx_closure_custom_jvp cls)
     * }
     */
    public static int mlx_closure_custom_jvp_free(MemorySegment cls) {
        var mh$ = mlx_closure_custom_jvp_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_custom_jvp_free", cls);
            }
            return (int)mh$.invokeExact(cls);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_closure_custom_jvp_new_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_closure_custom_jvp_.layout(),
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_custom_jvp_new_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_closure_custom_jvp mlx_closure_custom_jvp_new_func(int (*fun)(mlx_vector_array *, const mlx_vector_array, const mlx_vector_array, const int *, size_t))
     * }
     */
    public static FunctionDescriptor mlx_closure_custom_jvp_new_func$descriptor() {
        return mlx_closure_custom_jvp_new_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_closure_custom_jvp mlx_closure_custom_jvp_new_func(int (*fun)(mlx_vector_array *, const mlx_vector_array, const mlx_vector_array, const int *, size_t))
     * }
     */
    public static MethodHandle mlx_closure_custom_jvp_new_func$handle() {
        return mlx_closure_custom_jvp_new_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_closure_custom_jvp mlx_closure_custom_jvp_new_func(int (*fun)(mlx_vector_array *, const mlx_vector_array, const mlx_vector_array, const int *, size_t))
     * }
     */
    public static MemorySegment mlx_closure_custom_jvp_new_func$address() {
        return mlx_closure_custom_jvp_new_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_closure_custom_jvp mlx_closure_custom_jvp_new_func(int (*fun)(mlx_vector_array *, const mlx_vector_array, const mlx_vector_array, const int *, size_t))
     * }
     */
    public static MemorySegment mlx_closure_custom_jvp_new_func(SegmentAllocator allocator, MemorySegment fun) {
        var mh$ = mlx_closure_custom_jvp_new_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_custom_jvp_new_func", allocator, fun);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fun);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_closure_custom_jvp_new_func_payload {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_closure_custom_jvp_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_custom_jvp_new_func_payload");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_closure_custom_jvp mlx_closure_custom_jvp_new_func_payload(int (*fun)(mlx_vector_array *, const mlx_vector_array, const mlx_vector_array, const int *, size_t, void *), void *payload, void (*dtor)(void *))
     * }
     */
    public static FunctionDescriptor mlx_closure_custom_jvp_new_func_payload$descriptor() {
        return mlx_closure_custom_jvp_new_func_payload.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_closure_custom_jvp mlx_closure_custom_jvp_new_func_payload(int (*fun)(mlx_vector_array *, const mlx_vector_array, const mlx_vector_array, const int *, size_t, void *), void *payload, void (*dtor)(void *))
     * }
     */
    public static MethodHandle mlx_closure_custom_jvp_new_func_payload$handle() {
        return mlx_closure_custom_jvp_new_func_payload.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_closure_custom_jvp mlx_closure_custom_jvp_new_func_payload(int (*fun)(mlx_vector_array *, const mlx_vector_array, const mlx_vector_array, const int *, size_t, void *), void *payload, void (*dtor)(void *))
     * }
     */
    public static MemorySegment mlx_closure_custom_jvp_new_func_payload$address() {
        return mlx_closure_custom_jvp_new_func_payload.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_closure_custom_jvp mlx_closure_custom_jvp_new_func_payload(int (*fun)(mlx_vector_array *, const mlx_vector_array, const mlx_vector_array, const int *, size_t, void *), void *payload, void (*dtor)(void *))
     * }
     */
    public static MemorySegment mlx_closure_custom_jvp_new_func_payload(SegmentAllocator allocator, MemorySegment fun, MemorySegment payload, MemorySegment dtor) {
        var mh$ = mlx_closure_custom_jvp_new_func_payload.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_custom_jvp_new_func_payload", allocator, fun, payload, dtor);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fun, payload, dtor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_closure_custom_jvp_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_closure_custom_jvp_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_custom_jvp_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_closure_custom_jvp_set(mlx_closure_custom_jvp *cls, const mlx_closure_custom_jvp src)
     * }
     */
    public static FunctionDescriptor mlx_closure_custom_jvp_set$descriptor() {
        return mlx_closure_custom_jvp_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_closure_custom_jvp_set(mlx_closure_custom_jvp *cls, const mlx_closure_custom_jvp src)
     * }
     */
    public static MethodHandle mlx_closure_custom_jvp_set$handle() {
        return mlx_closure_custom_jvp_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_closure_custom_jvp_set(mlx_closure_custom_jvp *cls, const mlx_closure_custom_jvp src)
     * }
     */
    public static MemorySegment mlx_closure_custom_jvp_set$address() {
        return mlx_closure_custom_jvp_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_closure_custom_jvp_set(mlx_closure_custom_jvp *cls, const mlx_closure_custom_jvp src)
     * }
     */
    public static int mlx_closure_custom_jvp_set(MemorySegment cls, MemorySegment src) {
        var mh$ = mlx_closure_custom_jvp_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_custom_jvp_set", cls, src);
            }
            return (int)mh$.invokeExact(cls, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_closure_custom_jvp_apply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_closure_custom_jvp_.layout(),
            mlx_vector_array_.layout(),
            mlx_vector_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_custom_jvp_apply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_closure_custom_jvp_apply(mlx_vector_array *res, mlx_closure_custom_jvp cls, const mlx_vector_array input_0, const mlx_vector_array input_1, const int *input_2, size_t input_2_num)
     * }
     */
    public static FunctionDescriptor mlx_closure_custom_jvp_apply$descriptor() {
        return mlx_closure_custom_jvp_apply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_closure_custom_jvp_apply(mlx_vector_array *res, mlx_closure_custom_jvp cls, const mlx_vector_array input_0, const mlx_vector_array input_1, const int *input_2, size_t input_2_num)
     * }
     */
    public static MethodHandle mlx_closure_custom_jvp_apply$handle() {
        return mlx_closure_custom_jvp_apply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_closure_custom_jvp_apply(mlx_vector_array *res, mlx_closure_custom_jvp cls, const mlx_vector_array input_0, const mlx_vector_array input_1, const int *input_2, size_t input_2_num)
     * }
     */
    public static MemorySegment mlx_closure_custom_jvp_apply$address() {
        return mlx_closure_custom_jvp_apply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_closure_custom_jvp_apply(mlx_vector_array *res, mlx_closure_custom_jvp cls, const mlx_vector_array input_0, const mlx_vector_array input_1, const int *input_2, size_t input_2_num)
     * }
     */
    public static int mlx_closure_custom_jvp_apply(MemorySegment res, MemorySegment cls, MemorySegment input_0, MemorySegment input_1, MemorySegment input_2, long input_2_num) {
        var mh$ = mlx_closure_custom_jvp_apply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_custom_jvp_apply", res, cls, input_0, input_1, input_2, input_2_num);
            }
            return (int)mh$.invokeExact(res, cls, input_0, input_1, input_2, input_2_num);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * mlx_closure_custom_vmap mlx_closure_custom_vmap_new()
     * }
     */
    public static class mlx_closure_custom_vmap_new {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_closure_custom_vmap_.layout()        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_custom_vmap_new");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private mlx_closure_custom_vmap_new(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * mlx_closure_custom_vmap mlx_closure_custom_vmap_new()
         * }
         */
        public static mlx_closure_custom_vmap_new makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new mlx_closure_custom_vmap_new(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("mlx_closure_custom_vmap_new", allocator, x0);
                }
                return (MemorySegment) spreader.invokeExact(allocator, x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class mlx_closure_custom_vmap_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_closure_custom_vmap_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_custom_vmap_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_closure_custom_vmap_free(mlx_closure_custom_vmap cls)
     * }
     */
    public static FunctionDescriptor mlx_closure_custom_vmap_free$descriptor() {
        return mlx_closure_custom_vmap_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_closure_custom_vmap_free(mlx_closure_custom_vmap cls)
     * }
     */
    public static MethodHandle mlx_closure_custom_vmap_free$handle() {
        return mlx_closure_custom_vmap_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_closure_custom_vmap_free(mlx_closure_custom_vmap cls)
     * }
     */
    public static MemorySegment mlx_closure_custom_vmap_free$address() {
        return mlx_closure_custom_vmap_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_closure_custom_vmap_free(mlx_closure_custom_vmap cls)
     * }
     */
    public static int mlx_closure_custom_vmap_free(MemorySegment cls) {
        var mh$ = mlx_closure_custom_vmap_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_custom_vmap_free", cls);
            }
            return (int)mh$.invokeExact(cls);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_closure_custom_vmap_new_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_closure_custom_vmap_.layout(),
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_custom_vmap_new_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_closure_custom_vmap mlx_closure_custom_vmap_new_func(int (*fun)(mlx_vector_array *, mlx_vector_int *, const mlx_vector_array, const int *, size_t))
     * }
     */
    public static FunctionDescriptor mlx_closure_custom_vmap_new_func$descriptor() {
        return mlx_closure_custom_vmap_new_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_closure_custom_vmap mlx_closure_custom_vmap_new_func(int (*fun)(mlx_vector_array *, mlx_vector_int *, const mlx_vector_array, const int *, size_t))
     * }
     */
    public static MethodHandle mlx_closure_custom_vmap_new_func$handle() {
        return mlx_closure_custom_vmap_new_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_closure_custom_vmap mlx_closure_custom_vmap_new_func(int (*fun)(mlx_vector_array *, mlx_vector_int *, const mlx_vector_array, const int *, size_t))
     * }
     */
    public static MemorySegment mlx_closure_custom_vmap_new_func$address() {
        return mlx_closure_custom_vmap_new_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_closure_custom_vmap mlx_closure_custom_vmap_new_func(int (*fun)(mlx_vector_array *, mlx_vector_int *, const mlx_vector_array, const int *, size_t))
     * }
     */
    public static MemorySegment mlx_closure_custom_vmap_new_func(SegmentAllocator allocator, MemorySegment fun) {
        var mh$ = mlx_closure_custom_vmap_new_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_custom_vmap_new_func", allocator, fun);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fun);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_closure_custom_vmap_new_func_payload {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_closure_custom_vmap_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_custom_vmap_new_func_payload");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_closure_custom_vmap mlx_closure_custom_vmap_new_func_payload(int (*fun)(mlx_vector_array *, mlx_vector_int *, const mlx_vector_array, const int *, size_t, void *), void *payload, void (*dtor)(void *))
     * }
     */
    public static FunctionDescriptor mlx_closure_custom_vmap_new_func_payload$descriptor() {
        return mlx_closure_custom_vmap_new_func_payload.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_closure_custom_vmap mlx_closure_custom_vmap_new_func_payload(int (*fun)(mlx_vector_array *, mlx_vector_int *, const mlx_vector_array, const int *, size_t, void *), void *payload, void (*dtor)(void *))
     * }
     */
    public static MethodHandle mlx_closure_custom_vmap_new_func_payload$handle() {
        return mlx_closure_custom_vmap_new_func_payload.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_closure_custom_vmap mlx_closure_custom_vmap_new_func_payload(int (*fun)(mlx_vector_array *, mlx_vector_int *, const mlx_vector_array, const int *, size_t, void *), void *payload, void (*dtor)(void *))
     * }
     */
    public static MemorySegment mlx_closure_custom_vmap_new_func_payload$address() {
        return mlx_closure_custom_vmap_new_func_payload.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_closure_custom_vmap mlx_closure_custom_vmap_new_func_payload(int (*fun)(mlx_vector_array *, mlx_vector_int *, const mlx_vector_array, const int *, size_t, void *), void *payload, void (*dtor)(void *))
     * }
     */
    public static MemorySegment mlx_closure_custom_vmap_new_func_payload(SegmentAllocator allocator, MemorySegment fun, MemorySegment payload, MemorySegment dtor) {
        var mh$ = mlx_closure_custom_vmap_new_func_payload.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_custom_vmap_new_func_payload", allocator, fun, payload, dtor);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fun, payload, dtor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_closure_custom_vmap_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_closure_custom_vmap_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_custom_vmap_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_closure_custom_vmap_set(mlx_closure_custom_vmap *cls, const mlx_closure_custom_vmap src)
     * }
     */
    public static FunctionDescriptor mlx_closure_custom_vmap_set$descriptor() {
        return mlx_closure_custom_vmap_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_closure_custom_vmap_set(mlx_closure_custom_vmap *cls, const mlx_closure_custom_vmap src)
     * }
     */
    public static MethodHandle mlx_closure_custom_vmap_set$handle() {
        return mlx_closure_custom_vmap_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_closure_custom_vmap_set(mlx_closure_custom_vmap *cls, const mlx_closure_custom_vmap src)
     * }
     */
    public static MemorySegment mlx_closure_custom_vmap_set$address() {
        return mlx_closure_custom_vmap_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_closure_custom_vmap_set(mlx_closure_custom_vmap *cls, const mlx_closure_custom_vmap src)
     * }
     */
    public static int mlx_closure_custom_vmap_set(MemorySegment cls, MemorySegment src) {
        var mh$ = mlx_closure_custom_vmap_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_custom_vmap_set", cls, src);
            }
            return (int)mh$.invokeExact(cls, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_closure_custom_vmap_apply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_closure_custom_vmap_.layout(),
            mlx_vector_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_closure_custom_vmap_apply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_closure_custom_vmap_apply(mlx_vector_array *res_0, mlx_vector_int *res_1, mlx_closure_custom_vmap cls, const mlx_vector_array input_0, const int *input_1, size_t input_1_num)
     * }
     */
    public static FunctionDescriptor mlx_closure_custom_vmap_apply$descriptor() {
        return mlx_closure_custom_vmap_apply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_closure_custom_vmap_apply(mlx_vector_array *res_0, mlx_vector_int *res_1, mlx_closure_custom_vmap cls, const mlx_vector_array input_0, const int *input_1, size_t input_1_num)
     * }
     */
    public static MethodHandle mlx_closure_custom_vmap_apply$handle() {
        return mlx_closure_custom_vmap_apply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_closure_custom_vmap_apply(mlx_vector_array *res_0, mlx_vector_int *res_1, mlx_closure_custom_vmap cls, const mlx_vector_array input_0, const int *input_1, size_t input_1_num)
     * }
     */
    public static MemorySegment mlx_closure_custom_vmap_apply$address() {
        return mlx_closure_custom_vmap_apply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_closure_custom_vmap_apply(mlx_vector_array *res_0, mlx_vector_int *res_1, mlx_closure_custom_vmap cls, const mlx_vector_array input_0, const int *input_1, size_t input_1_num)
     * }
     */
    public static int mlx_closure_custom_vmap_apply(MemorySegment res_0, MemorySegment res_1, MemorySegment cls, MemorySegment input_0, MemorySegment input_1, long input_1_num) {
        var mh$ = mlx_closure_custom_vmap_apply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_closure_custom_vmap_apply", res_0, res_1, cls, input_0, input_1, input_1_num);
            }
            return (int)mh$.invokeExact(res_0, res_1, cls, input_0, input_1, input_1_num);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_va_list va_list
     * }
     */
    public static final AddressLayout va_list = mlx_h.C_POINTER;

    private static class renameat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("renameat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int renameat(int, const char *, int, const char *)
     * }
     */
    public static FunctionDescriptor renameat$descriptor() {
        return renameat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int renameat(int, const char *, int, const char *)
     * }
     */
    public static MethodHandle renameat$handle() {
        return renameat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int renameat(int, const char *, int, const char *)
     * }
     */
    public static MemorySegment renameat$address() {
        return renameat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int renameat(int, const char *, int, const char *)
     * }
     */
    public static int renameat(int x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = renameat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameat", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renamex_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("renamex_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int renamex_np(const char *, const char *, unsigned int)
     * }
     */
    public static FunctionDescriptor renamex_np$descriptor() {
        return renamex_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int renamex_np(const char *, const char *, unsigned int)
     * }
     */
    public static MethodHandle renamex_np$handle() {
        return renamex_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int renamex_np(const char *, const char *, unsigned int)
     * }
     */
    public static MemorySegment renamex_np$address() {
        return renamex_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int renamex_np(const char *, const char *, unsigned int)
     * }
     */
    public static int renamex_np(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = renamex_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renamex_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renameatx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("renameatx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int renameatx_np(int, const char *, int, const char *, unsigned int)
     * }
     */
    public static FunctionDescriptor renameatx_np$descriptor() {
        return renameatx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int renameatx_np(int, const char *, int, const char *, unsigned int)
     * }
     */
    public static MethodHandle renameatx_np$handle() {
        return renameatx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int renameatx_np(int, const char *, int, const char *, unsigned int)
     * }
     */
    public static MemorySegment renameatx_np$address() {
        return renameatx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int renameatx_np(int, const char *, int, const char *, unsigned int)
     * }
     */
    public static int renameatx_np(int x0, MemorySegment x1, int x2, MemorySegment x3, int x4) {
        var mh$ = renameatx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameatx_np", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int printf(const char *restrict, ...)
     * }
     */
    public static class printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_h.C_INT,
                mlx_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int printf(const char *restrict, ...)
         * }
         */
        public static printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("printf", x0, x1);
                }
                return (int) spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_off_t fpos_t
     * }
     */
    public static final OfLong fpos_t = mlx_h.C_LONG_LONG;

    private static class __stdinp$constants {
        public static final AddressLayout LAYOUT = mlx_h.C_POINTER;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("__stdinp").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *__stdinp
     * }
     */
    public static AddressLayout __stdinp$layout() {
        return __stdinp$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *__stdinp
     * }
     */
    public static MemorySegment __stdinp$segment() {
        return __stdinp$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *__stdinp
     * }
     */
    public static MemorySegment __stdinp() {
        return __stdinp$constants.SEGMENT.get(__stdinp$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *__stdinp
     * }
     */
    public static void __stdinp(MemorySegment varValue) {
        __stdinp$constants.SEGMENT.set(__stdinp$constants.LAYOUT, 0L, varValue);
    }

    private static class __stdoutp$constants {
        public static final AddressLayout LAYOUT = mlx_h.C_POINTER;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("__stdoutp").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *__stdoutp
     * }
     */
    public static AddressLayout __stdoutp$layout() {
        return __stdoutp$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *__stdoutp
     * }
     */
    public static MemorySegment __stdoutp$segment() {
        return __stdoutp$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *__stdoutp
     * }
     */
    public static MemorySegment __stdoutp() {
        return __stdoutp$constants.SEGMENT.get(__stdoutp$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *__stdoutp
     * }
     */
    public static void __stdoutp(MemorySegment varValue) {
        __stdoutp$constants.SEGMENT.set(__stdoutp$constants.LAYOUT, 0L, varValue);
    }

    private static class __stderrp$constants {
        public static final AddressLayout LAYOUT = mlx_h.C_POINTER;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("__stderrp").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *__stderrp
     * }
     */
    public static AddressLayout __stderrp$layout() {
        return __stderrp$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *__stderrp
     * }
     */
    public static MemorySegment __stderrp$segment() {
        return __stderrp$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *__stderrp
     * }
     */
    public static MemorySegment __stderrp() {
        return __stderrp$constants.SEGMENT.get(__stderrp$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *__stderrp
     * }
     */
    public static void __stderrp(MemorySegment varValue) {
        __stderrp$constants.SEGMENT.set(__stderrp$constants.LAYOUT, 0L, varValue);
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("clearerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clearerr(FILE *)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clearerr(FILE *)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clearerr(FILE *)
     * }
     */
    public static MemorySegment clearerr$address() {
        return clearerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clearerr(FILE *)
     * }
     */
    public static void clearerr(MemorySegment x0) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fclose(FILE *)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fclose(FILE *)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fclose(FILE *)
     * }
     */
    public static MemorySegment fclose$address() {
        return fclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fclose(FILE *)
     * }
     */
    public static int fclose(MemorySegment x0) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int feof(FILE *)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int feof(FILE *)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int feof(FILE *)
     * }
     */
    public static MemorySegment feof$address() {
        return feof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int feof(FILE *)
     * }
     */
    public static int feof(MemorySegment x0) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ferror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ferror(FILE *)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ferror(FILE *)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ferror(FILE *)
     * }
     */
    public static MemorySegment ferror$address() {
        return ferror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ferror(FILE *)
     * }
     */
    public static int ferror(MemorySegment x0) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fflush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fflush(FILE *)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fflush(FILE *)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fflush(FILE *)
     * }
     */
    public static MemorySegment fflush$address() {
        return fflush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fflush(FILE *)
     * }
     */
    public static int fflush(MemorySegment x0) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fgetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetc(FILE *)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetc(FILE *)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetc(FILE *)
     * }
     */
    public static MemorySegment fgetc$address() {
        return fgetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetc(FILE *)
     * }
     */
    public static int fgetc(MemorySegment x0) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fgetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetpos(FILE *restrict, fpos_t *)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetpos(FILE *restrict, fpos_t *)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetpos(FILE *restrict, fpos_t *)
     * }
     */
    public static MemorySegment fgetpos$address() {
        return fgetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetpos(FILE *restrict, fpos_t *)
     * }
     */
    public static int fgetpos(MemorySegment x0, MemorySegment x1) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fgets(char *restrict, int __size, FILE *)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fgets(char *restrict, int __size, FILE *)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fgets(char *restrict, int __size, FILE *)
     * }
     */
    public static MemorySegment fgets$address() {
        return fgets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fgets(char *restrict, int __size, FILE *)
     * }
     */
    public static MemorySegment fgets(MemorySegment x0, int __size, MemorySegment x2) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", x0, __size, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, __size, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fopen(const char *restrict __filename, const char *restrict __mode) asm("_fopen")
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fopen(const char *restrict __filename, const char *restrict __mode) asm("_fopen")
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *fopen(const char *restrict __filename, const char *restrict __mode) asm("_fopen")
     * }
     */
    public static MemorySegment fopen$address() {
        return fopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *fopen(const char *restrict __filename, const char *restrict __mode) asm("_fopen")
     * }
     */
    public static MemorySegment fopen(MemorySegment __filename, MemorySegment __mode) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", __filename, __mode);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int fprintf(FILE *restrict, const char *restrict, ...)
     * }
     */
    public static class fprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_h.C_INT,
                mlx_h.C_POINTER,
                mlx_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int fprintf(FILE *restrict, const char *restrict, ...)
         * }
         */
        public static fprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fprintf", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fputc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputc(int, FILE *)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputc(int, FILE *)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputc(int, FILE *)
     * }
     */
    public static MemorySegment fputc$address() {
        return fputc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputc(int, FILE *)
     * }
     */
    public static int fputc(int x0, MemorySegment x1) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputs(const char *restrict, FILE *restrict) asm("_fputs")
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputs(const char *restrict, FILE *restrict) asm("_fputs")
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputs(const char *restrict, FILE *restrict) asm("_fputs")
     * }
     */
    public static MemorySegment fputs$address() {
        return fputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputs(const char *restrict, FILE *restrict) asm("_fputs")
     * }
     */
    public static int fputs(MemorySegment x0, MemorySegment x1) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long fread(void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long fread(void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long fread(void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread$address() {
        return fread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long fread(void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static long fread(MemorySegment __ptr, long __size, long __nitems, MemorySegment __stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", __ptr, __size, __nitems, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __nitems, __stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("freopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *freopen(const char *restrict, const char *restrict, FILE *restrict) asm("_freopen")
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *freopen(const char *restrict, const char *restrict, FILE *restrict) asm("_freopen")
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *freopen(const char *restrict, const char *restrict, FILE *restrict) asm("_freopen")
     * }
     */
    public static MemorySegment freopen$address() {
        return freopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *freopen(const char *restrict, const char *restrict, FILE *restrict) asm("_freopen")
     * }
     */
    public static MemorySegment freopen(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int fscanf(FILE *restrict, const char *restrict, ...)
     * }
     */
    public static class fscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_h.C_INT,
                mlx_h.C_POINTER,
                mlx_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int fscanf(FILE *restrict, const char *restrict, ...)
         * }
         */
        public static fscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fscanf", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fseek(FILE *, long, int)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fseek(FILE *, long, int)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fseek(FILE *, long, int)
     * }
     */
    public static MemorySegment fseek$address() {
        return fseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fseek(FILE *, long, int)
     * }
     */
    public static int fseek(MemorySegment x0, long x1, int x2) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fsetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsetpos(FILE *, const fpos_t *)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsetpos(FILE *, const fpos_t *)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsetpos(FILE *, const fpos_t *)
     * }
     */
    public static MemorySegment fsetpos$address() {
        return fsetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsetpos(FILE *, const fpos_t *)
     * }
     */
    public static int fsetpos(MemorySegment x0, MemorySegment x1) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ftell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long ftell(FILE *)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long ftell(FILE *)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long ftell(FILE *)
     * }
     */
    public static MemorySegment ftell$address() {
        return ftell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long ftell(FILE *)
     * }
     */
    public static long ftell(MemorySegment x0) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream) asm("_fwrite")
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream) asm("_fwrite")
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream) asm("_fwrite")
     * }
     */
    public static MemorySegment fwrite$address() {
        return fwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream) asm("_fwrite")
     * }
     */
    public static long fwrite(MemorySegment __ptr, long __size, long __nitems, MemorySegment __stream) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", __ptr, __size, __nitems, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __nitems, __stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getc(FILE *)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getc(FILE *)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getc(FILE *)
     * }
     */
    public static MemorySegment getc$address() {
        return getc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getc(FILE *)
     * }
     */
    public static int getc(MemorySegment x0) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getchar(void)
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getchar(void)
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getchar(void)
     * }
     */
    public static MemorySegment getchar$address() {
        return getchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getchar(void)
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gets(char *)
     * }
     */
    public static FunctionDescriptor gets$descriptor() {
        return gets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gets(char *)
     * }
     */
    public static MethodHandle gets$handle() {
        return gets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *gets(char *)
     * }
     */
    public static MemorySegment gets$address() {
        return gets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *gets(char *)
     * }
     */
    public static MemorySegment gets(MemorySegment x0) {
        var mh$ = gets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gets", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void perror(const char *)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void perror(const char *)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void perror(const char *)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void perror(const char *)
     * }
     */
    public static void perror(MemorySegment x0) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putc(int, FILE *)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putc(int, FILE *)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putc(int, FILE *)
     * }
     */
    public static MemorySegment putc$address() {
        return putc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putc(int, FILE *)
     * }
     */
    public static int putc(int x0, MemorySegment x1) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putchar(int)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putchar(int)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putchar(int)
     * }
     */
    public static MemorySegment putchar$address() {
        return putchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putchar(int)
     * }
     */
    public static int putchar(int x0) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("puts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int puts(const char *)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int puts(const char *)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int puts(const char *)
     * }
     */
    public static MemorySegment puts$address() {
        return puts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int puts(const char *)
     * }
     */
    public static int puts(MemorySegment x0) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int remove(const char *)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int remove(const char *)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int remove(const char *)
     * }
     */
    public static MemorySegment remove$address() {
        return remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int remove(const char *)
     * }
     */
    public static int remove(MemorySegment x0) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rename(const char *__old, const char *__new)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rename(const char *__old, const char *__new)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rename(const char *__old, const char *__new)
     * }
     */
    public static MemorySegment rename$address() {
        return rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rename(const char *__old, const char *__new)
     * }
     */
    public static int rename(MemorySegment __old, MemorySegment __new) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", __old, __new);
            }
            return (int)mh$.invokeExact(__old, __new);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rewind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rewind(FILE *)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rewind(FILE *)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rewind(FILE *)
     * }
     */
    public static MemorySegment rewind$address() {
        return rewind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rewind(FILE *)
     * }
     */
    public static void rewind(MemorySegment x0) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int scanf(const char *restrict, ...)
     * }
     */
    public static class scanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_h.C_INT,
                mlx_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("scanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private scanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int scanf(const char *restrict, ...)
         * }
         */
        public static scanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new scanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("scanf", x0, x1);
                }
                return (int) spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setbuf(FILE *restrict, char *restrict)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setbuf(FILE *restrict, char *restrict)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setbuf(FILE *restrict, char *restrict)
     * }
     */
    public static MemorySegment setbuf$address() {
        return setbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setbuf(FILE *restrict, char *restrict)
     * }
     */
    public static void setbuf(MemorySegment x0, MemorySegment x1) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_INT,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setvbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setvbuf(FILE *restrict, char *restrict, int, size_t __size)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setvbuf(FILE *restrict, char *restrict, int, size_t __size)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setvbuf(FILE *restrict, char *restrict, int, size_t __size)
     * }
     */
    public static MemorySegment setvbuf$address() {
        return setvbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setvbuf(FILE *restrict, char *restrict, int, size_t __size)
     * }
     */
    public static int setvbuf(MemorySegment x0, MemorySegment x1, int x2, long __size) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", x0, x1, x2, __size);
            }
            return (int)mh$.invokeExact(x0, x1, x2, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int sprintf(char *restrict, const char *restrict, ...)
     * }
     */
    public static class sprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_h.C_INT,
                mlx_h.C_POINTER,
                mlx_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int sprintf(char *restrict, const char *restrict, ...)
         * }
         */
        public static sprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sprintf", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int sscanf(const char *restrict, const char *restrict, ...)
     * }
     */
    public static class sscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_h.C_INT,
                mlx_h.C_POINTER,
                mlx_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int sscanf(const char *restrict, const char *restrict, ...)
         * }
         */
        public static sscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sscanf", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tmpfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *tmpfile(void)
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *tmpfile(void)
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *tmpfile(void)
     * }
     */
    public static MemorySegment tmpfile$address() {
        return tmpfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *tmpfile(void)
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *tmpnam(char *)
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *tmpnam(char *)
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *tmpnam(char *)
     * }
     */
    public static MemorySegment tmpnam$address() {
        return tmpnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *tmpnam(char *)
     * }
     */
    public static MemorySegment tmpnam(MemorySegment x0) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ungetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ungetc(int, FILE *)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ungetc(int, FILE *)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ungetc(int, FILE *)
     * }
     */
    public static MemorySegment ungetc$address() {
        return ungetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ungetc(int, FILE *)
     * }
     */
    public static int ungetc(int x0, MemorySegment x1) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("vfprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vfprintf(FILE *restrict, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vfprintf$descriptor() {
        return vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vfprintf(FILE *restrict, const char *restrict, va_list)
     * }
     */
    public static MethodHandle vfprintf$handle() {
        return vfprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vfprintf(FILE *restrict, const char *restrict, va_list)
     * }
     */
    public static MemorySegment vfprintf$address() {
        return vfprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vfprintf(FILE *restrict, const char *restrict, va_list)
     * }
     */
    public static int vfprintf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("vprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vprintf(const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vprintf$descriptor() {
        return vprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vprintf(const char *restrict, va_list)
     * }
     */
    public static MethodHandle vprintf$handle() {
        return vprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vprintf(const char *restrict, va_list)
     * }
     */
    public static MemorySegment vprintf$address() {
        return vprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vprintf(const char *restrict, va_list)
     * }
     */
    public static int vprintf(MemorySegment x0, MemorySegment x1) {
        var mh$ = vprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vprintf", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("vsprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vsprintf(char *restrict, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vsprintf$descriptor() {
        return vsprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vsprintf(char *restrict, const char *restrict, va_list)
     * }
     */
    public static MethodHandle vsprintf$handle() {
        return vsprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vsprintf(char *restrict, const char *restrict, va_list)
     * }
     */
    public static MemorySegment vsprintf$address() {
        return vsprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vsprintf(char *restrict, const char *restrict, va_list)
     * }
     */
    public static int vsprintf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vsprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctermid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ctermid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static FunctionDescriptor ctermid$descriptor() {
        return ctermid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static MethodHandle ctermid$handle() {
        return ctermid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static MemorySegment ctermid$address() {
        return ctermid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static MemorySegment ctermid(MemorySegment x0) {
        var mh$ = ctermid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fdopen(int, const char *) asm("_fdopen")
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fdopen(int, const char *) asm("_fdopen")
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *fdopen(int, const char *) asm("_fdopen")
     * }
     */
    public static MemorySegment fdopen$address() {
        return fdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *fdopen(int, const char *) asm("_fdopen")
     * }
     */
    public static MemorySegment fdopen(int x0, MemorySegment x1) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fileno(FILE *)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fileno(FILE *)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fileno(FILE *)
     * }
     */
    public static MemorySegment fileno$address() {
        return fileno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fileno(FILE *)
     * }
     */
    public static int fileno(MemorySegment x0) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("pclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pclose(FILE *)
     * }
     */
    public static FunctionDescriptor pclose$descriptor() {
        return pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pclose(FILE *)
     * }
     */
    public static MethodHandle pclose$handle() {
        return pclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pclose(FILE *)
     * }
     */
    public static MemorySegment pclose$address() {
        return pclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pclose(FILE *)
     * }
     */
    public static int pclose(MemorySegment x0) {
        var mh$ = pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pclose", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("popen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *popen(const char *, const char *) asm("_popen")
     * }
     */
    public static FunctionDescriptor popen$descriptor() {
        return popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *popen(const char *, const char *) asm("_popen")
     * }
     */
    public static MethodHandle popen$handle() {
        return popen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *popen(const char *, const char *) asm("_popen")
     * }
     */
    public static MemorySegment popen$address() {
        return popen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *popen(const char *, const char *) asm("_popen")
     * }
     */
    public static MemorySegment popen(MemorySegment x0, MemorySegment x1) {
        var mh$ = popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("popen", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __srget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__srget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __srget(FILE *)
     * }
     */
    public static FunctionDescriptor __srget$descriptor() {
        return __srget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __srget(FILE *)
     * }
     */
    public static MethodHandle __srget$handle() {
        return __srget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __srget(FILE *)
     * }
     */
    public static MemorySegment __srget$address() {
        return __srget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __srget(FILE *)
     * }
     */
    public static int __srget(MemorySegment x0) {
        var mh$ = __srget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__srget", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __svfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__svfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __svfscanf(FILE *, const char *, va_list)
     * }
     */
    public static FunctionDescriptor __svfscanf$descriptor() {
        return __svfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __svfscanf(FILE *, const char *, va_list)
     * }
     */
    public static MethodHandle __svfscanf$handle() {
        return __svfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __svfscanf(FILE *, const char *, va_list)
     * }
     */
    public static MemorySegment __svfscanf$address() {
        return __svfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __svfscanf(FILE *, const char *, va_list)
     * }
     */
    public static int __svfscanf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __svfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__svfscanf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __swbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__swbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __swbuf(int, FILE *)
     * }
     */
    public static FunctionDescriptor __swbuf$descriptor() {
        return __swbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __swbuf(int, FILE *)
     * }
     */
    public static MethodHandle __swbuf$handle() {
        return __swbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __swbuf(int, FILE *)
     * }
     */
    public static MemorySegment __swbuf$address() {
        return __swbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __swbuf(int, FILE *)
     * }
     */
    public static int __swbuf(int x0, MemorySegment x1) {
        var mh$ = __swbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__swbuf", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flockfile(FILE *)
     * }
     */
    public static FunctionDescriptor flockfile$descriptor() {
        return flockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flockfile(FILE *)
     * }
     */
    public static MethodHandle flockfile$handle() {
        return flockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flockfile(FILE *)
     * }
     */
    public static MemorySegment flockfile$address() {
        return flockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flockfile(FILE *)
     * }
     */
    public static void flockfile(MemorySegment x0) {
        var mh$ = flockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flockfile", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftrylockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ftrylockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ftrylockfile(FILE *)
     * }
     */
    public static FunctionDescriptor ftrylockfile$descriptor() {
        return ftrylockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ftrylockfile(FILE *)
     * }
     */
    public static MethodHandle ftrylockfile$handle() {
        return ftrylockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ftrylockfile(FILE *)
     * }
     */
    public static MemorySegment ftrylockfile$address() {
        return ftrylockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ftrylockfile(FILE *)
     * }
     */
    public static int ftrylockfile(MemorySegment x0) {
        var mh$ = ftrylockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftrylockfile", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funlockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("funlockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void funlockfile(FILE *)
     * }
     */
    public static FunctionDescriptor funlockfile$descriptor() {
        return funlockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void funlockfile(FILE *)
     * }
     */
    public static MethodHandle funlockfile$handle() {
        return funlockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void funlockfile(FILE *)
     * }
     */
    public static MemorySegment funlockfile$address() {
        return funlockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void funlockfile(FILE *)
     * }
     */
    public static void funlockfile(MemorySegment x0) {
        var mh$ = funlockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funlockfile", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getc_unlocked(FILE *)
     * }
     */
    public static FunctionDescriptor getc_unlocked$descriptor() {
        return getc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getc_unlocked(FILE *)
     * }
     */
    public static MethodHandle getc_unlocked$handle() {
        return getc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getc_unlocked(FILE *)
     * }
     */
    public static MemorySegment getc_unlocked$address() {
        return getc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getc_unlocked(FILE *)
     * }
     */
    public static int getc_unlocked(MemorySegment x0) {
        var mh$ = getc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc_unlocked", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getchar_unlocked(void)
     * }
     */
    public static FunctionDescriptor getchar_unlocked$descriptor() {
        return getchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getchar_unlocked(void)
     * }
     */
    public static MethodHandle getchar_unlocked$handle() {
        return getchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getchar_unlocked(void)
     * }
     */
    public static MemorySegment getchar_unlocked$address() {
        return getchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getchar_unlocked(void)
     * }
     */
    public static int getchar_unlocked() {
        var mh$ = getchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar_unlocked");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putc_unlocked(int, FILE *)
     * }
     */
    public static FunctionDescriptor putc_unlocked$descriptor() {
        return putc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putc_unlocked(int, FILE *)
     * }
     */
    public static MethodHandle putc_unlocked$handle() {
        return putc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putc_unlocked(int, FILE *)
     * }
     */
    public static MemorySegment putc_unlocked$address() {
        return putc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putc_unlocked(int, FILE *)
     * }
     */
    public static int putc_unlocked(int x0, MemorySegment x1) {
        var mh$ = putc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc_unlocked", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putchar_unlocked(int)
     * }
     */
    public static FunctionDescriptor putchar_unlocked$descriptor() {
        return putchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putchar_unlocked(int)
     * }
     */
    public static MethodHandle putchar_unlocked$handle() {
        return putchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putchar_unlocked(int)
     * }
     */
    public static MemorySegment putchar_unlocked$address() {
        return putchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putchar_unlocked(int)
     * }
     */
    public static int putchar_unlocked(int x0) {
        var mh$ = putchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar_unlocked", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getw(FILE *)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getw(FILE *)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getw(FILE *)
     * }
     */
    public static MemorySegment getw$address() {
        return getw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getw(FILE *)
     * }
     */
    public static int getw(MemorySegment x0) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putw(int, FILE *)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putw(int, FILE *)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putw(int, FILE *)
     * }
     */
    public static MemorySegment putw$address() {
        return putw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putw(int, FILE *)
     * }
     */
    public static int putw(int x0, MemorySegment x1) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *tempnam(const char *__dir, const char *__prefix) asm("_tempnam")
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *tempnam(const char *__dir, const char *__prefix) asm("_tempnam")
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *tempnam(const char *__dir, const char *__prefix) asm("_tempnam")
     * }
     */
    public static MemorySegment tempnam$address() {
        return tempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *tempnam(const char *__dir, const char *__prefix) asm("_tempnam")
     * }
     */
    public static MemorySegment tempnam(MemorySegment __dir, MemorySegment __prefix) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", __dir, __prefix);
            }
            return (MemorySegment)mh$.invokeExact(__dir, __prefix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_off_t off_t
     * }
     */
    public static final OfLong off_t = mlx_h.C_LONG_LONG;

    private static class fseeko {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_LONG_LONG,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fseeko");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fseeko(FILE *__stream, off_t __offset, int __whence)
     * }
     */
    public static FunctionDescriptor fseeko$descriptor() {
        return fseeko.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fseeko(FILE *__stream, off_t __offset, int __whence)
     * }
     */
    public static MethodHandle fseeko$handle() {
        return fseeko.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fseeko(FILE *__stream, off_t __offset, int __whence)
     * }
     */
    public static MemorySegment fseeko$address() {
        return fseeko.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fseeko(FILE *__stream, off_t __offset, int __whence)
     * }
     */
    public static int fseeko(MemorySegment __stream, long __offset, int __whence) {
        var mh$ = fseeko.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseeko", __stream, __offset, __whence);
            }
            return (int)mh$.invokeExact(__stream, __offset, __whence);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftello {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG_LONG,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ftello");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * off_t ftello(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftello$descriptor() {
        return ftello.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * off_t ftello(FILE *__stream)
     * }
     */
    public static MethodHandle ftello$handle() {
        return ftello.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * off_t ftello(FILE *__stream)
     * }
     */
    public static MemorySegment ftello$address() {
        return ftello.ADDR;
    }

    /**
     * {@snippet lang=c :
     * off_t ftello(FILE *__stream)
     * }
     */
    public static long ftello(MemorySegment __stream) {
        var mh$ = ftello.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftello", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int snprintf(char *restrict __str, size_t __size, const char *restrict __format, ...)
     * }
     */
    public static class snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_h.C_INT,
                mlx_h.C_POINTER,
                mlx_h.C_LONG,
                mlx_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int snprintf(char *restrict __str, size_t __size, const char *restrict __format, ...)
         * }
         */
        public static snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __str, long __size, MemorySegment __format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("snprintf", __str, __size, __format, x3);
                }
                return (int) spreader.invokeExact(__str, __size, __format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("vfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vfscanf(FILE *restrict __stream, const char *restrict __format, va_list)
     * }
     */
    public static FunctionDescriptor vfscanf$descriptor() {
        return vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vfscanf(FILE *restrict __stream, const char *restrict __format, va_list)
     * }
     */
    public static MethodHandle vfscanf$handle() {
        return vfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vfscanf(FILE *restrict __stream, const char *restrict __format, va_list)
     * }
     */
    public static MemorySegment vfscanf$address() {
        return vfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vfscanf(FILE *restrict __stream, const char *restrict __format, va_list)
     * }
     */
    public static int vfscanf(MemorySegment __stream, MemorySegment __format, MemorySegment x2) {
        var mh$ = vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfscanf", __stream, __format, x2);
            }
            return (int)mh$.invokeExact(__stream, __format, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("vscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vscanf(const char *restrict __format, va_list)
     * }
     */
    public static FunctionDescriptor vscanf$descriptor() {
        return vscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vscanf(const char *restrict __format, va_list)
     * }
     */
    public static MethodHandle vscanf$handle() {
        return vscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vscanf(const char *restrict __format, va_list)
     * }
     */
    public static MemorySegment vscanf$address() {
        return vscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vscanf(const char *restrict __format, va_list)
     * }
     */
    public static int vscanf(MemorySegment __format, MemorySegment x1) {
        var mh$ = vscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vscanf", __format, x1);
            }
            return (int)mh$.invokeExact(__format, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsnprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("vsnprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vsnprintf(char *restrict __str, size_t __size, const char *restrict __format, va_list)
     * }
     */
    public static FunctionDescriptor vsnprintf$descriptor() {
        return vsnprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vsnprintf(char *restrict __str, size_t __size, const char *restrict __format, va_list)
     * }
     */
    public static MethodHandle vsnprintf$handle() {
        return vsnprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vsnprintf(char *restrict __str, size_t __size, const char *restrict __format, va_list)
     * }
     */
    public static MemorySegment vsnprintf$address() {
        return vsnprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vsnprintf(char *restrict __str, size_t __size, const char *restrict __format, va_list)
     * }
     */
    public static int vsnprintf(MemorySegment __str, long __size, MemorySegment __format, MemorySegment x3) {
        var mh$ = vsnprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsnprintf", __str, __size, __format, x3);
            }
            return (int)mh$.invokeExact(__str, __size, __format, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("vsscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vsscanf(const char *restrict __str, const char *restrict __format, va_list)
     * }
     */
    public static FunctionDescriptor vsscanf$descriptor() {
        return vsscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vsscanf(const char *restrict __str, const char *restrict __format, va_list)
     * }
     */
    public static MethodHandle vsscanf$handle() {
        return vsscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vsscanf(const char *restrict __str, const char *restrict __format, va_list)
     * }
     */
    public static MemorySegment vsscanf$address() {
        return vsscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vsscanf(const char *restrict __str, const char *restrict __format, va_list)
     * }
     */
    public static int vsscanf(MemorySegment __str, MemorySegment __format, MemorySegment x2) {
        var mh$ = vsscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsscanf", __str, __format, x2);
            }
            return (int)mh$.invokeExact(__str, __format, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = mlx_h.C_LONG;

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int dprintf(int, const char *restrict, ...)
     * }
     */
    public static class dprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_h.C_INT,
                mlx_h.C_INT,
                mlx_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("dprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private dprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int dprintf(int, const char *restrict, ...)
         * }
         */
        public static dprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new dprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("dprintf", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vdprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("vdprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vdprintf(int, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vdprintf$descriptor() {
        return vdprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vdprintf(int, const char *restrict, va_list)
     * }
     */
    public static MethodHandle vdprintf$handle() {
        return vdprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vdprintf(int, const char *restrict, va_list)
     * }
     */
    public static MemorySegment vdprintf$address() {
        return vdprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vdprintf(int, const char *restrict, va_list)
     * }
     */
    public static int vdprintf(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vdprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vdprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t getdelim(char **restrict __linep, size_t *restrict __linecapp, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getdelim$descriptor() {
        return getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t getdelim(char **restrict __linep, size_t *restrict __linecapp, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getdelim$handle() {
        return getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t getdelim(char **restrict __linep, size_t *restrict __linecapp, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getdelim$address() {
        return getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t getdelim(char **restrict __linep, size_t *restrict __linecapp, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long getdelim(MemorySegment __linep, MemorySegment __linecapp, int __delimiter, MemorySegment __stream) {
        var mh$ = getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdelim", __linep, __linecapp, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__linep, __linecapp, __delimiter, __stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t getline(char **restrict __linep, size_t *restrict __linecapp, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getline$descriptor() {
        return getline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t getline(char **restrict __linep, size_t *restrict __linecapp, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getline$handle() {
        return getline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t getline(char **restrict __linep, size_t *restrict __linecapp, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getline$address() {
        return getline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t getline(char **restrict __linep, size_t *restrict __linecapp, FILE *restrict __stream)
     * }
     */
    public static long getline(MemorySegment __linep, MemorySegment __linecapp, MemorySegment __stream) {
        var mh$ = getline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getline", __linep, __linecapp, __stream);
            }
            return (long)mh$.invokeExact(__linep, __linecapp, __stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmemopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fmemopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fmemopen(void *restrict __buf, size_t __size, const char *restrict __mode)
     * }
     */
    public static FunctionDescriptor fmemopen$descriptor() {
        return fmemopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fmemopen(void *restrict __buf, size_t __size, const char *restrict __mode)
     * }
     */
    public static MethodHandle fmemopen$handle() {
        return fmemopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *fmemopen(void *restrict __buf, size_t __size, const char *restrict __mode)
     * }
     */
    public static MemorySegment fmemopen$address() {
        return fmemopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *fmemopen(void *restrict __buf, size_t __size, const char *restrict __mode)
     * }
     */
    public static MemorySegment fmemopen(MemorySegment __buf, long __size, MemorySegment __mode) {
        var mh$ = fmemopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmemopen", __buf, __size, __mode);
            }
            return (MemorySegment)mh$.invokeExact(__buf, __size, __mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class open_memstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("open_memstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *open_memstream(char **__bufp, size_t *__sizep)
     * }
     */
    public static FunctionDescriptor open_memstream$descriptor() {
        return open_memstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *open_memstream(char **__bufp, size_t *__sizep)
     * }
     */
    public static MethodHandle open_memstream$handle() {
        return open_memstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *open_memstream(char **__bufp, size_t *__sizep)
     * }
     */
    public static MemorySegment open_memstream$address() {
        return open_memstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *open_memstream(char **__bufp, size_t *__sizep)
     * }
     */
    public static MemorySegment open_memstream(MemorySegment __bufp, MemorySegment __sizep) {
        var mh$ = open_memstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("open_memstream", __bufp, __sizep);
            }
            return (MemorySegment)mh$.invokeExact(__bufp, __sizep);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sys_nerr$constants {
        public static final OfInt LAYOUT = mlx_h.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("sys_nerr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const int sys_nerr
     * }
     */
    public static OfInt sys_nerr$layout() {
        return sys_nerr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const int sys_nerr
     * }
     */
    public static MemorySegment sys_nerr$segment() {
        return sys_nerr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const int sys_nerr
     * }
     */
    public static int sys_nerr() {
        return sys_nerr$constants.SEGMENT.get(sys_nerr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const int sys_nerr
     * }
     */
    public static void sys_nerr(int varValue) {
        sys_nerr$constants.SEGMENT.set(sys_nerr$constants.LAYOUT, 0L, varValue);
    }

    private static class sys_errlist$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, mlx_h.C_POINTER);
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("sys_errlist").reinterpret(LAYOUT.byteSize());
    public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {  };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static SequenceLayout sys_errlist$layout() {
        return sys_errlist$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static long[] sys_errlist$dimensions() {
        return sys_errlist$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static MemorySegment sys_errlist() {
        return sys_errlist$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static void sys_errlist(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, sys_errlist$constants.SEGMENT, 0L, sys_errlist$constants.LAYOUT.byteSize());
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int asprintf(char **restrict, const char *restrict, ...)
     * }
     */
    public static class asprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_h.C_INT,
                mlx_h.C_POINTER,
                mlx_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("asprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private asprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int asprintf(char **restrict, const char *restrict, ...)
         * }
         */
        public static asprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new asprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("asprintf", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class ctermid_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ctermid_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctermid_r(char *)
     * }
     */
    public static FunctionDescriptor ctermid_r$descriptor() {
        return ctermid_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctermid_r(char *)
     * }
     */
    public static MethodHandle ctermid_r$handle() {
        return ctermid_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctermid_r(char *)
     * }
     */
    public static MemorySegment ctermid_r$address() {
        return ctermid_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctermid_r(char *)
     * }
     */
    public static MemorySegment ctermid_r(MemorySegment x0) {
        var mh$ = ctermid_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid_r", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetln {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fgetln");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fgetln(FILE *, size_t *__len)
     * }
     */
    public static FunctionDescriptor fgetln$descriptor() {
        return fgetln.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fgetln(FILE *, size_t *__len)
     * }
     */
    public static MethodHandle fgetln$handle() {
        return fgetln.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fgetln(FILE *, size_t *__len)
     * }
     */
    public static MemorySegment fgetln$address() {
        return fgetln.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fgetln(FILE *, size_t *__len)
     * }
     */
    public static MemorySegment fgetln(MemorySegment x0, MemorySegment __len) {
        var mh$ = fgetln.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetln", x0, __len);
            }
            return (MemorySegment)mh$.invokeExact(x0, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmtcheck {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fmtcheck");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *fmtcheck(const char *, const char *)
     * }
     */
    public static FunctionDescriptor fmtcheck$descriptor() {
        return fmtcheck.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *fmtcheck(const char *, const char *)
     * }
     */
    public static MethodHandle fmtcheck$handle() {
        return fmtcheck.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *fmtcheck(const char *, const char *)
     * }
     */
    public static MemorySegment fmtcheck$address() {
        return fmtcheck.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *fmtcheck(const char *, const char *)
     * }
     */
    public static MemorySegment fmtcheck(MemorySegment x0, MemorySegment x1) {
        var mh$ = fmtcheck.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmtcheck", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fpurge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fpurge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fpurge(FILE *)
     * }
     */
    public static FunctionDescriptor fpurge$descriptor() {
        return fpurge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fpurge(FILE *)
     * }
     */
    public static MethodHandle fpurge$handle() {
        return fpurge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fpurge(FILE *)
     * }
     */
    public static MemorySegment fpurge$address() {
        return fpurge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fpurge(FILE *)
     * }
     */
    public static int fpurge(MemorySegment x0) {
        var mh$ = fpurge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fpurge", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setbuffer(FILE *, char *, int __size)
     * }
     */
    public static FunctionDescriptor setbuffer$descriptor() {
        return setbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setbuffer(FILE *, char *, int __size)
     * }
     */
    public static MethodHandle setbuffer$handle() {
        return setbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setbuffer(FILE *, char *, int __size)
     * }
     */
    public static MemorySegment setbuffer$address() {
        return setbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setbuffer(FILE *, char *, int __size)
     * }
     */
    public static void setbuffer(MemorySegment x0, MemorySegment x1, int __size) {
        var mh$ = setbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuffer", x0, x1, __size);
            }
            mh$.invokeExact(x0, x1, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlinebuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setlinebuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setlinebuf(FILE *)
     * }
     */
    public static FunctionDescriptor setlinebuf$descriptor() {
        return setlinebuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setlinebuf(FILE *)
     * }
     */
    public static MethodHandle setlinebuf$handle() {
        return setlinebuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setlinebuf(FILE *)
     * }
     */
    public static MemorySegment setlinebuf$address() {
        return setlinebuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setlinebuf(FILE *)
     * }
     */
    public static int setlinebuf(MemorySegment x0) {
        var mh$ = setlinebuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlinebuf", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vasprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("vasprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vasprintf(char **restrict, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vasprintf$descriptor() {
        return vasprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vasprintf(char **restrict, const char *restrict, va_list)
     * }
     */
    public static MethodHandle vasprintf$handle() {
        return vasprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vasprintf(char **restrict, const char *restrict, va_list)
     * }
     */
    public static MemorySegment vasprintf$address() {
        return vasprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vasprintf(char **restrict, const char *restrict, va_list)
     * }
     */
    public static int vasprintf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vasprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vasprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("funopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *funopen(const void *, int (* _Nullable)(void *, char *, int), int (* _Nullable)(void *, const char *, int), fpos_t (* _Nullable)(void *, fpos_t, int), int (* _Nullable)(void *))
     * }
     */
    public static FunctionDescriptor funopen$descriptor() {
        return funopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *funopen(const void *, int (* _Nullable)(void *, char *, int), int (* _Nullable)(void *, const char *, int), fpos_t (* _Nullable)(void *, fpos_t, int), int (* _Nullable)(void *))
     * }
     */
    public static MethodHandle funopen$handle() {
        return funopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *funopen(const void *, int (* _Nullable)(void *, char *, int), int (* _Nullable)(void *, const char *, int), fpos_t (* _Nullable)(void *, fpos_t, int), int (* _Nullable)(void *))
     * }
     */
    public static MemorySegment funopen$address() {
        return funopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *funopen(const void *, int (* _Nullable)(void *, char *, int), int (* _Nullable)(void *, const char *, int), fpos_t (* _Nullable)(void *, fpos_t, int), int (* _Nullable)(void *))
     * }
     */
    public static MemorySegment funopen(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = funopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funopen", x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int __sprintf_chk(char *restrict, int, size_t, const char *restrict, ...)
     * }
     */
    public static class __sprintf_chk {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_h.C_INT,
                mlx_h.C_POINTER,
                mlx_h.C_INT,
                mlx_h.C_LONG,
                mlx_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__sprintf_chk");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __sprintf_chk(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int __sprintf_chk(char *restrict, int, size_t, const char *restrict, ...)
         * }
         */
        public static __sprintf_chk makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __sprintf_chk(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, int x1, long x2, MemorySegment x3, Object... x4) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__sprintf_chk", x0, x1, x2, x3, x4);
                }
                return (int) spreader.invokeExact(x0, x1, x2, x3, x4);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int __snprintf_chk(char *restrict, size_t __maxlen, int, size_t, const char *restrict, ...)
     * }
     */
    public static class __snprintf_chk {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_h.C_INT,
                mlx_h.C_POINTER,
                mlx_h.C_LONG,
                mlx_h.C_INT,
                mlx_h.C_LONG,
                mlx_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__snprintf_chk");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __snprintf_chk(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int __snprintf_chk(char *restrict, size_t __maxlen, int, size_t, const char *restrict, ...)
         * }
         */
        public static __snprintf_chk makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __snprintf_chk(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, long __maxlen, int x2, long x3, MemorySegment x4, Object... x5) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__snprintf_chk", x0, __maxlen, x2, x3, x4, x5);
                }
                return (int) spreader.invokeExact(x0, __maxlen, x2, x3, x4, x5);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class __vsprintf_chk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_INT,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__vsprintf_chk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __vsprintf_chk(char *restrict, int, size_t, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor __vsprintf_chk$descriptor() {
        return __vsprintf_chk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __vsprintf_chk(char *restrict, int, size_t, const char *restrict, va_list)
     * }
     */
    public static MethodHandle __vsprintf_chk$handle() {
        return __vsprintf_chk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __vsprintf_chk(char *restrict, int, size_t, const char *restrict, va_list)
     * }
     */
    public static MemorySegment __vsprintf_chk$address() {
        return __vsprintf_chk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __vsprintf_chk(char *restrict, int, size_t, const char *restrict, va_list)
     * }
     */
    public static int __vsprintf_chk(MemorySegment x0, int x1, long x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = __vsprintf_chk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__vsprintf_chk", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __vsnprintf_chk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_INT,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__vsnprintf_chk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __vsnprintf_chk(char *restrict, size_t __maxlen, int, size_t, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor __vsnprintf_chk$descriptor() {
        return __vsnprintf_chk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __vsnprintf_chk(char *restrict, size_t __maxlen, int, size_t, const char *restrict, va_list)
     * }
     */
    public static MethodHandle __vsnprintf_chk$handle() {
        return __vsnprintf_chk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __vsnprintf_chk(char *restrict, size_t __maxlen, int, size_t, const char *restrict, va_list)
     * }
     */
    public static MemorySegment __vsnprintf_chk$address() {
        return __vsnprintf_chk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __vsnprintf_chk(char *restrict, size_t __maxlen, int, size_t, const char *restrict, va_list)
     * }
     */
    public static int __vsnprintf_chk(MemorySegment x0, long __maxlen, int x2, long x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = __vsnprintf_chk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__vsnprintf_chk", x0, __maxlen, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, __maxlen, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_distributed_group_rank {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_distributed_group_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_distributed_group_rank");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_distributed_group_rank(mlx_distributed_group group)
     * }
     */
    public static FunctionDescriptor mlx_distributed_group_rank$descriptor() {
        return mlx_distributed_group_rank.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_distributed_group_rank(mlx_distributed_group group)
     * }
     */
    public static MethodHandle mlx_distributed_group_rank$handle() {
        return mlx_distributed_group_rank.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_distributed_group_rank(mlx_distributed_group group)
     * }
     */
    public static MemorySegment mlx_distributed_group_rank$address() {
        return mlx_distributed_group_rank.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_distributed_group_rank(mlx_distributed_group group)
     * }
     */
    public static int mlx_distributed_group_rank(MemorySegment group) {
        var mh$ = mlx_distributed_group_rank.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_distributed_group_rank", group);
            }
            return (int)mh$.invokeExact(group);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_distributed_group_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_distributed_group_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_distributed_group_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_distributed_group_size(mlx_distributed_group group)
     * }
     */
    public static FunctionDescriptor mlx_distributed_group_size$descriptor() {
        return mlx_distributed_group_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_distributed_group_size(mlx_distributed_group group)
     * }
     */
    public static MethodHandle mlx_distributed_group_size$handle() {
        return mlx_distributed_group_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_distributed_group_size(mlx_distributed_group group)
     * }
     */
    public static MemorySegment mlx_distributed_group_size$address() {
        return mlx_distributed_group_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_distributed_group_size(mlx_distributed_group group)
     * }
     */
    public static int mlx_distributed_group_size(MemorySegment group) {
        var mh$ = mlx_distributed_group_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_distributed_group_size", group);
            }
            return (int)mh$.invokeExact(group);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_distributed_group_split {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_distributed_group_.layout(),
            mlx_distributed_group_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_distributed_group_split");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_distributed_group mlx_distributed_group_split(mlx_distributed_group group, int color, int key)
     * }
     */
    public static FunctionDescriptor mlx_distributed_group_split$descriptor() {
        return mlx_distributed_group_split.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_distributed_group mlx_distributed_group_split(mlx_distributed_group group, int color, int key)
     * }
     */
    public static MethodHandle mlx_distributed_group_split$handle() {
        return mlx_distributed_group_split.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_distributed_group mlx_distributed_group_split(mlx_distributed_group group, int color, int key)
     * }
     */
    public static MemorySegment mlx_distributed_group_split$address() {
        return mlx_distributed_group_split.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_distributed_group mlx_distributed_group_split(mlx_distributed_group group, int color, int key)
     * }
     */
    public static MemorySegment mlx_distributed_group_split(SegmentAllocator allocator, MemorySegment group, int color, int key) {
        var mh$ = mlx_distributed_group_split.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_distributed_group_split", allocator, group, color, key);
            }
            return (MemorySegment)mh$.invokeExact(allocator, group, color, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * bool mlx_distributed_is_available()
     * }
     */
    public static class mlx_distributed_is_available {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_h.C_BOOL        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_distributed_is_available");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private mlx_distributed_is_available(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * bool mlx_distributed_is_available()
         * }
         */
        public static mlx_distributed_is_available makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new mlx_distributed_is_available(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public boolean apply(Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("mlx_distributed_is_available", x0);
                }
                return (boolean) spreader.invokeExact(x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class mlx_distributed_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_distributed_group_.layout(),
            mlx_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_distributed_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_distributed_group mlx_distributed_init(bool strict)
     * }
     */
    public static FunctionDescriptor mlx_distributed_init$descriptor() {
        return mlx_distributed_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_distributed_group mlx_distributed_init(bool strict)
     * }
     */
    public static MethodHandle mlx_distributed_init$handle() {
        return mlx_distributed_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_distributed_group mlx_distributed_init(bool strict)
     * }
     */
    public static MemorySegment mlx_distributed_init$address() {
        return mlx_distributed_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_distributed_group mlx_distributed_init(bool strict)
     * }
     */
    public static MemorySegment mlx_distributed_init(SegmentAllocator allocator, boolean strict) {
        var mh$ = mlx_distributed_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_distributed_init", allocator, strict);
            }
            return (MemorySegment)mh$.invokeExact(allocator, strict);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_io_reader_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_io_reader_.layout(),
            mlx_h.C_POINTER,
            mlx_io_vtable_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_io_reader_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_io_reader mlx_io_reader_new(void *desc, mlx_io_vtable vtable)
     * }
     */
    public static FunctionDescriptor mlx_io_reader_new$descriptor() {
        return mlx_io_reader_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_io_reader mlx_io_reader_new(void *desc, mlx_io_vtable vtable)
     * }
     */
    public static MethodHandle mlx_io_reader_new$handle() {
        return mlx_io_reader_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_io_reader mlx_io_reader_new(void *desc, mlx_io_vtable vtable)
     * }
     */
    public static MemorySegment mlx_io_reader_new$address() {
        return mlx_io_reader_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_io_reader mlx_io_reader_new(void *desc, mlx_io_vtable vtable)
     * }
     */
    public static MemorySegment mlx_io_reader_new(SegmentAllocator allocator, MemorySegment desc, MemorySegment vtable) {
        var mh$ = mlx_io_reader_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_io_reader_new", allocator, desc, vtable);
            }
            return (MemorySegment)mh$.invokeExact(allocator, desc, vtable);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_io_reader_descriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_io_reader_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_io_reader_descriptor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_io_reader_descriptor(void **desc_, mlx_io_reader io)
     * }
     */
    public static FunctionDescriptor mlx_io_reader_descriptor$descriptor() {
        return mlx_io_reader_descriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_io_reader_descriptor(void **desc_, mlx_io_reader io)
     * }
     */
    public static MethodHandle mlx_io_reader_descriptor$handle() {
        return mlx_io_reader_descriptor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_io_reader_descriptor(void **desc_, mlx_io_reader io)
     * }
     */
    public static MemorySegment mlx_io_reader_descriptor$address() {
        return mlx_io_reader_descriptor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_io_reader_descriptor(void **desc_, mlx_io_reader io)
     * }
     */
    public static int mlx_io_reader_descriptor(MemorySegment desc_, MemorySegment io) {
        var mh$ = mlx_io_reader_descriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_io_reader_descriptor", desc_, io);
            }
            return (int)mh$.invokeExact(desc_, io);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_io_reader_tostring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_io_reader_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_io_reader_tostring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_io_reader_tostring(mlx_string *str_, mlx_io_reader io)
     * }
     */
    public static FunctionDescriptor mlx_io_reader_tostring$descriptor() {
        return mlx_io_reader_tostring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_io_reader_tostring(mlx_string *str_, mlx_io_reader io)
     * }
     */
    public static MethodHandle mlx_io_reader_tostring$handle() {
        return mlx_io_reader_tostring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_io_reader_tostring(mlx_string *str_, mlx_io_reader io)
     * }
     */
    public static MemorySegment mlx_io_reader_tostring$address() {
        return mlx_io_reader_tostring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_io_reader_tostring(mlx_string *str_, mlx_io_reader io)
     * }
     */
    public static int mlx_io_reader_tostring(MemorySegment str_, MemorySegment io) {
        var mh$ = mlx_io_reader_tostring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_io_reader_tostring", str_, io);
            }
            return (int)mh$.invokeExact(str_, io);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_io_reader_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_io_reader_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_io_reader_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_io_reader_free(mlx_io_reader io)
     * }
     */
    public static FunctionDescriptor mlx_io_reader_free$descriptor() {
        return mlx_io_reader_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_io_reader_free(mlx_io_reader io)
     * }
     */
    public static MethodHandle mlx_io_reader_free$handle() {
        return mlx_io_reader_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_io_reader_free(mlx_io_reader io)
     * }
     */
    public static MemorySegment mlx_io_reader_free$address() {
        return mlx_io_reader_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_io_reader_free(mlx_io_reader io)
     * }
     */
    public static int mlx_io_reader_free(MemorySegment io) {
        var mh$ = mlx_io_reader_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_io_reader_free", io);
            }
            return (int)mh$.invokeExact(io);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_io_writer_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_io_writer_.layout(),
            mlx_h.C_POINTER,
            mlx_io_vtable_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_io_writer_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_io_writer mlx_io_writer_new(void *desc, mlx_io_vtable vtable)
     * }
     */
    public static FunctionDescriptor mlx_io_writer_new$descriptor() {
        return mlx_io_writer_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_io_writer mlx_io_writer_new(void *desc, mlx_io_vtable vtable)
     * }
     */
    public static MethodHandle mlx_io_writer_new$handle() {
        return mlx_io_writer_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_io_writer mlx_io_writer_new(void *desc, mlx_io_vtable vtable)
     * }
     */
    public static MemorySegment mlx_io_writer_new$address() {
        return mlx_io_writer_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_io_writer mlx_io_writer_new(void *desc, mlx_io_vtable vtable)
     * }
     */
    public static MemorySegment mlx_io_writer_new(SegmentAllocator allocator, MemorySegment desc, MemorySegment vtable) {
        var mh$ = mlx_io_writer_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_io_writer_new", allocator, desc, vtable);
            }
            return (MemorySegment)mh$.invokeExact(allocator, desc, vtable);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_io_writer_descriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_io_writer_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_io_writer_descriptor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_io_writer_descriptor(void **desc_, mlx_io_writer io)
     * }
     */
    public static FunctionDescriptor mlx_io_writer_descriptor$descriptor() {
        return mlx_io_writer_descriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_io_writer_descriptor(void **desc_, mlx_io_writer io)
     * }
     */
    public static MethodHandle mlx_io_writer_descriptor$handle() {
        return mlx_io_writer_descriptor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_io_writer_descriptor(void **desc_, mlx_io_writer io)
     * }
     */
    public static MemorySegment mlx_io_writer_descriptor$address() {
        return mlx_io_writer_descriptor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_io_writer_descriptor(void **desc_, mlx_io_writer io)
     * }
     */
    public static int mlx_io_writer_descriptor(MemorySegment desc_, MemorySegment io) {
        var mh$ = mlx_io_writer_descriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_io_writer_descriptor", desc_, io);
            }
            return (int)mh$.invokeExact(desc_, io);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_io_writer_tostring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_io_writer_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_io_writer_tostring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_io_writer_tostring(mlx_string *str_, mlx_io_writer io)
     * }
     */
    public static FunctionDescriptor mlx_io_writer_tostring$descriptor() {
        return mlx_io_writer_tostring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_io_writer_tostring(mlx_string *str_, mlx_io_writer io)
     * }
     */
    public static MethodHandle mlx_io_writer_tostring$handle() {
        return mlx_io_writer_tostring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_io_writer_tostring(mlx_string *str_, mlx_io_writer io)
     * }
     */
    public static MemorySegment mlx_io_writer_tostring$address() {
        return mlx_io_writer_tostring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_io_writer_tostring(mlx_string *str_, mlx_io_writer io)
     * }
     */
    public static int mlx_io_writer_tostring(MemorySegment str_, MemorySegment io) {
        var mh$ = mlx_io_writer_tostring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_io_writer_tostring", str_, io);
            }
            return (int)mh$.invokeExact(str_, io);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_io_writer_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_io_writer_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_io_writer_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_io_writer_free(mlx_io_writer io)
     * }
     */
    public static FunctionDescriptor mlx_io_writer_free$descriptor() {
        return mlx_io_writer_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_io_writer_free(mlx_io_writer io)
     * }
     */
    public static MethodHandle mlx_io_writer_free$handle() {
        return mlx_io_writer_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_io_writer_free(mlx_io_writer io)
     * }
     */
    public static MemorySegment mlx_io_writer_free$address() {
        return mlx_io_writer_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_io_writer_free(mlx_io_writer io)
     * }
     */
    public static int mlx_io_writer_free(MemorySegment io) {
        var mh$ = mlx_io_writer_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_io_writer_free", io);
            }
            return (int)mh$.invokeExact(io);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int MLX_COMPILE_MODE_DISABLED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum mlx_compile_mode_.MLX_COMPILE_MODE_DISABLED = 0
     * }
     */
    public static int MLX_COMPILE_MODE_DISABLED() {
        return MLX_COMPILE_MODE_DISABLED;
    }
    private static final int MLX_COMPILE_MODE_NO_SIMPLIFY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum mlx_compile_mode_.MLX_COMPILE_MODE_NO_SIMPLIFY = 1
     * }
     */
    public static int MLX_COMPILE_MODE_NO_SIMPLIFY() {
        return MLX_COMPILE_MODE_NO_SIMPLIFY;
    }
    private static final int MLX_COMPILE_MODE_NO_FUSE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum mlx_compile_mode_.MLX_COMPILE_MODE_NO_FUSE = 2
     * }
     */
    public static int MLX_COMPILE_MODE_NO_FUSE() {
        return MLX_COMPILE_MODE_NO_FUSE;
    }
    private static final int MLX_COMPILE_MODE_ENABLED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum mlx_compile_mode_.MLX_COMPILE_MODE_ENABLED = 3
     * }
     */
    public static int MLX_COMPILE_MODE_ENABLED() {
        return MLX_COMPILE_MODE_ENABLED;
    }

    private static class mlx_compile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_closure_.layout(),
            mlx_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_compile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_compile(mlx_closure *res, const mlx_closure fun, bool shapeless)
     * }
     */
    public static FunctionDescriptor mlx_compile$descriptor() {
        return mlx_compile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_compile(mlx_closure *res, const mlx_closure fun, bool shapeless)
     * }
     */
    public static MethodHandle mlx_compile$handle() {
        return mlx_compile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_compile(mlx_closure *res, const mlx_closure fun, bool shapeless)
     * }
     */
    public static MemorySegment mlx_compile$address() {
        return mlx_compile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_compile(mlx_closure *res, const mlx_closure fun, bool shapeless)
     * }
     */
    public static int mlx_compile(MemorySegment res, MemorySegment fun, boolean shapeless) {
        var mh$ = mlx_compile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_compile", res, fun, shapeless);
            }
            return (int)mh$.invokeExact(res, fun, shapeless);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_detail_compile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_closure_.layout(),
            mlx_h.C_LONG,
            mlx_h.C_BOOL,
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_detail_compile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_detail_compile(mlx_closure *res, const mlx_closure fun, uintptr_t fun_id, bool shapeless, const uint64_t *constants, size_t constants_num)
     * }
     */
    public static FunctionDescriptor mlx_detail_compile$descriptor() {
        return mlx_detail_compile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_detail_compile(mlx_closure *res, const mlx_closure fun, uintptr_t fun_id, bool shapeless, const uint64_t *constants, size_t constants_num)
     * }
     */
    public static MethodHandle mlx_detail_compile$handle() {
        return mlx_detail_compile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_detail_compile(mlx_closure *res, const mlx_closure fun, uintptr_t fun_id, bool shapeless, const uint64_t *constants, size_t constants_num)
     * }
     */
    public static MemorySegment mlx_detail_compile$address() {
        return mlx_detail_compile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_detail_compile(mlx_closure *res, const mlx_closure fun, uintptr_t fun_id, bool shapeless, const uint64_t *constants, size_t constants_num)
     * }
     */
    public static int mlx_detail_compile(MemorySegment res, MemorySegment fun, long fun_id, boolean shapeless, MemorySegment constants, long constants_num) {
        var mh$ = mlx_detail_compile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_detail_compile", res, fun, fun_id, shapeless, constants, constants_num);
            }
            return (int)mh$.invokeExact(res, fun, fun_id, shapeless, constants, constants_num);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int mlx_detail_compile_clear_cache()
     * }
     */
    public static class mlx_detail_compile_clear_cache {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_h.C_INT        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_detail_compile_clear_cache");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private mlx_detail_compile_clear_cache(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int mlx_detail_compile_clear_cache()
         * }
         */
        public static mlx_detail_compile_clear_cache makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new mlx_detail_compile_clear_cache(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("mlx_detail_compile_clear_cache", x0);
                }
                return (int) spreader.invokeExact(x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class mlx_detail_compile_erase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_detail_compile_erase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_detail_compile_erase(uintptr_t fun_id)
     * }
     */
    public static FunctionDescriptor mlx_detail_compile_erase$descriptor() {
        return mlx_detail_compile_erase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_detail_compile_erase(uintptr_t fun_id)
     * }
     */
    public static MethodHandle mlx_detail_compile_erase$handle() {
        return mlx_detail_compile_erase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_detail_compile_erase(uintptr_t fun_id)
     * }
     */
    public static MemorySegment mlx_detail_compile_erase$address() {
        return mlx_detail_compile_erase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_detail_compile_erase(uintptr_t fun_id)
     * }
     */
    public static int mlx_detail_compile_erase(long fun_id) {
        var mh$ = mlx_detail_compile_erase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_detail_compile_erase", fun_id);
            }
            return (int)mh$.invokeExact(fun_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int mlx_disable_compile()
     * }
     */
    public static class mlx_disable_compile {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_h.C_INT        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_disable_compile");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private mlx_disable_compile(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int mlx_disable_compile()
         * }
         */
        public static mlx_disable_compile makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new mlx_disable_compile(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("mlx_disable_compile", x0);
                }
                return (int) spreader.invokeExact(x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int mlx_enable_compile()
     * }
     */
    public static class mlx_enable_compile {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_h.C_INT        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_enable_compile");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private mlx_enable_compile(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int mlx_enable_compile()
         * }
         */
        public static mlx_enable_compile makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new mlx_enable_compile(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("mlx_enable_compile", x0);
                }
                return (int) spreader.invokeExact(x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class mlx_set_compile_mode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_set_compile_mode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_set_compile_mode(mlx_compile_mode mode)
     * }
     */
    public static FunctionDescriptor mlx_set_compile_mode$descriptor() {
        return mlx_set_compile_mode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_set_compile_mode(mlx_compile_mode mode)
     * }
     */
    public static MethodHandle mlx_set_compile_mode$handle() {
        return mlx_set_compile_mode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_set_compile_mode(mlx_compile_mode mode)
     * }
     */
    public static MemorySegment mlx_set_compile_mode$address() {
        return mlx_set_compile_mode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_set_compile_mode(mlx_compile_mode mode)
     * }
     */
    public static int mlx_set_compile_mode(int mode) {
        var mh$ = mlx_set_compile_mode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_set_compile_mode", mode);
            }
            return (int)mh$.invokeExact(mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_distributed_all_gather {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_distributed_group_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_distributed_all_gather");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_distributed_all_gather(mlx_array *res, const mlx_array x, const mlx_distributed_group group, const mlx_stream S)
     * }
     */
    public static FunctionDescriptor mlx_distributed_all_gather$descriptor() {
        return mlx_distributed_all_gather.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_distributed_all_gather(mlx_array *res, const mlx_array x, const mlx_distributed_group group, const mlx_stream S)
     * }
     */
    public static MethodHandle mlx_distributed_all_gather$handle() {
        return mlx_distributed_all_gather.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_distributed_all_gather(mlx_array *res, const mlx_array x, const mlx_distributed_group group, const mlx_stream S)
     * }
     */
    public static MemorySegment mlx_distributed_all_gather$address() {
        return mlx_distributed_all_gather.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_distributed_all_gather(mlx_array *res, const mlx_array x, const mlx_distributed_group group, const mlx_stream S)
     * }
     */
    public static int mlx_distributed_all_gather(MemorySegment res, MemorySegment x, MemorySegment group, MemorySegment S) {
        var mh$ = mlx_distributed_all_gather.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_distributed_all_gather", res, x, group, S);
            }
            return (int)mh$.invokeExact(res, x, group, S);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_distributed_all_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_distributed_group_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_distributed_all_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_distributed_all_max(mlx_array *res, const mlx_array x, const mlx_distributed_group group, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_distributed_all_max$descriptor() {
        return mlx_distributed_all_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_distributed_all_max(mlx_array *res, const mlx_array x, const mlx_distributed_group group, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_distributed_all_max$handle() {
        return mlx_distributed_all_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_distributed_all_max(mlx_array *res, const mlx_array x, const mlx_distributed_group group, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_distributed_all_max$address() {
        return mlx_distributed_all_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_distributed_all_max(mlx_array *res, const mlx_array x, const mlx_distributed_group group, const mlx_stream s)
     * }
     */
    public static int mlx_distributed_all_max(MemorySegment res, MemorySegment x, MemorySegment group, MemorySegment s) {
        var mh$ = mlx_distributed_all_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_distributed_all_max", res, x, group, s);
            }
            return (int)mh$.invokeExact(res, x, group, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_distributed_all_min {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_distributed_group_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_distributed_all_min");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_distributed_all_min(mlx_array *res, const mlx_array x, const mlx_distributed_group group, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_distributed_all_min$descriptor() {
        return mlx_distributed_all_min.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_distributed_all_min(mlx_array *res, const mlx_array x, const mlx_distributed_group group, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_distributed_all_min$handle() {
        return mlx_distributed_all_min.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_distributed_all_min(mlx_array *res, const mlx_array x, const mlx_distributed_group group, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_distributed_all_min$address() {
        return mlx_distributed_all_min.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_distributed_all_min(mlx_array *res, const mlx_array x, const mlx_distributed_group group, const mlx_stream s)
     * }
     */
    public static int mlx_distributed_all_min(MemorySegment res, MemorySegment x, MemorySegment group, MemorySegment s) {
        var mh$ = mlx_distributed_all_min.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_distributed_all_min", res, x, group, s);
            }
            return (int)mh$.invokeExact(res, x, group, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_distributed_all_sum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_distributed_group_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_distributed_all_sum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_distributed_all_sum(mlx_array *res, const mlx_array x, const mlx_distributed_group group, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_distributed_all_sum$descriptor() {
        return mlx_distributed_all_sum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_distributed_all_sum(mlx_array *res, const mlx_array x, const mlx_distributed_group group, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_distributed_all_sum$handle() {
        return mlx_distributed_all_sum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_distributed_all_sum(mlx_array *res, const mlx_array x, const mlx_distributed_group group, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_distributed_all_sum$address() {
        return mlx_distributed_all_sum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_distributed_all_sum(mlx_array *res, const mlx_array x, const mlx_distributed_group group, const mlx_stream s)
     * }
     */
    public static int mlx_distributed_all_sum(MemorySegment res, MemorySegment x, MemorySegment group, MemorySegment s) {
        var mh$ = mlx_distributed_all_sum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_distributed_all_sum", res, x, group, s);
            }
            return (int)mh$.invokeExact(res, x, group, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_distributed_recv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_distributed_group_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_distributed_recv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_distributed_recv(mlx_array *res, const int *shape, size_t shape_num, mlx_dtype dtype, int src, const mlx_distributed_group group, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_distributed_recv$descriptor() {
        return mlx_distributed_recv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_distributed_recv(mlx_array *res, const int *shape, size_t shape_num, mlx_dtype dtype, int src, const mlx_distributed_group group, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_distributed_recv$handle() {
        return mlx_distributed_recv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_distributed_recv(mlx_array *res, const int *shape, size_t shape_num, mlx_dtype dtype, int src, const mlx_distributed_group group, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_distributed_recv$address() {
        return mlx_distributed_recv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_distributed_recv(mlx_array *res, const int *shape, size_t shape_num, mlx_dtype dtype, int src, const mlx_distributed_group group, const mlx_stream s)
     * }
     */
    public static int mlx_distributed_recv(MemorySegment res, MemorySegment shape, long shape_num, int dtype, int src, MemorySegment group, MemorySegment s) {
        var mh$ = mlx_distributed_recv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_distributed_recv", res, shape, shape_num, dtype, src, group, s);
            }
            return (int)mh$.invokeExact(res, shape, shape_num, dtype, src, group, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_distributed_recv_like {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_distributed_group_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_distributed_recv_like");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_distributed_recv_like(mlx_array *res, const mlx_array x, int src, const mlx_distributed_group group, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_distributed_recv_like$descriptor() {
        return mlx_distributed_recv_like.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_distributed_recv_like(mlx_array *res, const mlx_array x, int src, const mlx_distributed_group group, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_distributed_recv_like$handle() {
        return mlx_distributed_recv_like.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_distributed_recv_like(mlx_array *res, const mlx_array x, int src, const mlx_distributed_group group, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_distributed_recv_like$address() {
        return mlx_distributed_recv_like.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_distributed_recv_like(mlx_array *res, const mlx_array x, int src, const mlx_distributed_group group, const mlx_stream s)
     * }
     */
    public static int mlx_distributed_recv_like(MemorySegment res, MemorySegment x, int src, MemorySegment group, MemorySegment s) {
        var mh$ = mlx_distributed_recv_like.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_distributed_recv_like", res, x, src, group, s);
            }
            return (int)mh$.invokeExact(res, x, src, group, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_distributed_send {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_distributed_group_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_distributed_send");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_distributed_send(mlx_array *res, const mlx_array x, int dst, const mlx_distributed_group group, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_distributed_send$descriptor() {
        return mlx_distributed_send.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_distributed_send(mlx_array *res, const mlx_array x, int dst, const mlx_distributed_group group, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_distributed_send$handle() {
        return mlx_distributed_send.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_distributed_send(mlx_array *res, const mlx_array x, int dst, const mlx_distributed_group group, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_distributed_send$address() {
        return mlx_distributed_send.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_distributed_send(mlx_array *res, const mlx_array x, int dst, const mlx_distributed_group group, const mlx_stream s)
     * }
     */
    public static int mlx_distributed_send(MemorySegment res, MemorySegment x, int dst, MemorySegment group, MemorySegment s) {
        var mh$ = mlx_distributed_send.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_distributed_send", res, x, dst, group, s);
            }
            return (int)mh$.invokeExact(res, x, dst, group, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_set_error_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_set_error_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void mlx_set_error_handler(mlx_error_handler_func handler, void *data, void (*dtor)(void *))
     * }
     */
    public static FunctionDescriptor mlx_set_error_handler$descriptor() {
        return mlx_set_error_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void mlx_set_error_handler(mlx_error_handler_func handler, void *data, void (*dtor)(void *))
     * }
     */
    public static MethodHandle mlx_set_error_handler$handle() {
        return mlx_set_error_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void mlx_set_error_handler(mlx_error_handler_func handler, void *data, void (*dtor)(void *))
     * }
     */
    public static MemorySegment mlx_set_error_handler$address() {
        return mlx_set_error_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void mlx_set_error_handler(mlx_error_handler_func handler, void *data, void (*dtor)(void *))
     * }
     */
    public static void mlx_set_error_handler(MemorySegment handler, MemorySegment data, MemorySegment dtor) {
        var mh$ = mlx_set_error_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_set_error_handler", handler, data, dtor);
            }
            mh$.invokeExact(handler, data, dtor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void _mlx_error(const char *file, const int line, const char *fmt, ...)
     * }
     */
    public static class _mlx_error {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                mlx_h.C_POINTER,
                mlx_h.C_INT,
                mlx_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mlx_error");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _mlx_error(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void _mlx_error(const char *file, const int line, const char *fmt, ...)
         * }
         */
        public static _mlx_error makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _mlx_error(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment file, int line, MemorySegment fmt, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_mlx_error", file, line, fmt, x3);
                }
                 spreader.invokeExact(file, line, fmt, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class mlx_export_function {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_closure_.layout(),
            mlx_vector_array_.layout(),
            mlx_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_export_function");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_export_function(const char *file, const mlx_closure fun, const mlx_vector_array args, bool shapeless)
     * }
     */
    public static FunctionDescriptor mlx_export_function$descriptor() {
        return mlx_export_function.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_export_function(const char *file, const mlx_closure fun, const mlx_vector_array args, bool shapeless)
     * }
     */
    public static MethodHandle mlx_export_function$handle() {
        return mlx_export_function.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_export_function(const char *file, const mlx_closure fun, const mlx_vector_array args, bool shapeless)
     * }
     */
    public static MemorySegment mlx_export_function$address() {
        return mlx_export_function.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_export_function(const char *file, const mlx_closure fun, const mlx_vector_array args, bool shapeless)
     * }
     */
    public static int mlx_export_function(MemorySegment file, MemorySegment fun, MemorySegment args, boolean shapeless) {
        var mh$ = mlx_export_function.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_export_function", file, fun, args, shapeless);
            }
            return (int)mh$.invokeExact(file, fun, args, shapeless);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_export_function_kwargs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_closure_kwargs_.layout(),
            mlx_vector_array_.layout(),
            mlx_map_string_to_array_.layout(),
            mlx_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_export_function_kwargs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_export_function_kwargs(const char *file, const mlx_closure_kwargs fun, const mlx_vector_array args, const mlx_map_string_to_array kwargs, bool shapeless)
     * }
     */
    public static FunctionDescriptor mlx_export_function_kwargs$descriptor() {
        return mlx_export_function_kwargs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_export_function_kwargs(const char *file, const mlx_closure_kwargs fun, const mlx_vector_array args, const mlx_map_string_to_array kwargs, bool shapeless)
     * }
     */
    public static MethodHandle mlx_export_function_kwargs$handle() {
        return mlx_export_function_kwargs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_export_function_kwargs(const char *file, const mlx_closure_kwargs fun, const mlx_vector_array args, const mlx_map_string_to_array kwargs, bool shapeless)
     * }
     */
    public static MemorySegment mlx_export_function_kwargs$address() {
        return mlx_export_function_kwargs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_export_function_kwargs(const char *file, const mlx_closure_kwargs fun, const mlx_vector_array args, const mlx_map_string_to_array kwargs, bool shapeless)
     * }
     */
    public static int mlx_export_function_kwargs(MemorySegment file, MemorySegment fun, MemorySegment args, MemorySegment kwargs, boolean shapeless) {
        var mh$ = mlx_export_function_kwargs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_export_function_kwargs", file, fun, args, kwargs, shapeless);
            }
            return (int)mh$.invokeExact(file, fun, args, kwargs, shapeless);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_function_exporter_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_function_exporter_.layout(),
            mlx_h.C_POINTER,
            mlx_closure_.layout(),
            mlx_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_function_exporter_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_function_exporter mlx_function_exporter_new(const char *file, const mlx_closure fun, bool shapeless)
     * }
     */
    public static FunctionDescriptor mlx_function_exporter_new$descriptor() {
        return mlx_function_exporter_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_function_exporter mlx_function_exporter_new(const char *file, const mlx_closure fun, bool shapeless)
     * }
     */
    public static MethodHandle mlx_function_exporter_new$handle() {
        return mlx_function_exporter_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_function_exporter mlx_function_exporter_new(const char *file, const mlx_closure fun, bool shapeless)
     * }
     */
    public static MemorySegment mlx_function_exporter_new$address() {
        return mlx_function_exporter_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_function_exporter mlx_function_exporter_new(const char *file, const mlx_closure fun, bool shapeless)
     * }
     */
    public static MemorySegment mlx_function_exporter_new(SegmentAllocator allocator, MemorySegment file, MemorySegment fun, boolean shapeless) {
        var mh$ = mlx_function_exporter_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_function_exporter_new", allocator, file, fun, shapeless);
            }
            return (MemorySegment)mh$.invokeExact(allocator, file, fun, shapeless);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_function_exporter_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_function_exporter_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_function_exporter_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_function_exporter_free(mlx_function_exporter xfunc)
     * }
     */
    public static FunctionDescriptor mlx_function_exporter_free$descriptor() {
        return mlx_function_exporter_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_function_exporter_free(mlx_function_exporter xfunc)
     * }
     */
    public static MethodHandle mlx_function_exporter_free$handle() {
        return mlx_function_exporter_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_function_exporter_free(mlx_function_exporter xfunc)
     * }
     */
    public static MemorySegment mlx_function_exporter_free$address() {
        return mlx_function_exporter_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_function_exporter_free(mlx_function_exporter xfunc)
     * }
     */
    public static int mlx_function_exporter_free(MemorySegment xfunc) {
        var mh$ = mlx_function_exporter_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_function_exporter_free", xfunc);
            }
            return (int)mh$.invokeExact(xfunc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_function_exporter_apply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_function_exporter_.layout(),
            mlx_vector_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_function_exporter_apply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_function_exporter_apply(const mlx_function_exporter xfunc, const mlx_vector_array args)
     * }
     */
    public static FunctionDescriptor mlx_function_exporter_apply$descriptor() {
        return mlx_function_exporter_apply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_function_exporter_apply(const mlx_function_exporter xfunc, const mlx_vector_array args)
     * }
     */
    public static MethodHandle mlx_function_exporter_apply$handle() {
        return mlx_function_exporter_apply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_function_exporter_apply(const mlx_function_exporter xfunc, const mlx_vector_array args)
     * }
     */
    public static MemorySegment mlx_function_exporter_apply$address() {
        return mlx_function_exporter_apply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_function_exporter_apply(const mlx_function_exporter xfunc, const mlx_vector_array args)
     * }
     */
    public static int mlx_function_exporter_apply(MemorySegment xfunc, MemorySegment args) {
        var mh$ = mlx_function_exporter_apply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_function_exporter_apply", xfunc, args);
            }
            return (int)mh$.invokeExact(xfunc, args);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_function_exporter_apply_kwargs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_function_exporter_.layout(),
            mlx_vector_array_.layout(),
            mlx_map_string_to_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_function_exporter_apply_kwargs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_function_exporter_apply_kwargs(const mlx_function_exporter xfunc, const mlx_vector_array args, const mlx_map_string_to_array kwargs)
     * }
     */
    public static FunctionDescriptor mlx_function_exporter_apply_kwargs$descriptor() {
        return mlx_function_exporter_apply_kwargs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_function_exporter_apply_kwargs(const mlx_function_exporter xfunc, const mlx_vector_array args, const mlx_map_string_to_array kwargs)
     * }
     */
    public static MethodHandle mlx_function_exporter_apply_kwargs$handle() {
        return mlx_function_exporter_apply_kwargs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_function_exporter_apply_kwargs(const mlx_function_exporter xfunc, const mlx_vector_array args, const mlx_map_string_to_array kwargs)
     * }
     */
    public static MemorySegment mlx_function_exporter_apply_kwargs$address() {
        return mlx_function_exporter_apply_kwargs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_function_exporter_apply_kwargs(const mlx_function_exporter xfunc, const mlx_vector_array args, const mlx_map_string_to_array kwargs)
     * }
     */
    public static int mlx_function_exporter_apply_kwargs(MemorySegment xfunc, MemorySegment args, MemorySegment kwargs) {
        var mh$ = mlx_function_exporter_apply_kwargs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_function_exporter_apply_kwargs", xfunc, args, kwargs);
            }
            return (int)mh$.invokeExact(xfunc, args, kwargs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_imported_function_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_imported_function_.layout(),
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_imported_function_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_imported_function mlx_imported_function_new(const char *file)
     * }
     */
    public static FunctionDescriptor mlx_imported_function_new$descriptor() {
        return mlx_imported_function_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_imported_function mlx_imported_function_new(const char *file)
     * }
     */
    public static MethodHandle mlx_imported_function_new$handle() {
        return mlx_imported_function_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_imported_function mlx_imported_function_new(const char *file)
     * }
     */
    public static MemorySegment mlx_imported_function_new$address() {
        return mlx_imported_function_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_imported_function mlx_imported_function_new(const char *file)
     * }
     */
    public static MemorySegment mlx_imported_function_new(SegmentAllocator allocator, MemorySegment file) {
        var mh$ = mlx_imported_function_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_imported_function_new", allocator, file);
            }
            return (MemorySegment)mh$.invokeExact(allocator, file);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_imported_function_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_imported_function_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_imported_function_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_imported_function_free(mlx_imported_function xfunc)
     * }
     */
    public static FunctionDescriptor mlx_imported_function_free$descriptor() {
        return mlx_imported_function_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_imported_function_free(mlx_imported_function xfunc)
     * }
     */
    public static MethodHandle mlx_imported_function_free$handle() {
        return mlx_imported_function_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_imported_function_free(mlx_imported_function xfunc)
     * }
     */
    public static MemorySegment mlx_imported_function_free$address() {
        return mlx_imported_function_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_imported_function_free(mlx_imported_function xfunc)
     * }
     */
    public static int mlx_imported_function_free(MemorySegment xfunc) {
        var mh$ = mlx_imported_function_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_imported_function_free", xfunc);
            }
            return (int)mh$.invokeExact(xfunc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_imported_function_apply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_imported_function_.layout(),
            mlx_vector_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_imported_function_apply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_imported_function_apply(mlx_vector_array *res, const mlx_imported_function xfunc, const mlx_vector_array args)
     * }
     */
    public static FunctionDescriptor mlx_imported_function_apply$descriptor() {
        return mlx_imported_function_apply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_imported_function_apply(mlx_vector_array *res, const mlx_imported_function xfunc, const mlx_vector_array args)
     * }
     */
    public static MethodHandle mlx_imported_function_apply$handle() {
        return mlx_imported_function_apply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_imported_function_apply(mlx_vector_array *res, const mlx_imported_function xfunc, const mlx_vector_array args)
     * }
     */
    public static MemorySegment mlx_imported_function_apply$address() {
        return mlx_imported_function_apply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_imported_function_apply(mlx_vector_array *res, const mlx_imported_function xfunc, const mlx_vector_array args)
     * }
     */
    public static int mlx_imported_function_apply(MemorySegment res, MemorySegment xfunc, MemorySegment args) {
        var mh$ = mlx_imported_function_apply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_imported_function_apply", res, xfunc, args);
            }
            return (int)mh$.invokeExact(res, xfunc, args);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_imported_function_apply_kwargs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_imported_function_.layout(),
            mlx_vector_array_.layout(),
            mlx_map_string_to_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_imported_function_apply_kwargs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_imported_function_apply_kwargs(mlx_vector_array *res, const mlx_imported_function xfunc, const mlx_vector_array args, const mlx_map_string_to_array kwargs)
     * }
     */
    public static FunctionDescriptor mlx_imported_function_apply_kwargs$descriptor() {
        return mlx_imported_function_apply_kwargs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_imported_function_apply_kwargs(mlx_vector_array *res, const mlx_imported_function xfunc, const mlx_vector_array args, const mlx_map_string_to_array kwargs)
     * }
     */
    public static MethodHandle mlx_imported_function_apply_kwargs$handle() {
        return mlx_imported_function_apply_kwargs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_imported_function_apply_kwargs(mlx_vector_array *res, const mlx_imported_function xfunc, const mlx_vector_array args, const mlx_map_string_to_array kwargs)
     * }
     */
    public static MemorySegment mlx_imported_function_apply_kwargs$address() {
        return mlx_imported_function_apply_kwargs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_imported_function_apply_kwargs(mlx_vector_array *res, const mlx_imported_function xfunc, const mlx_vector_array args, const mlx_map_string_to_array kwargs)
     * }
     */
    public static int mlx_imported_function_apply_kwargs(MemorySegment res, MemorySegment xfunc, MemorySegment args, MemorySegment kwargs) {
        var mh$ = mlx_imported_function_apply_kwargs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_imported_function_apply_kwargs", res, xfunc, args, kwargs);
            }
            return (int)mh$.invokeExact(res, xfunc, args, kwargs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fast_affine_dequantize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fast_affine_dequantize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fast_affine_dequantize(mlx_array *res, const mlx_array w, const mlx_array scales, const mlx_array biases, int group_size, int bits, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_fast_affine_dequantize$descriptor() {
        return mlx_fast_affine_dequantize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fast_affine_dequantize(mlx_array *res, const mlx_array w, const mlx_array scales, const mlx_array biases, int group_size, int bits, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_fast_affine_dequantize$handle() {
        return mlx_fast_affine_dequantize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fast_affine_dequantize(mlx_array *res, const mlx_array w, const mlx_array scales, const mlx_array biases, int group_size, int bits, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_fast_affine_dequantize$address() {
        return mlx_fast_affine_dequantize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fast_affine_dequantize(mlx_array *res, const mlx_array w, const mlx_array scales, const mlx_array biases, int group_size, int bits, const mlx_stream s)
     * }
     */
    public static int mlx_fast_affine_dequantize(MemorySegment res, MemorySegment w, MemorySegment scales, MemorySegment biases, int group_size, int bits, MemorySegment s) {
        var mh$ = mlx_fast_affine_dequantize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fast_affine_dequantize", res, w, scales, biases, group_size, bits, s);
            }
            return (int)mh$.invokeExact(res, w, scales, biases, group_size, bits, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fast_affine_quantize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fast_affine_quantize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fast_affine_quantize(mlx_array *res_0, mlx_array *res_1, mlx_array *res_2, const mlx_array w, int group_size, int bits, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_fast_affine_quantize$descriptor() {
        return mlx_fast_affine_quantize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fast_affine_quantize(mlx_array *res_0, mlx_array *res_1, mlx_array *res_2, const mlx_array w, int group_size, int bits, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_fast_affine_quantize$handle() {
        return mlx_fast_affine_quantize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fast_affine_quantize(mlx_array *res_0, mlx_array *res_1, mlx_array *res_2, const mlx_array w, int group_size, int bits, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_fast_affine_quantize$address() {
        return mlx_fast_affine_quantize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fast_affine_quantize(mlx_array *res_0, mlx_array *res_1, mlx_array *res_2, const mlx_array w, int group_size, int bits, const mlx_stream s)
     * }
     */
    public static int mlx_fast_affine_quantize(MemorySegment res_0, MemorySegment res_1, MemorySegment res_2, MemorySegment w, int group_size, int bits, MemorySegment s) {
        var mh$ = mlx_fast_affine_quantize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fast_affine_quantize", res_0, res_1, res_2, w, group_size, bits, s);
            }
            return (int)mh$.invokeExact(res_0, res_1, res_2, w, group_size, bits, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fast_layer_norm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_FLOAT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fast_layer_norm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fast_layer_norm(mlx_array *res, const mlx_array x, const mlx_array weight, const mlx_array bias, float eps, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_fast_layer_norm$descriptor() {
        return mlx_fast_layer_norm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fast_layer_norm(mlx_array *res, const mlx_array x, const mlx_array weight, const mlx_array bias, float eps, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_fast_layer_norm$handle() {
        return mlx_fast_layer_norm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fast_layer_norm(mlx_array *res, const mlx_array x, const mlx_array weight, const mlx_array bias, float eps, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_fast_layer_norm$address() {
        return mlx_fast_layer_norm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fast_layer_norm(mlx_array *res, const mlx_array x, const mlx_array weight, const mlx_array bias, float eps, const mlx_stream s)
     * }
     */
    public static int mlx_fast_layer_norm(MemorySegment res, MemorySegment x, MemorySegment weight, MemorySegment bias, float eps, MemorySegment s) {
        var mh$ = mlx_fast_layer_norm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fast_layer_norm", res, x, weight, bias, eps, s);
            }
            return (int)mh$.invokeExact(res, x, weight, bias, eps, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * mlx_fast_metal_kernel_config mlx_fast_metal_kernel_config_new()
     * }
     */
    public static class mlx_fast_metal_kernel_config_new {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_fast_metal_kernel_config_.layout()        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fast_metal_kernel_config_new");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private mlx_fast_metal_kernel_config_new(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * mlx_fast_metal_kernel_config mlx_fast_metal_kernel_config_new()
         * }
         */
        public static mlx_fast_metal_kernel_config_new makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new mlx_fast_metal_kernel_config_new(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("mlx_fast_metal_kernel_config_new", allocator, x0);
                }
                return (MemorySegment) spreader.invokeExact(allocator, x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class mlx_fast_metal_kernel_config_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_fast_metal_kernel_config_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fast_metal_kernel_config_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void mlx_fast_metal_kernel_config_free(mlx_fast_metal_kernel_config cls)
     * }
     */
    public static FunctionDescriptor mlx_fast_metal_kernel_config_free$descriptor() {
        return mlx_fast_metal_kernel_config_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void mlx_fast_metal_kernel_config_free(mlx_fast_metal_kernel_config cls)
     * }
     */
    public static MethodHandle mlx_fast_metal_kernel_config_free$handle() {
        return mlx_fast_metal_kernel_config_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void mlx_fast_metal_kernel_config_free(mlx_fast_metal_kernel_config cls)
     * }
     */
    public static MemorySegment mlx_fast_metal_kernel_config_free$address() {
        return mlx_fast_metal_kernel_config_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void mlx_fast_metal_kernel_config_free(mlx_fast_metal_kernel_config cls)
     * }
     */
    public static void mlx_fast_metal_kernel_config_free(MemorySegment cls) {
        var mh$ = mlx_fast_metal_kernel_config_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fast_metal_kernel_config_free", cls);
            }
            mh$.invokeExact(cls);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fast_metal_kernel_config_add_output_arg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_fast_metal_kernel_config_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fast_metal_kernel_config_add_output_arg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_add_output_arg(mlx_fast_metal_kernel_config cls, const int *shape, size_t size, mlx_dtype dtype)
     * }
     */
    public static FunctionDescriptor mlx_fast_metal_kernel_config_add_output_arg$descriptor() {
        return mlx_fast_metal_kernel_config_add_output_arg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_add_output_arg(mlx_fast_metal_kernel_config cls, const int *shape, size_t size, mlx_dtype dtype)
     * }
     */
    public static MethodHandle mlx_fast_metal_kernel_config_add_output_arg$handle() {
        return mlx_fast_metal_kernel_config_add_output_arg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_add_output_arg(mlx_fast_metal_kernel_config cls, const int *shape, size_t size, mlx_dtype dtype)
     * }
     */
    public static MemorySegment mlx_fast_metal_kernel_config_add_output_arg$address() {
        return mlx_fast_metal_kernel_config_add_output_arg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_add_output_arg(mlx_fast_metal_kernel_config cls, const int *shape, size_t size, mlx_dtype dtype)
     * }
     */
    public static int mlx_fast_metal_kernel_config_add_output_arg(MemorySegment cls, MemorySegment shape, long size, int dtype) {
        var mh$ = mlx_fast_metal_kernel_config_add_output_arg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fast_metal_kernel_config_add_output_arg", cls, shape, size, dtype);
            }
            return (int)mh$.invokeExact(cls, shape, size, dtype);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fast_metal_kernel_config_set_grid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_fast_metal_kernel_config_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fast_metal_kernel_config_set_grid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_set_grid(mlx_fast_metal_kernel_config cls, int grid1, int grid2, int grid3)
     * }
     */
    public static FunctionDescriptor mlx_fast_metal_kernel_config_set_grid$descriptor() {
        return mlx_fast_metal_kernel_config_set_grid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_set_grid(mlx_fast_metal_kernel_config cls, int grid1, int grid2, int grid3)
     * }
     */
    public static MethodHandle mlx_fast_metal_kernel_config_set_grid$handle() {
        return mlx_fast_metal_kernel_config_set_grid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_set_grid(mlx_fast_metal_kernel_config cls, int grid1, int grid2, int grid3)
     * }
     */
    public static MemorySegment mlx_fast_metal_kernel_config_set_grid$address() {
        return mlx_fast_metal_kernel_config_set_grid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_set_grid(mlx_fast_metal_kernel_config cls, int grid1, int grid2, int grid3)
     * }
     */
    public static int mlx_fast_metal_kernel_config_set_grid(MemorySegment cls, int grid1, int grid2, int grid3) {
        var mh$ = mlx_fast_metal_kernel_config_set_grid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fast_metal_kernel_config_set_grid", cls, grid1, grid2, grid3);
            }
            return (int)mh$.invokeExact(cls, grid1, grid2, grid3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fast_metal_kernel_config_set_thread_group {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_fast_metal_kernel_config_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fast_metal_kernel_config_set_thread_group");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_set_thread_group(mlx_fast_metal_kernel_config cls, int thread1, int thread2, int thread3)
     * }
     */
    public static FunctionDescriptor mlx_fast_metal_kernel_config_set_thread_group$descriptor() {
        return mlx_fast_metal_kernel_config_set_thread_group.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_set_thread_group(mlx_fast_metal_kernel_config cls, int thread1, int thread2, int thread3)
     * }
     */
    public static MethodHandle mlx_fast_metal_kernel_config_set_thread_group$handle() {
        return mlx_fast_metal_kernel_config_set_thread_group.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_set_thread_group(mlx_fast_metal_kernel_config cls, int thread1, int thread2, int thread3)
     * }
     */
    public static MemorySegment mlx_fast_metal_kernel_config_set_thread_group$address() {
        return mlx_fast_metal_kernel_config_set_thread_group.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_set_thread_group(mlx_fast_metal_kernel_config cls, int thread1, int thread2, int thread3)
     * }
     */
    public static int mlx_fast_metal_kernel_config_set_thread_group(MemorySegment cls, int thread1, int thread2, int thread3) {
        var mh$ = mlx_fast_metal_kernel_config_set_thread_group.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fast_metal_kernel_config_set_thread_group", cls, thread1, thread2, thread3);
            }
            return (int)mh$.invokeExact(cls, thread1, thread2, thread3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fast_metal_kernel_config_set_init_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_fast_metal_kernel_config_.layout(),
            mlx_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fast_metal_kernel_config_set_init_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_set_init_value(mlx_fast_metal_kernel_config cls, float value)
     * }
     */
    public static FunctionDescriptor mlx_fast_metal_kernel_config_set_init_value$descriptor() {
        return mlx_fast_metal_kernel_config_set_init_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_set_init_value(mlx_fast_metal_kernel_config cls, float value)
     * }
     */
    public static MethodHandle mlx_fast_metal_kernel_config_set_init_value$handle() {
        return mlx_fast_metal_kernel_config_set_init_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_set_init_value(mlx_fast_metal_kernel_config cls, float value)
     * }
     */
    public static MemorySegment mlx_fast_metal_kernel_config_set_init_value$address() {
        return mlx_fast_metal_kernel_config_set_init_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_set_init_value(mlx_fast_metal_kernel_config cls, float value)
     * }
     */
    public static int mlx_fast_metal_kernel_config_set_init_value(MemorySegment cls, float value) {
        var mh$ = mlx_fast_metal_kernel_config_set_init_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fast_metal_kernel_config_set_init_value", cls, value);
            }
            return (int)mh$.invokeExact(cls, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fast_metal_kernel_config_set_verbose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_fast_metal_kernel_config_.layout(),
            mlx_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fast_metal_kernel_config_set_verbose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_set_verbose(mlx_fast_metal_kernel_config cls, bool verbose)
     * }
     */
    public static FunctionDescriptor mlx_fast_metal_kernel_config_set_verbose$descriptor() {
        return mlx_fast_metal_kernel_config_set_verbose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_set_verbose(mlx_fast_metal_kernel_config cls, bool verbose)
     * }
     */
    public static MethodHandle mlx_fast_metal_kernel_config_set_verbose$handle() {
        return mlx_fast_metal_kernel_config_set_verbose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_set_verbose(mlx_fast_metal_kernel_config cls, bool verbose)
     * }
     */
    public static MemorySegment mlx_fast_metal_kernel_config_set_verbose$address() {
        return mlx_fast_metal_kernel_config_set_verbose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_set_verbose(mlx_fast_metal_kernel_config cls, bool verbose)
     * }
     */
    public static int mlx_fast_metal_kernel_config_set_verbose(MemorySegment cls, boolean verbose) {
        var mh$ = mlx_fast_metal_kernel_config_set_verbose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fast_metal_kernel_config_set_verbose", cls, verbose);
            }
            return (int)mh$.invokeExact(cls, verbose);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fast_metal_kernel_config_add_template_arg_dtype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_fast_metal_kernel_config_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fast_metal_kernel_config_add_template_arg_dtype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_add_template_arg_dtype(mlx_fast_metal_kernel_config cls, const char *name, mlx_dtype dtype)
     * }
     */
    public static FunctionDescriptor mlx_fast_metal_kernel_config_add_template_arg_dtype$descriptor() {
        return mlx_fast_metal_kernel_config_add_template_arg_dtype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_add_template_arg_dtype(mlx_fast_metal_kernel_config cls, const char *name, mlx_dtype dtype)
     * }
     */
    public static MethodHandle mlx_fast_metal_kernel_config_add_template_arg_dtype$handle() {
        return mlx_fast_metal_kernel_config_add_template_arg_dtype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_add_template_arg_dtype(mlx_fast_metal_kernel_config cls, const char *name, mlx_dtype dtype)
     * }
     */
    public static MemorySegment mlx_fast_metal_kernel_config_add_template_arg_dtype$address() {
        return mlx_fast_metal_kernel_config_add_template_arg_dtype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_add_template_arg_dtype(mlx_fast_metal_kernel_config cls, const char *name, mlx_dtype dtype)
     * }
     */
    public static int mlx_fast_metal_kernel_config_add_template_arg_dtype(MemorySegment cls, MemorySegment name, int dtype) {
        var mh$ = mlx_fast_metal_kernel_config_add_template_arg_dtype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fast_metal_kernel_config_add_template_arg_dtype", cls, name, dtype);
            }
            return (int)mh$.invokeExact(cls, name, dtype);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fast_metal_kernel_config_add_template_arg_int {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_fast_metal_kernel_config_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fast_metal_kernel_config_add_template_arg_int");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_add_template_arg_int(mlx_fast_metal_kernel_config cls, const char *name, int value)
     * }
     */
    public static FunctionDescriptor mlx_fast_metal_kernel_config_add_template_arg_int$descriptor() {
        return mlx_fast_metal_kernel_config_add_template_arg_int.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_add_template_arg_int(mlx_fast_metal_kernel_config cls, const char *name, int value)
     * }
     */
    public static MethodHandle mlx_fast_metal_kernel_config_add_template_arg_int$handle() {
        return mlx_fast_metal_kernel_config_add_template_arg_int.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_add_template_arg_int(mlx_fast_metal_kernel_config cls, const char *name, int value)
     * }
     */
    public static MemorySegment mlx_fast_metal_kernel_config_add_template_arg_int$address() {
        return mlx_fast_metal_kernel_config_add_template_arg_int.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_add_template_arg_int(mlx_fast_metal_kernel_config cls, const char *name, int value)
     * }
     */
    public static int mlx_fast_metal_kernel_config_add_template_arg_int(MemorySegment cls, MemorySegment name, int value) {
        var mh$ = mlx_fast_metal_kernel_config_add_template_arg_int.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fast_metal_kernel_config_add_template_arg_int", cls, name, value);
            }
            return (int)mh$.invokeExact(cls, name, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fast_metal_kernel_config_add_template_arg_bool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_fast_metal_kernel_config_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fast_metal_kernel_config_add_template_arg_bool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_add_template_arg_bool(mlx_fast_metal_kernel_config cls, const char *name, bool value)
     * }
     */
    public static FunctionDescriptor mlx_fast_metal_kernel_config_add_template_arg_bool$descriptor() {
        return mlx_fast_metal_kernel_config_add_template_arg_bool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_add_template_arg_bool(mlx_fast_metal_kernel_config cls, const char *name, bool value)
     * }
     */
    public static MethodHandle mlx_fast_metal_kernel_config_add_template_arg_bool$handle() {
        return mlx_fast_metal_kernel_config_add_template_arg_bool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_add_template_arg_bool(mlx_fast_metal_kernel_config cls, const char *name, bool value)
     * }
     */
    public static MemorySegment mlx_fast_metal_kernel_config_add_template_arg_bool$address() {
        return mlx_fast_metal_kernel_config_add_template_arg_bool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_config_add_template_arg_bool(mlx_fast_metal_kernel_config cls, const char *name, bool value)
     * }
     */
    public static int mlx_fast_metal_kernel_config_add_template_arg_bool(MemorySegment cls, MemorySegment name, boolean value) {
        var mh$ = mlx_fast_metal_kernel_config_add_template_arg_bool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fast_metal_kernel_config_add_template_arg_bool", cls, name, value);
            }
            return (int)mh$.invokeExact(cls, name, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fast_metal_kernel_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_fast_metal_kernel_.layout(),
            mlx_h.C_POINTER,
            mlx_vector_string_.layout(),
            mlx_vector_string_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_BOOL,
            mlx_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fast_metal_kernel_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mlx_fast_metal_kernel mlx_fast_metal_kernel_new(const char *name, const mlx_vector_string input_names, const mlx_vector_string output_names, const char *source, const char *header, bool ensure_row_contiguous, bool atomic_outputs)
     * }
     */
    public static FunctionDescriptor mlx_fast_metal_kernel_new$descriptor() {
        return mlx_fast_metal_kernel_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mlx_fast_metal_kernel mlx_fast_metal_kernel_new(const char *name, const mlx_vector_string input_names, const mlx_vector_string output_names, const char *source, const char *header, bool ensure_row_contiguous, bool atomic_outputs)
     * }
     */
    public static MethodHandle mlx_fast_metal_kernel_new$handle() {
        return mlx_fast_metal_kernel_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mlx_fast_metal_kernel mlx_fast_metal_kernel_new(const char *name, const mlx_vector_string input_names, const mlx_vector_string output_names, const char *source, const char *header, bool ensure_row_contiguous, bool atomic_outputs)
     * }
     */
    public static MemorySegment mlx_fast_metal_kernel_new$address() {
        return mlx_fast_metal_kernel_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mlx_fast_metal_kernel mlx_fast_metal_kernel_new(const char *name, const mlx_vector_string input_names, const mlx_vector_string output_names, const char *source, const char *header, bool ensure_row_contiguous, bool atomic_outputs)
     * }
     */
    public static MemorySegment mlx_fast_metal_kernel_new(SegmentAllocator allocator, MemorySegment name, MemorySegment input_names, MemorySegment output_names, MemorySegment source, MemorySegment header, boolean ensure_row_contiguous, boolean atomic_outputs) {
        var mh$ = mlx_fast_metal_kernel_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fast_metal_kernel_new", allocator, name, input_names, output_names, source, header, ensure_row_contiguous, atomic_outputs);
            }
            return (MemorySegment)mh$.invokeExact(allocator, name, input_names, output_names, source, header, ensure_row_contiguous, atomic_outputs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fast_metal_kernel_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mlx_fast_metal_kernel_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fast_metal_kernel_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void mlx_fast_metal_kernel_free(mlx_fast_metal_kernel cls)
     * }
     */
    public static FunctionDescriptor mlx_fast_metal_kernel_free$descriptor() {
        return mlx_fast_metal_kernel_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void mlx_fast_metal_kernel_free(mlx_fast_metal_kernel cls)
     * }
     */
    public static MethodHandle mlx_fast_metal_kernel_free$handle() {
        return mlx_fast_metal_kernel_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void mlx_fast_metal_kernel_free(mlx_fast_metal_kernel cls)
     * }
     */
    public static MemorySegment mlx_fast_metal_kernel_free$address() {
        return mlx_fast_metal_kernel_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void mlx_fast_metal_kernel_free(mlx_fast_metal_kernel cls)
     * }
     */
    public static void mlx_fast_metal_kernel_free(MemorySegment cls) {
        var mh$ = mlx_fast_metal_kernel_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fast_metal_kernel_free", cls);
            }
            mh$.invokeExact(cls);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fast_metal_kernel_apply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_fast_metal_kernel_.layout(),
            mlx_vector_array_.layout(),
            mlx_fast_metal_kernel_config_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fast_metal_kernel_apply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_apply(mlx_vector_array *outputs, mlx_fast_metal_kernel cls, const mlx_vector_array inputs, const mlx_fast_metal_kernel_config config, const mlx_stream stream)
     * }
     */
    public static FunctionDescriptor mlx_fast_metal_kernel_apply$descriptor() {
        return mlx_fast_metal_kernel_apply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_apply(mlx_vector_array *outputs, mlx_fast_metal_kernel cls, const mlx_vector_array inputs, const mlx_fast_metal_kernel_config config, const mlx_stream stream)
     * }
     */
    public static MethodHandle mlx_fast_metal_kernel_apply$handle() {
        return mlx_fast_metal_kernel_apply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_apply(mlx_vector_array *outputs, mlx_fast_metal_kernel cls, const mlx_vector_array inputs, const mlx_fast_metal_kernel_config config, const mlx_stream stream)
     * }
     */
    public static MemorySegment mlx_fast_metal_kernel_apply$address() {
        return mlx_fast_metal_kernel_apply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fast_metal_kernel_apply(mlx_vector_array *outputs, mlx_fast_metal_kernel cls, const mlx_vector_array inputs, const mlx_fast_metal_kernel_config config, const mlx_stream stream)
     * }
     */
    public static int mlx_fast_metal_kernel_apply(MemorySegment outputs, MemorySegment cls, MemorySegment inputs, MemorySegment config, MemorySegment stream) {
        var mh$ = mlx_fast_metal_kernel_apply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fast_metal_kernel_apply", outputs, cls, inputs, config, stream);
            }
            return (int)mh$.invokeExact(outputs, cls, inputs, config, stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fast_rms_norm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_FLOAT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fast_rms_norm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fast_rms_norm(mlx_array *res, const mlx_array x, const mlx_array weight, float eps, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_fast_rms_norm$descriptor() {
        return mlx_fast_rms_norm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fast_rms_norm(mlx_array *res, const mlx_array x, const mlx_array weight, float eps, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_fast_rms_norm$handle() {
        return mlx_fast_rms_norm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fast_rms_norm(mlx_array *res, const mlx_array x, const mlx_array weight, float eps, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_fast_rms_norm$address() {
        return mlx_fast_rms_norm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fast_rms_norm(mlx_array *res, const mlx_array x, const mlx_array weight, float eps, const mlx_stream s)
     * }
     */
    public static int mlx_fast_rms_norm(MemorySegment res, MemorySegment x, MemorySegment weight, float eps, MemorySegment s) {
        var mh$ = mlx_fast_rms_norm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fast_rms_norm", res, x, weight, eps, s);
            }
            return (int)mh$.invokeExact(res, x, weight, eps, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fast_rope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_BOOL,
            mlx_optional_float_.layout(),
            mlx_h.C_FLOAT,
            mlx_h.C_INT,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fast_rope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fast_rope(mlx_array *res, const mlx_array x, int dims, bool traditional, mlx_optional_float base, float scale, int offset, const mlx_array freqs, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_fast_rope$descriptor() {
        return mlx_fast_rope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fast_rope(mlx_array *res, const mlx_array x, int dims, bool traditional, mlx_optional_float base, float scale, int offset, const mlx_array freqs, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_fast_rope$handle() {
        return mlx_fast_rope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fast_rope(mlx_array *res, const mlx_array x, int dims, bool traditional, mlx_optional_float base, float scale, int offset, const mlx_array freqs, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_fast_rope$address() {
        return mlx_fast_rope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fast_rope(mlx_array *res, const mlx_array x, int dims, bool traditional, mlx_optional_float base, float scale, int offset, const mlx_array freqs, const mlx_stream s)
     * }
     */
    public static int mlx_fast_rope(MemorySegment res, MemorySegment x, int dims, boolean traditional, MemorySegment base, float scale, int offset, MemorySegment freqs, MemorySegment s) {
        var mh$ = mlx_fast_rope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fast_rope", res, x, dims, traditional, base, scale, offset, freqs, s);
            }
            return (int)mh$.invokeExact(res, x, dims, traditional, base, scale, offset, freqs, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fast_scaled_dot_product_attention {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_FLOAT,
            mlx_h.C_POINTER,
            mlx_vector_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fast_scaled_dot_product_attention");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fast_scaled_dot_product_attention(mlx_array *res, const mlx_array queries, const mlx_array keys, const mlx_array values, float scale, const char *mask_mode, const mlx_vector_array mask_arrs, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_fast_scaled_dot_product_attention$descriptor() {
        return mlx_fast_scaled_dot_product_attention.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fast_scaled_dot_product_attention(mlx_array *res, const mlx_array queries, const mlx_array keys, const mlx_array values, float scale, const char *mask_mode, const mlx_vector_array mask_arrs, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_fast_scaled_dot_product_attention$handle() {
        return mlx_fast_scaled_dot_product_attention.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fast_scaled_dot_product_attention(mlx_array *res, const mlx_array queries, const mlx_array keys, const mlx_array values, float scale, const char *mask_mode, const mlx_vector_array mask_arrs, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_fast_scaled_dot_product_attention$address() {
        return mlx_fast_scaled_dot_product_attention.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fast_scaled_dot_product_attention(mlx_array *res, const mlx_array queries, const mlx_array keys, const mlx_array values, float scale, const char *mask_mode, const mlx_vector_array mask_arrs, const mlx_stream s)
     * }
     */
    public static int mlx_fast_scaled_dot_product_attention(MemorySegment res, MemorySegment queries, MemorySegment keys, MemorySegment values, float scale, MemorySegment mask_mode, MemorySegment mask_arrs, MemorySegment s) {
        var mh$ = mlx_fast_scaled_dot_product_attention.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fast_scaled_dot_product_attention", res, queries, keys, values, scale, mask_mode, mask_arrs, s);
            }
            return (int)mh$.invokeExact(res, queries, keys, values, scale, mask_mode, mask_arrs, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fft_fft {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fft_fft");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fft_fft(mlx_array *res, const mlx_array a, int n, int axis, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_fft_fft$descriptor() {
        return mlx_fft_fft.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fft_fft(mlx_array *res, const mlx_array a, int n, int axis, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_fft_fft$handle() {
        return mlx_fft_fft.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fft_fft(mlx_array *res, const mlx_array a, int n, int axis, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_fft_fft$address() {
        return mlx_fft_fft.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fft_fft(mlx_array *res, const mlx_array a, int n, int axis, const mlx_stream s)
     * }
     */
    public static int mlx_fft_fft(MemorySegment res, MemorySegment a, int n, int axis, MemorySegment s) {
        var mh$ = mlx_fft_fft.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fft_fft", res, a, n, axis, s);
            }
            return (int)mh$.invokeExact(res, a, n, axis, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fft_fft2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fft_fft2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fft_fft2(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_fft_fft2$descriptor() {
        return mlx_fft_fft2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fft_fft2(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_fft_fft2$handle() {
        return mlx_fft_fft2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fft_fft2(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_fft_fft2$address() {
        return mlx_fft_fft2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fft_fft2(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static int mlx_fft_fft2(MemorySegment res, MemorySegment a, MemorySegment n, long n_num, MemorySegment axes, long axes_num, MemorySegment s) {
        var mh$ = mlx_fft_fft2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fft_fft2", res, a, n, n_num, axes, axes_num, s);
            }
            return (int)mh$.invokeExact(res, a, n, n_num, axes, axes_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fft_fftn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fft_fftn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fft_fftn(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_fft_fftn$descriptor() {
        return mlx_fft_fftn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fft_fftn(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_fft_fftn$handle() {
        return mlx_fft_fftn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fft_fftn(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_fft_fftn$address() {
        return mlx_fft_fftn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fft_fftn(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static int mlx_fft_fftn(MemorySegment res, MemorySegment a, MemorySegment n, long n_num, MemorySegment axes, long axes_num, MemorySegment s) {
        var mh$ = mlx_fft_fftn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fft_fftn", res, a, n, n_num, axes, axes_num, s);
            }
            return (int)mh$.invokeExact(res, a, n, n_num, axes, axes_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fft_ifft {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fft_ifft");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fft_ifft(mlx_array *res, const mlx_array a, int n, int axis, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_fft_ifft$descriptor() {
        return mlx_fft_ifft.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fft_ifft(mlx_array *res, const mlx_array a, int n, int axis, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_fft_ifft$handle() {
        return mlx_fft_ifft.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fft_ifft(mlx_array *res, const mlx_array a, int n, int axis, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_fft_ifft$address() {
        return mlx_fft_ifft.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fft_ifft(mlx_array *res, const mlx_array a, int n, int axis, const mlx_stream s)
     * }
     */
    public static int mlx_fft_ifft(MemorySegment res, MemorySegment a, int n, int axis, MemorySegment s) {
        var mh$ = mlx_fft_ifft.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fft_ifft", res, a, n, axis, s);
            }
            return (int)mh$.invokeExact(res, a, n, axis, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fft_ifft2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fft_ifft2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fft_ifft2(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_fft_ifft2$descriptor() {
        return mlx_fft_ifft2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fft_ifft2(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_fft_ifft2$handle() {
        return mlx_fft_ifft2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fft_ifft2(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_fft_ifft2$address() {
        return mlx_fft_ifft2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fft_ifft2(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static int mlx_fft_ifft2(MemorySegment res, MemorySegment a, MemorySegment n, long n_num, MemorySegment axes, long axes_num, MemorySegment s) {
        var mh$ = mlx_fft_ifft2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fft_ifft2", res, a, n, n_num, axes, axes_num, s);
            }
            return (int)mh$.invokeExact(res, a, n, n_num, axes, axes_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fft_ifftn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fft_ifftn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fft_ifftn(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_fft_ifftn$descriptor() {
        return mlx_fft_ifftn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fft_ifftn(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_fft_ifftn$handle() {
        return mlx_fft_ifftn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fft_ifftn(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_fft_ifftn$address() {
        return mlx_fft_ifftn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fft_ifftn(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static int mlx_fft_ifftn(MemorySegment res, MemorySegment a, MemorySegment n, long n_num, MemorySegment axes, long axes_num, MemorySegment s) {
        var mh$ = mlx_fft_ifftn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fft_ifftn", res, a, n, n_num, axes, axes_num, s);
            }
            return (int)mh$.invokeExact(res, a, n, n_num, axes, axes_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fft_irfft {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fft_irfft");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fft_irfft(mlx_array *res, const mlx_array a, int n, int axis, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_fft_irfft$descriptor() {
        return mlx_fft_irfft.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fft_irfft(mlx_array *res, const mlx_array a, int n, int axis, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_fft_irfft$handle() {
        return mlx_fft_irfft.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fft_irfft(mlx_array *res, const mlx_array a, int n, int axis, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_fft_irfft$address() {
        return mlx_fft_irfft.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fft_irfft(mlx_array *res, const mlx_array a, int n, int axis, const mlx_stream s)
     * }
     */
    public static int mlx_fft_irfft(MemorySegment res, MemorySegment a, int n, int axis, MemorySegment s) {
        var mh$ = mlx_fft_irfft.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fft_irfft", res, a, n, axis, s);
            }
            return (int)mh$.invokeExact(res, a, n, axis, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fft_irfft2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fft_irfft2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fft_irfft2(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_fft_irfft2$descriptor() {
        return mlx_fft_irfft2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fft_irfft2(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_fft_irfft2$handle() {
        return mlx_fft_irfft2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fft_irfft2(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_fft_irfft2$address() {
        return mlx_fft_irfft2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fft_irfft2(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static int mlx_fft_irfft2(MemorySegment res, MemorySegment a, MemorySegment n, long n_num, MemorySegment axes, long axes_num, MemorySegment s) {
        var mh$ = mlx_fft_irfft2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fft_irfft2", res, a, n, n_num, axes, axes_num, s);
            }
            return (int)mh$.invokeExact(res, a, n, n_num, axes, axes_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fft_irfftn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fft_irfftn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fft_irfftn(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_fft_irfftn$descriptor() {
        return mlx_fft_irfftn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fft_irfftn(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_fft_irfftn$handle() {
        return mlx_fft_irfftn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fft_irfftn(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_fft_irfftn$address() {
        return mlx_fft_irfftn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fft_irfftn(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static int mlx_fft_irfftn(MemorySegment res, MemorySegment a, MemorySegment n, long n_num, MemorySegment axes, long axes_num, MemorySegment s) {
        var mh$ = mlx_fft_irfftn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fft_irfftn", res, a, n, n_num, axes, axes_num, s);
            }
            return (int)mh$.invokeExact(res, a, n, n_num, axes, axes_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fft_rfft {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fft_rfft");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fft_rfft(mlx_array *res, const mlx_array a, int n, int axis, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_fft_rfft$descriptor() {
        return mlx_fft_rfft.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fft_rfft(mlx_array *res, const mlx_array a, int n, int axis, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_fft_rfft$handle() {
        return mlx_fft_rfft.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fft_rfft(mlx_array *res, const mlx_array a, int n, int axis, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_fft_rfft$address() {
        return mlx_fft_rfft.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fft_rfft(mlx_array *res, const mlx_array a, int n, int axis, const mlx_stream s)
     * }
     */
    public static int mlx_fft_rfft(MemorySegment res, MemorySegment a, int n, int axis, MemorySegment s) {
        var mh$ = mlx_fft_rfft.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fft_rfft", res, a, n, axis, s);
            }
            return (int)mh$.invokeExact(res, a, n, axis, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fft_rfft2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fft_rfft2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fft_rfft2(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_fft_rfft2$descriptor() {
        return mlx_fft_rfft2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fft_rfft2(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_fft_rfft2$handle() {
        return mlx_fft_rfft2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fft_rfft2(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_fft_rfft2$address() {
        return mlx_fft_rfft2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fft_rfft2(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static int mlx_fft_rfft2(MemorySegment res, MemorySegment a, MemorySegment n, long n_num, MemorySegment axes, long axes_num, MemorySegment s) {
        var mh$ = mlx_fft_rfft2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fft_rfft2", res, a, n, n_num, axes, axes_num, s);
            }
            return (int)mh$.invokeExact(res, a, n, n_num, axes, axes_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_fft_rfftn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_fft_rfftn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_fft_rfftn(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_fft_rfftn$descriptor() {
        return mlx_fft_rfftn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_fft_rfftn(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_fft_rfftn$handle() {
        return mlx_fft_rfftn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_fft_rfftn(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_fft_rfftn$address() {
        return mlx_fft_rfftn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_fft_rfftn(mlx_array *res, const mlx_array a, const int *n, size_t n_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static int mlx_fft_rfftn(MemorySegment res, MemorySegment a, MemorySegment n, long n_num, MemorySegment axes, long axes_num, MemorySegment s) {
        var mh$ = mlx_fft_rfftn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_fft_rfftn", res, a, n, n_num, axes, axes_num, s);
            }
            return (int)mh$.invokeExact(res, a, n, n_num, axes, axes_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_load_reader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_io_reader_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_load_reader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_load_reader(mlx_array *res, mlx_io_reader in_stream, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_load_reader$descriptor() {
        return mlx_load_reader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_load_reader(mlx_array *res, mlx_io_reader in_stream, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_load_reader$handle() {
        return mlx_load_reader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_load_reader(mlx_array *res, mlx_io_reader in_stream, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_load_reader$address() {
        return mlx_load_reader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_load_reader(mlx_array *res, mlx_io_reader in_stream, const mlx_stream s)
     * }
     */
    public static int mlx_load_reader(MemorySegment res, MemorySegment in_stream, MemorySegment s) {
        var mh$ = mlx_load_reader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_load_reader", res, in_stream, s);
            }
            return (int)mh$.invokeExact(res, in_stream, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_load {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_load");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_load(mlx_array *res, const char *file, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_load$descriptor() {
        return mlx_load.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_load(mlx_array *res, const char *file, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_load$handle() {
        return mlx_load.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_load(mlx_array *res, const char *file, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_load$address() {
        return mlx_load.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_load(mlx_array *res, const char *file, const mlx_stream s)
     * }
     */
    public static int mlx_load(MemorySegment res, MemorySegment file, MemorySegment s) {
        var mh$ = mlx_load.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_load", res, file, s);
            }
            return (int)mh$.invokeExact(res, file, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_load_safetensors_reader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_io_reader_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_load_safetensors_reader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_load_safetensors_reader(mlx_map_string_to_array *res_0, mlx_map_string_to_string *res_1, mlx_io_reader in_stream, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_load_safetensors_reader$descriptor() {
        return mlx_load_safetensors_reader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_load_safetensors_reader(mlx_map_string_to_array *res_0, mlx_map_string_to_string *res_1, mlx_io_reader in_stream, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_load_safetensors_reader$handle() {
        return mlx_load_safetensors_reader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_load_safetensors_reader(mlx_map_string_to_array *res_0, mlx_map_string_to_string *res_1, mlx_io_reader in_stream, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_load_safetensors_reader$address() {
        return mlx_load_safetensors_reader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_load_safetensors_reader(mlx_map_string_to_array *res_0, mlx_map_string_to_string *res_1, mlx_io_reader in_stream, const mlx_stream s)
     * }
     */
    public static int mlx_load_safetensors_reader(MemorySegment res_0, MemorySegment res_1, MemorySegment in_stream, MemorySegment s) {
        var mh$ = mlx_load_safetensors_reader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_load_safetensors_reader", res_0, res_1, in_stream, s);
            }
            return (int)mh$.invokeExact(res_0, res_1, in_stream, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_load_safetensors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_load_safetensors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_load_safetensors(mlx_map_string_to_array *res_0, mlx_map_string_to_string *res_1, const char *file, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_load_safetensors$descriptor() {
        return mlx_load_safetensors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_load_safetensors(mlx_map_string_to_array *res_0, mlx_map_string_to_string *res_1, const char *file, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_load_safetensors$handle() {
        return mlx_load_safetensors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_load_safetensors(mlx_map_string_to_array *res_0, mlx_map_string_to_string *res_1, const char *file, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_load_safetensors$address() {
        return mlx_load_safetensors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_load_safetensors(mlx_map_string_to_array *res_0, mlx_map_string_to_string *res_1, const char *file, const mlx_stream s)
     * }
     */
    public static int mlx_load_safetensors(MemorySegment res_0, MemorySegment res_1, MemorySegment file, MemorySegment s) {
        var mh$ = mlx_load_safetensors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_load_safetensors", res_0, res_1, file, s);
            }
            return (int)mh$.invokeExact(res_0, res_1, file, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_save_writer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_io_writer_.layout(),
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_save_writer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_save_writer(mlx_io_writer out_stream, const mlx_array a)
     * }
     */
    public static FunctionDescriptor mlx_save_writer$descriptor() {
        return mlx_save_writer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_save_writer(mlx_io_writer out_stream, const mlx_array a)
     * }
     */
    public static MethodHandle mlx_save_writer$handle() {
        return mlx_save_writer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_save_writer(mlx_io_writer out_stream, const mlx_array a)
     * }
     */
    public static MemorySegment mlx_save_writer$address() {
        return mlx_save_writer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_save_writer(mlx_io_writer out_stream, const mlx_array a)
     * }
     */
    public static int mlx_save_writer(MemorySegment out_stream, MemorySegment a) {
        var mh$ = mlx_save_writer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_save_writer", out_stream, a);
            }
            return (int)mh$.invokeExact(out_stream, a);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_save {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_save");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_save(const char *file, const mlx_array a)
     * }
     */
    public static FunctionDescriptor mlx_save$descriptor() {
        return mlx_save.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_save(const char *file, const mlx_array a)
     * }
     */
    public static MethodHandle mlx_save$handle() {
        return mlx_save.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_save(const char *file, const mlx_array a)
     * }
     */
    public static MemorySegment mlx_save$address() {
        return mlx_save.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_save(const char *file, const mlx_array a)
     * }
     */
    public static int mlx_save(MemorySegment file, MemorySegment a) {
        var mh$ = mlx_save.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_save", file, a);
            }
            return (int)mh$.invokeExact(file, a);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_save_safetensors_writer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_io_writer_.layout(),
            mlx_map_string_to_array_.layout(),
            mlx_map_string_to_string_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_save_safetensors_writer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_save_safetensors_writer(mlx_io_writer in_stream, const mlx_map_string_to_array param, const mlx_map_string_to_string metadata)
     * }
     */
    public static FunctionDescriptor mlx_save_safetensors_writer$descriptor() {
        return mlx_save_safetensors_writer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_save_safetensors_writer(mlx_io_writer in_stream, const mlx_map_string_to_array param, const mlx_map_string_to_string metadata)
     * }
     */
    public static MethodHandle mlx_save_safetensors_writer$handle() {
        return mlx_save_safetensors_writer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_save_safetensors_writer(mlx_io_writer in_stream, const mlx_map_string_to_array param, const mlx_map_string_to_string metadata)
     * }
     */
    public static MemorySegment mlx_save_safetensors_writer$address() {
        return mlx_save_safetensors_writer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_save_safetensors_writer(mlx_io_writer in_stream, const mlx_map_string_to_array param, const mlx_map_string_to_string metadata)
     * }
     */
    public static int mlx_save_safetensors_writer(MemorySegment in_stream, MemorySegment param, MemorySegment metadata) {
        var mh$ = mlx_save_safetensors_writer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_save_safetensors_writer", in_stream, param, metadata);
            }
            return (int)mh$.invokeExact(in_stream, param, metadata);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_save_safetensors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_map_string_to_array_.layout(),
            mlx_map_string_to_string_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_save_safetensors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_save_safetensors(const char *file, const mlx_map_string_to_array param, const mlx_map_string_to_string metadata)
     * }
     */
    public static FunctionDescriptor mlx_save_safetensors$descriptor() {
        return mlx_save_safetensors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_save_safetensors(const char *file, const mlx_map_string_to_array param, const mlx_map_string_to_string metadata)
     * }
     */
    public static MethodHandle mlx_save_safetensors$handle() {
        return mlx_save_safetensors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_save_safetensors(const char *file, const mlx_map_string_to_array param, const mlx_map_string_to_string metadata)
     * }
     */
    public static MemorySegment mlx_save_safetensors$address() {
        return mlx_save_safetensors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_save_safetensors(const char *file, const mlx_map_string_to_array param, const mlx_map_string_to_string metadata)
     * }
     */
    public static int mlx_save_safetensors(MemorySegment file, MemorySegment param, MemorySegment metadata) {
        var mh$ = mlx_save_safetensors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_save_safetensors", file, param, metadata);
            }
            return (int)mh$.invokeExact(file, param, metadata);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_linalg_cholesky {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_linalg_cholesky");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_linalg_cholesky(mlx_array *res, const mlx_array a, bool upper, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_linalg_cholesky$descriptor() {
        return mlx_linalg_cholesky.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_linalg_cholesky(mlx_array *res, const mlx_array a, bool upper, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_linalg_cholesky$handle() {
        return mlx_linalg_cholesky.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_linalg_cholesky(mlx_array *res, const mlx_array a, bool upper, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_linalg_cholesky$address() {
        return mlx_linalg_cholesky.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_linalg_cholesky(mlx_array *res, const mlx_array a, bool upper, const mlx_stream s)
     * }
     */
    public static int mlx_linalg_cholesky(MemorySegment res, MemorySegment a, boolean upper, MemorySegment s) {
        var mh$ = mlx_linalg_cholesky.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_linalg_cholesky", res, a, upper, s);
            }
            return (int)mh$.invokeExact(res, a, upper, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_linalg_cholesky_inv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_linalg_cholesky_inv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_linalg_cholesky_inv(mlx_array *res, const mlx_array a, bool upper, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_linalg_cholesky_inv$descriptor() {
        return mlx_linalg_cholesky_inv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_linalg_cholesky_inv(mlx_array *res, const mlx_array a, bool upper, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_linalg_cholesky_inv$handle() {
        return mlx_linalg_cholesky_inv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_linalg_cholesky_inv(mlx_array *res, const mlx_array a, bool upper, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_linalg_cholesky_inv$address() {
        return mlx_linalg_cholesky_inv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_linalg_cholesky_inv(mlx_array *res, const mlx_array a, bool upper, const mlx_stream s)
     * }
     */
    public static int mlx_linalg_cholesky_inv(MemorySegment res, MemorySegment a, boolean upper, MemorySegment s) {
        var mh$ = mlx_linalg_cholesky_inv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_linalg_cholesky_inv", res, a, upper, s);
            }
            return (int)mh$.invokeExact(res, a, upper, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_linalg_cross {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_linalg_cross");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_linalg_cross(mlx_array *res, const mlx_array a, const mlx_array b, int axis, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_linalg_cross$descriptor() {
        return mlx_linalg_cross.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_linalg_cross(mlx_array *res, const mlx_array a, const mlx_array b, int axis, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_linalg_cross$handle() {
        return mlx_linalg_cross.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_linalg_cross(mlx_array *res, const mlx_array a, const mlx_array b, int axis, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_linalg_cross$address() {
        return mlx_linalg_cross.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_linalg_cross(mlx_array *res, const mlx_array a, const mlx_array b, int axis, const mlx_stream s)
     * }
     */
    public static int mlx_linalg_cross(MemorySegment res, MemorySegment a, MemorySegment b, int axis, MemorySegment s) {
        var mh$ = mlx_linalg_cross.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_linalg_cross", res, a, b, axis, s);
            }
            return (int)mh$.invokeExact(res, a, b, axis, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_linalg_eigh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_linalg_eigh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_linalg_eigh(mlx_array *res_0, mlx_array *res_1, const mlx_array a, const char *UPLO, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_linalg_eigh$descriptor() {
        return mlx_linalg_eigh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_linalg_eigh(mlx_array *res_0, mlx_array *res_1, const mlx_array a, const char *UPLO, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_linalg_eigh$handle() {
        return mlx_linalg_eigh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_linalg_eigh(mlx_array *res_0, mlx_array *res_1, const mlx_array a, const char *UPLO, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_linalg_eigh$address() {
        return mlx_linalg_eigh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_linalg_eigh(mlx_array *res_0, mlx_array *res_1, const mlx_array a, const char *UPLO, const mlx_stream s)
     * }
     */
    public static int mlx_linalg_eigh(MemorySegment res_0, MemorySegment res_1, MemorySegment a, MemorySegment UPLO, MemorySegment s) {
        var mh$ = mlx_linalg_eigh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_linalg_eigh", res_0, res_1, a, UPLO, s);
            }
            return (int)mh$.invokeExact(res_0, res_1, a, UPLO, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_linalg_eigvalsh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_linalg_eigvalsh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_linalg_eigvalsh(mlx_array *res, const mlx_array a, const char *UPLO, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_linalg_eigvalsh$descriptor() {
        return mlx_linalg_eigvalsh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_linalg_eigvalsh(mlx_array *res, const mlx_array a, const char *UPLO, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_linalg_eigvalsh$handle() {
        return mlx_linalg_eigvalsh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_linalg_eigvalsh(mlx_array *res, const mlx_array a, const char *UPLO, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_linalg_eigvalsh$address() {
        return mlx_linalg_eigvalsh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_linalg_eigvalsh(mlx_array *res, const mlx_array a, const char *UPLO, const mlx_stream s)
     * }
     */
    public static int mlx_linalg_eigvalsh(MemorySegment res, MemorySegment a, MemorySegment UPLO, MemorySegment s) {
        var mh$ = mlx_linalg_eigvalsh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_linalg_eigvalsh", res, a, UPLO, s);
            }
            return (int)mh$.invokeExact(res, a, UPLO, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_linalg_inv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_linalg_inv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_linalg_inv(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_linalg_inv$descriptor() {
        return mlx_linalg_inv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_linalg_inv(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_linalg_inv$handle() {
        return mlx_linalg_inv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_linalg_inv(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_linalg_inv$address() {
        return mlx_linalg_inv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_linalg_inv(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_linalg_inv(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_linalg_inv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_linalg_inv", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_linalg_lu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_linalg_lu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_linalg_lu(mlx_vector_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_linalg_lu$descriptor() {
        return mlx_linalg_lu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_linalg_lu(mlx_vector_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_linalg_lu$handle() {
        return mlx_linalg_lu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_linalg_lu(mlx_vector_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_linalg_lu$address() {
        return mlx_linalg_lu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_linalg_lu(mlx_vector_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_linalg_lu(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_linalg_lu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_linalg_lu", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_linalg_lu_factor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_linalg_lu_factor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_linalg_lu_factor(mlx_array *res_0, mlx_array *res_1, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_linalg_lu_factor$descriptor() {
        return mlx_linalg_lu_factor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_linalg_lu_factor(mlx_array *res_0, mlx_array *res_1, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_linalg_lu_factor$handle() {
        return mlx_linalg_lu_factor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_linalg_lu_factor(mlx_array *res_0, mlx_array *res_1, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_linalg_lu_factor$address() {
        return mlx_linalg_lu_factor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_linalg_lu_factor(mlx_array *res_0, mlx_array *res_1, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_linalg_lu_factor(MemorySegment res_0, MemorySegment res_1, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_linalg_lu_factor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_linalg_lu_factor", res_0, res_1, a, s);
            }
            return (int)mh$.invokeExact(res_0, res_1, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_linalg_norm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_DOUBLE,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_linalg_norm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_linalg_norm(mlx_array *res, const mlx_array a, double ord, const int *axis, size_t axis_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_linalg_norm$descriptor() {
        return mlx_linalg_norm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_linalg_norm(mlx_array *res, const mlx_array a, double ord, const int *axis, size_t axis_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_linalg_norm$handle() {
        return mlx_linalg_norm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_linalg_norm(mlx_array *res, const mlx_array a, double ord, const int *axis, size_t axis_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_linalg_norm$address() {
        return mlx_linalg_norm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_linalg_norm(mlx_array *res, const mlx_array a, double ord, const int *axis, size_t axis_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_linalg_norm(MemorySegment res, MemorySegment a, double ord, MemorySegment axis, long axis_num, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_linalg_norm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_linalg_norm", res, a, ord, axis, axis_num, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, ord, axis, axis_num, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_linalg_norm_matrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_linalg_norm_matrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_linalg_norm_matrix(mlx_array *res, const mlx_array a, const char *ord, const int *axis, size_t axis_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_linalg_norm_matrix$descriptor() {
        return mlx_linalg_norm_matrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_linalg_norm_matrix(mlx_array *res, const mlx_array a, const char *ord, const int *axis, size_t axis_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_linalg_norm_matrix$handle() {
        return mlx_linalg_norm_matrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_linalg_norm_matrix(mlx_array *res, const mlx_array a, const char *ord, const int *axis, size_t axis_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_linalg_norm_matrix$address() {
        return mlx_linalg_norm_matrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_linalg_norm_matrix(mlx_array *res, const mlx_array a, const char *ord, const int *axis, size_t axis_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_linalg_norm_matrix(MemorySegment res, MemorySegment a, MemorySegment ord, MemorySegment axis, long axis_num, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_linalg_norm_matrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_linalg_norm_matrix", res, a, ord, axis, axis_num, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, ord, axis, axis_num, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_linalg_norm_l2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_linalg_norm_l2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_linalg_norm_l2(mlx_array *res, const mlx_array a, const int *axis, size_t axis_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_linalg_norm_l2$descriptor() {
        return mlx_linalg_norm_l2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_linalg_norm_l2(mlx_array *res, const mlx_array a, const int *axis, size_t axis_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_linalg_norm_l2$handle() {
        return mlx_linalg_norm_l2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_linalg_norm_l2(mlx_array *res, const mlx_array a, const int *axis, size_t axis_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_linalg_norm_l2$address() {
        return mlx_linalg_norm_l2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_linalg_norm_l2(mlx_array *res, const mlx_array a, const int *axis, size_t axis_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_linalg_norm_l2(MemorySegment res, MemorySegment a, MemorySegment axis, long axis_num, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_linalg_norm_l2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_linalg_norm_l2", res, a, axis, axis_num, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, axis, axis_num, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_linalg_pinv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_linalg_pinv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_linalg_pinv(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_linalg_pinv$descriptor() {
        return mlx_linalg_pinv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_linalg_pinv(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_linalg_pinv$handle() {
        return mlx_linalg_pinv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_linalg_pinv(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_linalg_pinv$address() {
        return mlx_linalg_pinv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_linalg_pinv(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_linalg_pinv(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_linalg_pinv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_linalg_pinv", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_linalg_qr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_linalg_qr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_linalg_qr(mlx_array *res_0, mlx_array *res_1, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_linalg_qr$descriptor() {
        return mlx_linalg_qr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_linalg_qr(mlx_array *res_0, mlx_array *res_1, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_linalg_qr$handle() {
        return mlx_linalg_qr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_linalg_qr(mlx_array *res_0, mlx_array *res_1, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_linalg_qr$address() {
        return mlx_linalg_qr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_linalg_qr(mlx_array *res_0, mlx_array *res_1, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_linalg_qr(MemorySegment res_0, MemorySegment res_1, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_linalg_qr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_linalg_qr", res_0, res_1, a, s);
            }
            return (int)mh$.invokeExact(res_0, res_1, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_linalg_solve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_linalg_solve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_linalg_solve(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_linalg_solve$descriptor() {
        return mlx_linalg_solve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_linalg_solve(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_linalg_solve$handle() {
        return mlx_linalg_solve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_linalg_solve(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_linalg_solve$address() {
        return mlx_linalg_solve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_linalg_solve(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_linalg_solve(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_linalg_solve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_linalg_solve", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_linalg_solve_triangular {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_linalg_solve_triangular");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_linalg_solve_triangular(mlx_array *res, const mlx_array a, const mlx_array b, bool upper, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_linalg_solve_triangular$descriptor() {
        return mlx_linalg_solve_triangular.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_linalg_solve_triangular(mlx_array *res, const mlx_array a, const mlx_array b, bool upper, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_linalg_solve_triangular$handle() {
        return mlx_linalg_solve_triangular.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_linalg_solve_triangular(mlx_array *res, const mlx_array a, const mlx_array b, bool upper, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_linalg_solve_triangular$address() {
        return mlx_linalg_solve_triangular.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_linalg_solve_triangular(mlx_array *res, const mlx_array a, const mlx_array b, bool upper, const mlx_stream s)
     * }
     */
    public static int mlx_linalg_solve_triangular(MemorySegment res, MemorySegment a, MemorySegment b, boolean upper, MemorySegment s) {
        var mh$ = mlx_linalg_solve_triangular.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_linalg_solve_triangular", res, a, b, upper, s);
            }
            return (int)mh$.invokeExact(res, a, b, upper, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_linalg_svd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_linalg_svd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_linalg_svd(mlx_vector_array *res, const mlx_array a, bool compute_uv, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_linalg_svd$descriptor() {
        return mlx_linalg_svd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_linalg_svd(mlx_vector_array *res, const mlx_array a, bool compute_uv, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_linalg_svd$handle() {
        return mlx_linalg_svd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_linalg_svd(mlx_vector_array *res, const mlx_array a, bool compute_uv, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_linalg_svd$address() {
        return mlx_linalg_svd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_linalg_svd(mlx_vector_array *res, const mlx_array a, bool compute_uv, const mlx_stream s)
     * }
     */
    public static int mlx_linalg_svd(MemorySegment res, MemorySegment a, boolean compute_uv, MemorySegment s) {
        var mh$ = mlx_linalg_svd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_linalg_svd", res, a, compute_uv, s);
            }
            return (int)mh$.invokeExact(res, a, compute_uv, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_linalg_tri_inv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_linalg_tri_inv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_linalg_tri_inv(mlx_array *res, const mlx_array a, bool upper, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_linalg_tri_inv$descriptor() {
        return mlx_linalg_tri_inv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_linalg_tri_inv(mlx_array *res, const mlx_array a, bool upper, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_linalg_tri_inv$handle() {
        return mlx_linalg_tri_inv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_linalg_tri_inv(mlx_array *res, const mlx_array a, bool upper, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_linalg_tri_inv$address() {
        return mlx_linalg_tri_inv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_linalg_tri_inv(mlx_array *res, const mlx_array a, bool upper, const mlx_stream s)
     * }
     */
    public static int mlx_linalg_tri_inv(MemorySegment res, MemorySegment a, boolean upper, MemorySegment s) {
        var mh$ = mlx_linalg_tri_inv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_linalg_tri_inv", res, a, upper, s);
            }
            return (int)mh$.invokeExact(res, a, upper, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int mlx_clear_cache()
     * }
     */
    public static class mlx_clear_cache {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_h.C_INT        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_clear_cache");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private mlx_clear_cache(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int mlx_clear_cache()
         * }
         */
        public static mlx_clear_cache makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new mlx_clear_cache(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("mlx_clear_cache", x0);
                }
                return (int) spreader.invokeExact(x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class mlx_get_active_memory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_get_active_memory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_get_active_memory(size_t *res)
     * }
     */
    public static FunctionDescriptor mlx_get_active_memory$descriptor() {
        return mlx_get_active_memory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_get_active_memory(size_t *res)
     * }
     */
    public static MethodHandle mlx_get_active_memory$handle() {
        return mlx_get_active_memory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_get_active_memory(size_t *res)
     * }
     */
    public static MemorySegment mlx_get_active_memory$address() {
        return mlx_get_active_memory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_get_active_memory(size_t *res)
     * }
     */
    public static int mlx_get_active_memory(MemorySegment res) {
        var mh$ = mlx_get_active_memory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_get_active_memory", res);
            }
            return (int)mh$.invokeExact(res);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_get_cache_memory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_get_cache_memory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_get_cache_memory(size_t *res)
     * }
     */
    public static FunctionDescriptor mlx_get_cache_memory$descriptor() {
        return mlx_get_cache_memory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_get_cache_memory(size_t *res)
     * }
     */
    public static MethodHandle mlx_get_cache_memory$handle() {
        return mlx_get_cache_memory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_get_cache_memory(size_t *res)
     * }
     */
    public static MemorySegment mlx_get_cache_memory$address() {
        return mlx_get_cache_memory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_get_cache_memory(size_t *res)
     * }
     */
    public static int mlx_get_cache_memory(MemorySegment res) {
        var mh$ = mlx_get_cache_memory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_get_cache_memory", res);
            }
            return (int)mh$.invokeExact(res);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_get_memory_limit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_get_memory_limit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_get_memory_limit(size_t *res)
     * }
     */
    public static FunctionDescriptor mlx_get_memory_limit$descriptor() {
        return mlx_get_memory_limit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_get_memory_limit(size_t *res)
     * }
     */
    public static MethodHandle mlx_get_memory_limit$handle() {
        return mlx_get_memory_limit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_get_memory_limit(size_t *res)
     * }
     */
    public static MemorySegment mlx_get_memory_limit$address() {
        return mlx_get_memory_limit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_get_memory_limit(size_t *res)
     * }
     */
    public static int mlx_get_memory_limit(MemorySegment res) {
        var mh$ = mlx_get_memory_limit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_get_memory_limit", res);
            }
            return (int)mh$.invokeExact(res);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_get_peak_memory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_get_peak_memory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_get_peak_memory(size_t *res)
     * }
     */
    public static FunctionDescriptor mlx_get_peak_memory$descriptor() {
        return mlx_get_peak_memory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_get_peak_memory(size_t *res)
     * }
     */
    public static MethodHandle mlx_get_peak_memory$handle() {
        return mlx_get_peak_memory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_get_peak_memory(size_t *res)
     * }
     */
    public static MemorySegment mlx_get_peak_memory$address() {
        return mlx_get_peak_memory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_get_peak_memory(size_t *res)
     * }
     */
    public static int mlx_get_peak_memory(MemorySegment res) {
        var mh$ = mlx_get_peak_memory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_get_peak_memory", res);
            }
            return (int)mh$.invokeExact(res);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int mlx_reset_peak_memory()
     * }
     */
    public static class mlx_reset_peak_memory {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_h.C_INT        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_reset_peak_memory");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private mlx_reset_peak_memory(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int mlx_reset_peak_memory()
         * }
         */
        public static mlx_reset_peak_memory makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new mlx_reset_peak_memory(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("mlx_reset_peak_memory", x0);
                }
                return (int) spreader.invokeExact(x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class mlx_set_cache_limit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_set_cache_limit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_set_cache_limit(size_t *res, size_t limit)
     * }
     */
    public static FunctionDescriptor mlx_set_cache_limit$descriptor() {
        return mlx_set_cache_limit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_set_cache_limit(size_t *res, size_t limit)
     * }
     */
    public static MethodHandle mlx_set_cache_limit$handle() {
        return mlx_set_cache_limit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_set_cache_limit(size_t *res, size_t limit)
     * }
     */
    public static MemorySegment mlx_set_cache_limit$address() {
        return mlx_set_cache_limit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_set_cache_limit(size_t *res, size_t limit)
     * }
     */
    public static int mlx_set_cache_limit(MemorySegment res, long limit) {
        var mh$ = mlx_set_cache_limit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_set_cache_limit", res, limit);
            }
            return (int)mh$.invokeExact(res, limit);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_set_memory_limit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_set_memory_limit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_set_memory_limit(size_t *res, size_t limit)
     * }
     */
    public static FunctionDescriptor mlx_set_memory_limit$descriptor() {
        return mlx_set_memory_limit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_set_memory_limit(size_t *res, size_t limit)
     * }
     */
    public static MethodHandle mlx_set_memory_limit$handle() {
        return mlx_set_memory_limit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_set_memory_limit(size_t *res, size_t limit)
     * }
     */
    public static MemorySegment mlx_set_memory_limit$address() {
        return mlx_set_memory_limit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_set_memory_limit(size_t *res, size_t limit)
     * }
     */
    public static int mlx_set_memory_limit(MemorySegment res, long limit) {
        var mh$ = mlx_set_memory_limit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_set_memory_limit", res, limit);
            }
            return (int)mh$.invokeExact(res, limit);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_set_wired_limit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_set_wired_limit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_set_wired_limit(size_t *res, size_t limit)
     * }
     */
    public static FunctionDescriptor mlx_set_wired_limit$descriptor() {
        return mlx_set_wired_limit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_set_wired_limit(size_t *res, size_t limit)
     * }
     */
    public static MethodHandle mlx_set_wired_limit$handle() {
        return mlx_set_wired_limit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_set_wired_limit(size_t *res, size_t limit)
     * }
     */
    public static MemorySegment mlx_set_wired_limit$address() {
        return mlx_set_wired_limit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_set_wired_limit(size_t *res, size_t limit)
     * }
     */
    public static int mlx_set_wired_limit(MemorySegment res, long limit) {
        var mh$ = mlx_set_wired_limit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_set_wired_limit", res, limit);
            }
            return (int)mh$.invokeExact(res, limit);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * mlx_metal_device_info_t mlx_metal_device_info()
     * }
     */
    public static class mlx_metal_device_info {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_metal_device_info_t_.layout()        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_metal_device_info");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private mlx_metal_device_info(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * mlx_metal_device_info_t mlx_metal_device_info()
         * }
         */
        public static mlx_metal_device_info makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new mlx_metal_device_info(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("mlx_metal_device_info", allocator, x0);
                }
                return (MemorySegment) spreader.invokeExact(allocator, x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class mlx_metal_is_available {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_metal_is_available");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_metal_is_available(bool *res)
     * }
     */
    public static FunctionDescriptor mlx_metal_is_available$descriptor() {
        return mlx_metal_is_available.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_metal_is_available(bool *res)
     * }
     */
    public static MethodHandle mlx_metal_is_available$handle() {
        return mlx_metal_is_available.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_metal_is_available(bool *res)
     * }
     */
    public static MemorySegment mlx_metal_is_available$address() {
        return mlx_metal_is_available.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_metal_is_available(bool *res)
     * }
     */
    public static int mlx_metal_is_available(MemorySegment res) {
        var mh$ = mlx_metal_is_available.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_metal_is_available", res);
            }
            return (int)mh$.invokeExact(res);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_metal_start_capture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_metal_start_capture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_metal_start_capture(const char *path)
     * }
     */
    public static FunctionDescriptor mlx_metal_start_capture$descriptor() {
        return mlx_metal_start_capture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_metal_start_capture(const char *path)
     * }
     */
    public static MethodHandle mlx_metal_start_capture$handle() {
        return mlx_metal_start_capture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_metal_start_capture(const char *path)
     * }
     */
    public static MemorySegment mlx_metal_start_capture$address() {
        return mlx_metal_start_capture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_metal_start_capture(const char *path)
     * }
     */
    public static int mlx_metal_start_capture(MemorySegment path) {
        var mh$ = mlx_metal_start_capture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_metal_start_capture", path);
            }
            return (int)mh$.invokeExact(path);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int mlx_metal_stop_capture()
     * }
     */
    public static class mlx_metal_stop_capture {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                mlx_h.C_INT        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_metal_stop_capture");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private mlx_metal_stop_capture(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int mlx_metal_stop_capture()
         * }
         */
        public static mlx_metal_stop_capture makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new mlx_metal_stop_capture(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("mlx_metal_stop_capture", x0);
                }
                return (int) spreader.invokeExact(x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class mlx_abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_abs(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_abs$descriptor() {
        return mlx_abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_abs(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_abs$handle() {
        return mlx_abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_abs(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_abs$address() {
        return mlx_abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_abs(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_abs(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_abs", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_add(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_add$descriptor() {
        return mlx_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_add(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_add$handle() {
        return mlx_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_add(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_add$address() {
        return mlx_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_add(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_add(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_add", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_addmm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_FLOAT,
            mlx_h.C_FLOAT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_addmm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_addmm(mlx_array *res, const mlx_array c, const mlx_array a, const mlx_array b, float alpha, float beta, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_addmm$descriptor() {
        return mlx_addmm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_addmm(mlx_array *res, const mlx_array c, const mlx_array a, const mlx_array b, float alpha, float beta, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_addmm$handle() {
        return mlx_addmm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_addmm(mlx_array *res, const mlx_array c, const mlx_array a, const mlx_array b, float alpha, float beta, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_addmm$address() {
        return mlx_addmm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_addmm(mlx_array *res, const mlx_array c, const mlx_array a, const mlx_array b, float alpha, float beta, const mlx_stream s)
     * }
     */
    public static int mlx_addmm(MemorySegment res, MemorySegment c, MemorySegment a, MemorySegment b, float alpha, float beta, MemorySegment s) {
        var mh$ = mlx_addmm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_addmm", res, c, a, b, alpha, beta, s);
            }
            return (int)mh$.invokeExact(res, c, a, b, alpha, beta, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_all_axes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_all_axes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_all_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_all_axes$descriptor() {
        return mlx_all_axes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_all_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_all_axes$handle() {
        return mlx_all_axes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_all_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_all_axes$address() {
        return mlx_all_axes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_all_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_all_axes(MemorySegment res, MemorySegment a, MemorySegment axes, long axes_num, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_all_axes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_all_axes", res, a, axes, axes_num, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, axes, axes_num, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_all_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_all_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_all_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_all_axis$descriptor() {
        return mlx_all_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_all_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_all_axis$handle() {
        return mlx_all_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_all_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_all_axis$address() {
        return mlx_all_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_all_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_all_axis(MemorySegment res, MemorySegment a, int axis, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_all_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_all_axis", res, a, axis, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, axis, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_all {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_all");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_all(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_all$descriptor() {
        return mlx_all.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_all(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_all$handle() {
        return mlx_all.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_all(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_all$address() {
        return mlx_all.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_all(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_all(MemorySegment res, MemorySegment a, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_all.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_all", res, a, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_allclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_DOUBLE,
            mlx_h.C_DOUBLE,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_allclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_allclose(mlx_array *res, const mlx_array a, const mlx_array b, double rtol, double atol, bool equal_nan, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_allclose$descriptor() {
        return mlx_allclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_allclose(mlx_array *res, const mlx_array a, const mlx_array b, double rtol, double atol, bool equal_nan, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_allclose$handle() {
        return mlx_allclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_allclose(mlx_array *res, const mlx_array a, const mlx_array b, double rtol, double atol, bool equal_nan, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_allclose$address() {
        return mlx_allclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_allclose(mlx_array *res, const mlx_array a, const mlx_array b, double rtol, double atol, bool equal_nan, const mlx_stream s)
     * }
     */
    public static int mlx_allclose(MemorySegment res, MemorySegment a, MemorySegment b, double rtol, double atol, boolean equal_nan, MemorySegment s) {
        var mh$ = mlx_allclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_allclose", res, a, b, rtol, atol, equal_nan, s);
            }
            return (int)mh$.invokeExact(res, a, b, rtol, atol, equal_nan, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_any_axes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_any_axes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_any_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_any_axes$descriptor() {
        return mlx_any_axes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_any_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_any_axes$handle() {
        return mlx_any_axes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_any_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_any_axes$address() {
        return mlx_any_axes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_any_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_any_axes(MemorySegment res, MemorySegment a, MemorySegment axes, long axes_num, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_any_axes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_any_axes", res, a, axes, axes_num, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, axes, axes_num, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_any_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_any_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_any_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_any_axis$descriptor() {
        return mlx_any_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_any_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_any_axis$handle() {
        return mlx_any_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_any_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_any_axis$address() {
        return mlx_any_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_any_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_any_axis(MemorySegment res, MemorySegment a, int axis, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_any_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_any_axis", res, a, axis, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, axis, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_any {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_any");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_any(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_any$descriptor() {
        return mlx_any.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_any(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_any$handle() {
        return mlx_any.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_any(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_any$address() {
        return mlx_any.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_any(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_any(MemorySegment res, MemorySegment a, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_any.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_any", res, a, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_arange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_DOUBLE,
            mlx_h.C_DOUBLE,
            mlx_h.C_DOUBLE,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_arange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_arange(mlx_array *res, double start, double stop, double step, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_arange$descriptor() {
        return mlx_arange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_arange(mlx_array *res, double start, double stop, double step, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_arange$handle() {
        return mlx_arange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_arange(mlx_array *res, double start, double stop, double step, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_arange$address() {
        return mlx_arange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_arange(mlx_array *res, double start, double stop, double step, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static int mlx_arange(MemorySegment res, double start, double stop, double step, int dtype, MemorySegment s) {
        var mh$ = mlx_arange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_arange", res, start, stop, step, dtype, s);
            }
            return (int)mh$.invokeExact(res, start, stop, step, dtype, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_arccos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_arccos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_arccos(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_arccos$descriptor() {
        return mlx_arccos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_arccos(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_arccos$handle() {
        return mlx_arccos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_arccos(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_arccos$address() {
        return mlx_arccos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_arccos(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_arccos(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_arccos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_arccos", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_arccosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_arccosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_arccosh(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_arccosh$descriptor() {
        return mlx_arccosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_arccosh(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_arccosh$handle() {
        return mlx_arccosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_arccosh(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_arccosh$address() {
        return mlx_arccosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_arccosh(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_arccosh(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_arccosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_arccosh", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_arcsin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_arcsin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_arcsin(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_arcsin$descriptor() {
        return mlx_arcsin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_arcsin(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_arcsin$handle() {
        return mlx_arcsin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_arcsin(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_arcsin$address() {
        return mlx_arcsin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_arcsin(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_arcsin(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_arcsin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_arcsin", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_arcsinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_arcsinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_arcsinh(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_arcsinh$descriptor() {
        return mlx_arcsinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_arcsinh(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_arcsinh$handle() {
        return mlx_arcsinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_arcsinh(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_arcsinh$address() {
        return mlx_arcsinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_arcsinh(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_arcsinh(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_arcsinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_arcsinh", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_arctan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_arctan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_arctan(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_arctan$descriptor() {
        return mlx_arctan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_arctan(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_arctan$handle() {
        return mlx_arctan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_arctan(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_arctan$address() {
        return mlx_arctan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_arctan(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_arctan(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_arctan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_arctan", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_arctan2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_arctan2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_arctan2(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_arctan2$descriptor() {
        return mlx_arctan2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_arctan2(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_arctan2$handle() {
        return mlx_arctan2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_arctan2(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_arctan2$address() {
        return mlx_arctan2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_arctan2(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_arctan2(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_arctan2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_arctan2", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_arctanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_arctanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_arctanh(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_arctanh$descriptor() {
        return mlx_arctanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_arctanh(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_arctanh$handle() {
        return mlx_arctanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_arctanh(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_arctanh$address() {
        return mlx_arctanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_arctanh(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_arctanh(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_arctanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_arctanh", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_argmax_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_argmax_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_argmax_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_argmax_axis$descriptor() {
        return mlx_argmax_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_argmax_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_argmax_axis$handle() {
        return mlx_argmax_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_argmax_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_argmax_axis$address() {
        return mlx_argmax_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_argmax_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_argmax_axis(MemorySegment res, MemorySegment a, int axis, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_argmax_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_argmax_axis", res, a, axis, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, axis, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_argmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_argmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_argmax(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_argmax$descriptor() {
        return mlx_argmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_argmax(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_argmax$handle() {
        return mlx_argmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_argmax(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_argmax$address() {
        return mlx_argmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_argmax(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_argmax(MemorySegment res, MemorySegment a, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_argmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_argmax", res, a, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_argmin_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_argmin_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_argmin_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_argmin_axis$descriptor() {
        return mlx_argmin_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_argmin_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_argmin_axis$handle() {
        return mlx_argmin_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_argmin_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_argmin_axis$address() {
        return mlx_argmin_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_argmin_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_argmin_axis(MemorySegment res, MemorySegment a, int axis, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_argmin_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_argmin_axis", res, a, axis, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, axis, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_argmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_argmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_argmin(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_argmin$descriptor() {
        return mlx_argmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_argmin(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_argmin$handle() {
        return mlx_argmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_argmin(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_argmin$address() {
        return mlx_argmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_argmin(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_argmin(MemorySegment res, MemorySegment a, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_argmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_argmin", res, a, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_argpartition_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_argpartition_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_argpartition_axis(mlx_array *res, const mlx_array a, int kth, int axis, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_argpartition_axis$descriptor() {
        return mlx_argpartition_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_argpartition_axis(mlx_array *res, const mlx_array a, int kth, int axis, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_argpartition_axis$handle() {
        return mlx_argpartition_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_argpartition_axis(mlx_array *res, const mlx_array a, int kth, int axis, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_argpartition_axis$address() {
        return mlx_argpartition_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_argpartition_axis(mlx_array *res, const mlx_array a, int kth, int axis, const mlx_stream s)
     * }
     */
    public static int mlx_argpartition_axis(MemorySegment res, MemorySegment a, int kth, int axis, MemorySegment s) {
        var mh$ = mlx_argpartition_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_argpartition_axis", res, a, kth, axis, s);
            }
            return (int)mh$.invokeExact(res, a, kth, axis, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_argpartition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_argpartition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_argpartition(mlx_array *res, const mlx_array a, int kth, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_argpartition$descriptor() {
        return mlx_argpartition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_argpartition(mlx_array *res, const mlx_array a, int kth, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_argpartition$handle() {
        return mlx_argpartition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_argpartition(mlx_array *res, const mlx_array a, int kth, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_argpartition$address() {
        return mlx_argpartition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_argpartition(mlx_array *res, const mlx_array a, int kth, const mlx_stream s)
     * }
     */
    public static int mlx_argpartition(MemorySegment res, MemorySegment a, int kth, MemorySegment s) {
        var mh$ = mlx_argpartition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_argpartition", res, a, kth, s);
            }
            return (int)mh$.invokeExact(res, a, kth, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_argsort_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_argsort_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_argsort_axis(mlx_array *res, const mlx_array a, int axis, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_argsort_axis$descriptor() {
        return mlx_argsort_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_argsort_axis(mlx_array *res, const mlx_array a, int axis, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_argsort_axis$handle() {
        return mlx_argsort_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_argsort_axis(mlx_array *res, const mlx_array a, int axis, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_argsort_axis$address() {
        return mlx_argsort_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_argsort_axis(mlx_array *res, const mlx_array a, int axis, const mlx_stream s)
     * }
     */
    public static int mlx_argsort_axis(MemorySegment res, MemorySegment a, int axis, MemorySegment s) {
        var mh$ = mlx_argsort_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_argsort_axis", res, a, axis, s);
            }
            return (int)mh$.invokeExact(res, a, axis, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_argsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_argsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_argsort(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_argsort$descriptor() {
        return mlx_argsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_argsort(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_argsort$handle() {
        return mlx_argsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_argsort(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_argsort$address() {
        return mlx_argsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_argsort(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_argsort(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_argsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_argsort", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_array_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_array_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_array_equal(mlx_array *res, const mlx_array a, const mlx_array b, bool equal_nan, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_array_equal$descriptor() {
        return mlx_array_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_array_equal(mlx_array *res, const mlx_array a, const mlx_array b, bool equal_nan, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_array_equal$handle() {
        return mlx_array_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_array_equal(mlx_array *res, const mlx_array a, const mlx_array b, bool equal_nan, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_array_equal$address() {
        return mlx_array_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_array_equal(mlx_array *res, const mlx_array a, const mlx_array b, bool equal_nan, const mlx_stream s)
     * }
     */
    public static int mlx_array_equal(MemorySegment res, MemorySegment a, MemorySegment b, boolean equal_nan, MemorySegment s) {
        var mh$ = mlx_array_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_array_equal", res, a, b, equal_nan, s);
            }
            return (int)mh$.invokeExact(res, a, b, equal_nan, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_as_strided {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_as_strided");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_as_strided(mlx_array *res, const mlx_array a, const int *shape, size_t shape_num, const int64_t *strides, size_t strides_num, size_t offset, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_as_strided$descriptor() {
        return mlx_as_strided.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_as_strided(mlx_array *res, const mlx_array a, const int *shape, size_t shape_num, const int64_t *strides, size_t strides_num, size_t offset, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_as_strided$handle() {
        return mlx_as_strided.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_as_strided(mlx_array *res, const mlx_array a, const int *shape, size_t shape_num, const int64_t *strides, size_t strides_num, size_t offset, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_as_strided$address() {
        return mlx_as_strided.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_as_strided(mlx_array *res, const mlx_array a, const int *shape, size_t shape_num, const int64_t *strides, size_t strides_num, size_t offset, const mlx_stream s)
     * }
     */
    public static int mlx_as_strided(MemorySegment res, MemorySegment a, MemorySegment shape, long shape_num, MemorySegment strides, long strides_num, long offset, MemorySegment s) {
        var mh$ = mlx_as_strided.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_as_strided", res, a, shape, shape_num, strides, strides_num, offset, s);
            }
            return (int)mh$.invokeExact(res, a, shape, shape_num, strides, strides_num, offset, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_astype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_astype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_astype(mlx_array *res, const mlx_array a, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_astype$descriptor() {
        return mlx_astype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_astype(mlx_array *res, const mlx_array a, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_astype$handle() {
        return mlx_astype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_astype(mlx_array *res, const mlx_array a, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_astype$address() {
        return mlx_astype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_astype(mlx_array *res, const mlx_array a, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static int mlx_astype(MemorySegment res, MemorySegment a, int dtype, MemorySegment s) {
        var mh$ = mlx_astype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_astype", res, a, dtype, s);
            }
            return (int)mh$.invokeExact(res, a, dtype, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_atleast_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_atleast_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_atleast_1d(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_atleast_1d$descriptor() {
        return mlx_atleast_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_atleast_1d(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_atleast_1d$handle() {
        return mlx_atleast_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_atleast_1d(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_atleast_1d$address() {
        return mlx_atleast_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_atleast_1d(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_atleast_1d(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_atleast_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_atleast_1d", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_atleast_2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_atleast_2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_atleast_2d(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_atleast_2d$descriptor() {
        return mlx_atleast_2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_atleast_2d(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_atleast_2d$handle() {
        return mlx_atleast_2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_atleast_2d(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_atleast_2d$address() {
        return mlx_atleast_2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_atleast_2d(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_atleast_2d(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_atleast_2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_atleast_2d", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_atleast_3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_atleast_3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_atleast_3d(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_atleast_3d$descriptor() {
        return mlx_atleast_3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_atleast_3d(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_atleast_3d$handle() {
        return mlx_atleast_3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_atleast_3d(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_atleast_3d$address() {
        return mlx_atleast_3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_atleast_3d(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_atleast_3d(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_atleast_3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_atleast_3d", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_bitwise_and {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_bitwise_and");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_bitwise_and(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_bitwise_and$descriptor() {
        return mlx_bitwise_and.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_bitwise_and(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_bitwise_and$handle() {
        return mlx_bitwise_and.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_bitwise_and(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_bitwise_and$address() {
        return mlx_bitwise_and.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_bitwise_and(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_bitwise_and(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_bitwise_and.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_bitwise_and", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_bitwise_invert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_bitwise_invert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_bitwise_invert(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_bitwise_invert$descriptor() {
        return mlx_bitwise_invert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_bitwise_invert(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_bitwise_invert$handle() {
        return mlx_bitwise_invert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_bitwise_invert(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_bitwise_invert$address() {
        return mlx_bitwise_invert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_bitwise_invert(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_bitwise_invert(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_bitwise_invert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_bitwise_invert", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_bitwise_or {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_bitwise_or");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_bitwise_or(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_bitwise_or$descriptor() {
        return mlx_bitwise_or.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_bitwise_or(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_bitwise_or$handle() {
        return mlx_bitwise_or.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_bitwise_or(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_bitwise_or$address() {
        return mlx_bitwise_or.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_bitwise_or(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_bitwise_or(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_bitwise_or.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_bitwise_or", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_bitwise_xor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_bitwise_xor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_bitwise_xor(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_bitwise_xor$descriptor() {
        return mlx_bitwise_xor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_bitwise_xor(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_bitwise_xor$handle() {
        return mlx_bitwise_xor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_bitwise_xor(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_bitwise_xor$address() {
        return mlx_bitwise_xor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_bitwise_xor(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_bitwise_xor(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_bitwise_xor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_bitwise_xor", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_block_masked_mm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_block_masked_mm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_block_masked_mm(mlx_array *res, const mlx_array a, const mlx_array b, int block_size, const mlx_array mask_out, const mlx_array mask_lhs, const mlx_array mask_rhs, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_block_masked_mm$descriptor() {
        return mlx_block_masked_mm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_block_masked_mm(mlx_array *res, const mlx_array a, const mlx_array b, int block_size, const mlx_array mask_out, const mlx_array mask_lhs, const mlx_array mask_rhs, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_block_masked_mm$handle() {
        return mlx_block_masked_mm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_block_masked_mm(mlx_array *res, const mlx_array a, const mlx_array b, int block_size, const mlx_array mask_out, const mlx_array mask_lhs, const mlx_array mask_rhs, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_block_masked_mm$address() {
        return mlx_block_masked_mm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_block_masked_mm(mlx_array *res, const mlx_array a, const mlx_array b, int block_size, const mlx_array mask_out, const mlx_array mask_lhs, const mlx_array mask_rhs, const mlx_stream s)
     * }
     */
    public static int mlx_block_masked_mm(MemorySegment res, MemorySegment a, MemorySegment b, int block_size, MemorySegment mask_out, MemorySegment mask_lhs, MemorySegment mask_rhs, MemorySegment s) {
        var mh$ = mlx_block_masked_mm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_block_masked_mm", res, a, b, block_size, mask_out, mask_lhs, mask_rhs, s);
            }
            return (int)mh$.invokeExact(res, a, b, block_size, mask_out, mask_lhs, mask_rhs, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_broadcast_arrays {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_vector_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_broadcast_arrays");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_broadcast_arrays(mlx_vector_array *res, const mlx_vector_array inputs, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_broadcast_arrays$descriptor() {
        return mlx_broadcast_arrays.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_broadcast_arrays(mlx_vector_array *res, const mlx_vector_array inputs, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_broadcast_arrays$handle() {
        return mlx_broadcast_arrays.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_broadcast_arrays(mlx_vector_array *res, const mlx_vector_array inputs, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_broadcast_arrays$address() {
        return mlx_broadcast_arrays.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_broadcast_arrays(mlx_vector_array *res, const mlx_vector_array inputs, const mlx_stream s)
     * }
     */
    public static int mlx_broadcast_arrays(MemorySegment res, MemorySegment inputs, MemorySegment s) {
        var mh$ = mlx_broadcast_arrays.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_broadcast_arrays", res, inputs, s);
            }
            return (int)mh$.invokeExact(res, inputs, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_broadcast_to {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_broadcast_to");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_broadcast_to(mlx_array *res, const mlx_array a, const int *shape, size_t shape_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_broadcast_to$descriptor() {
        return mlx_broadcast_to.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_broadcast_to(mlx_array *res, const mlx_array a, const int *shape, size_t shape_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_broadcast_to$handle() {
        return mlx_broadcast_to.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_broadcast_to(mlx_array *res, const mlx_array a, const int *shape, size_t shape_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_broadcast_to$address() {
        return mlx_broadcast_to.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_broadcast_to(mlx_array *res, const mlx_array a, const int *shape, size_t shape_num, const mlx_stream s)
     * }
     */
    public static int mlx_broadcast_to(MemorySegment res, MemorySegment a, MemorySegment shape, long shape_num, MemorySegment s) {
        var mh$ = mlx_broadcast_to.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_broadcast_to", res, a, shape, shape_num, s);
            }
            return (int)mh$.invokeExact(res, a, shape, shape_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_ceil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_ceil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_ceil(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_ceil$descriptor() {
        return mlx_ceil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_ceil(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_ceil$handle() {
        return mlx_ceil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_ceil(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_ceil$address() {
        return mlx_ceil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_ceil(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_ceil(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_ceil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_ceil", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_clip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_clip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_clip(mlx_array *res, const mlx_array a, const mlx_array a_min, const mlx_array a_max, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_clip$descriptor() {
        return mlx_clip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_clip(mlx_array *res, const mlx_array a, const mlx_array a_min, const mlx_array a_max, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_clip$handle() {
        return mlx_clip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_clip(mlx_array *res, const mlx_array a, const mlx_array a_min, const mlx_array a_max, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_clip$address() {
        return mlx_clip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_clip(mlx_array *res, const mlx_array a, const mlx_array a_min, const mlx_array a_max, const mlx_stream s)
     * }
     */
    public static int mlx_clip(MemorySegment res, MemorySegment a, MemorySegment a_min, MemorySegment a_max, MemorySegment s) {
        var mh$ = mlx_clip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_clip", res, a, a_min, a_max, s);
            }
            return (int)mh$.invokeExact(res, a, a_min, a_max, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_concatenate_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_vector_array_.layout(),
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_concatenate_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_concatenate_axis(mlx_array *res, const mlx_vector_array arrays, int axis, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_concatenate_axis$descriptor() {
        return mlx_concatenate_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_concatenate_axis(mlx_array *res, const mlx_vector_array arrays, int axis, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_concatenate_axis$handle() {
        return mlx_concatenate_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_concatenate_axis(mlx_array *res, const mlx_vector_array arrays, int axis, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_concatenate_axis$address() {
        return mlx_concatenate_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_concatenate_axis(mlx_array *res, const mlx_vector_array arrays, int axis, const mlx_stream s)
     * }
     */
    public static int mlx_concatenate_axis(MemorySegment res, MemorySegment arrays, int axis, MemorySegment s) {
        var mh$ = mlx_concatenate_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_concatenate_axis", res, arrays, axis, s);
            }
            return (int)mh$.invokeExact(res, arrays, axis, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_concatenate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_vector_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_concatenate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_concatenate(mlx_array *res, const mlx_vector_array arrays, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_concatenate$descriptor() {
        return mlx_concatenate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_concatenate(mlx_array *res, const mlx_vector_array arrays, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_concatenate$handle() {
        return mlx_concatenate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_concatenate(mlx_array *res, const mlx_vector_array arrays, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_concatenate$address() {
        return mlx_concatenate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_concatenate(mlx_array *res, const mlx_vector_array arrays, const mlx_stream s)
     * }
     */
    public static int mlx_concatenate(MemorySegment res, MemorySegment arrays, MemorySegment s) {
        var mh$ = mlx_concatenate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_concatenate", res, arrays, s);
            }
            return (int)mh$.invokeExact(res, arrays, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_conjugate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_conjugate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_conjugate(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_conjugate$descriptor() {
        return mlx_conjugate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_conjugate(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_conjugate$handle() {
        return mlx_conjugate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_conjugate(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_conjugate$address() {
        return mlx_conjugate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_conjugate(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_conjugate(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_conjugate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_conjugate", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_contiguous {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_contiguous");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_contiguous(mlx_array *res, const mlx_array a, bool allow_col_major, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_contiguous$descriptor() {
        return mlx_contiguous.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_contiguous(mlx_array *res, const mlx_array a, bool allow_col_major, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_contiguous$handle() {
        return mlx_contiguous.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_contiguous(mlx_array *res, const mlx_array a, bool allow_col_major, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_contiguous$address() {
        return mlx_contiguous.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_contiguous(mlx_array *res, const mlx_array a, bool allow_col_major, const mlx_stream s)
     * }
     */
    public static int mlx_contiguous(MemorySegment res, MemorySegment a, boolean allow_col_major, MemorySegment s) {
        var mh$ = mlx_contiguous.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_contiguous", res, a, allow_col_major, s);
            }
            return (int)mh$.invokeExact(res, a, allow_col_major, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_conv1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_conv1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_conv1d(mlx_array *res, const mlx_array input, const mlx_array weight, int stride, int padding, int dilation, int groups, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_conv1d$descriptor() {
        return mlx_conv1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_conv1d(mlx_array *res, const mlx_array input, const mlx_array weight, int stride, int padding, int dilation, int groups, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_conv1d$handle() {
        return mlx_conv1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_conv1d(mlx_array *res, const mlx_array input, const mlx_array weight, int stride, int padding, int dilation, int groups, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_conv1d$address() {
        return mlx_conv1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_conv1d(mlx_array *res, const mlx_array input, const mlx_array weight, int stride, int padding, int dilation, int groups, const mlx_stream s)
     * }
     */
    public static int mlx_conv1d(MemorySegment res, MemorySegment input, MemorySegment weight, int stride, int padding, int dilation, int groups, MemorySegment s) {
        var mh$ = mlx_conv1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_conv1d", res, input, weight, stride, padding, dilation, groups, s);
            }
            return (int)mh$.invokeExact(res, input, weight, stride, padding, dilation, groups, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_conv2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_conv2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_conv2d(mlx_array *res, const mlx_array input, const mlx_array weight, int stride_0, int stride_1, int padding_0, int padding_1, int dilation_0, int dilation_1, int groups, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_conv2d$descriptor() {
        return mlx_conv2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_conv2d(mlx_array *res, const mlx_array input, const mlx_array weight, int stride_0, int stride_1, int padding_0, int padding_1, int dilation_0, int dilation_1, int groups, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_conv2d$handle() {
        return mlx_conv2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_conv2d(mlx_array *res, const mlx_array input, const mlx_array weight, int stride_0, int stride_1, int padding_0, int padding_1, int dilation_0, int dilation_1, int groups, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_conv2d$address() {
        return mlx_conv2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_conv2d(mlx_array *res, const mlx_array input, const mlx_array weight, int stride_0, int stride_1, int padding_0, int padding_1, int dilation_0, int dilation_1, int groups, const mlx_stream s)
     * }
     */
    public static int mlx_conv2d(MemorySegment res, MemorySegment input, MemorySegment weight, int stride_0, int stride_1, int padding_0, int padding_1, int dilation_0, int dilation_1, int groups, MemorySegment s) {
        var mh$ = mlx_conv2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_conv2d", res, input, weight, stride_0, stride_1, padding_0, padding_1, dilation_0, dilation_1, groups, s);
            }
            return (int)mh$.invokeExact(res, input, weight, stride_0, stride_1, padding_0, padding_1, dilation_0, dilation_1, groups, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_conv3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_conv3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_conv3d(mlx_array *res, const mlx_array input, const mlx_array weight, int stride_0, int stride_1, int stride_2, int padding_0, int padding_1, int padding_2, int dilation_0, int dilation_1, int dilation_2, int groups, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_conv3d$descriptor() {
        return mlx_conv3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_conv3d(mlx_array *res, const mlx_array input, const mlx_array weight, int stride_0, int stride_1, int stride_2, int padding_0, int padding_1, int padding_2, int dilation_0, int dilation_1, int dilation_2, int groups, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_conv3d$handle() {
        return mlx_conv3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_conv3d(mlx_array *res, const mlx_array input, const mlx_array weight, int stride_0, int stride_1, int stride_2, int padding_0, int padding_1, int padding_2, int dilation_0, int dilation_1, int dilation_2, int groups, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_conv3d$address() {
        return mlx_conv3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_conv3d(mlx_array *res, const mlx_array input, const mlx_array weight, int stride_0, int stride_1, int stride_2, int padding_0, int padding_1, int padding_2, int dilation_0, int dilation_1, int dilation_2, int groups, const mlx_stream s)
     * }
     */
    public static int mlx_conv3d(MemorySegment res, MemorySegment input, MemorySegment weight, int stride_0, int stride_1, int stride_2, int padding_0, int padding_1, int padding_2, int dilation_0, int dilation_1, int dilation_2, int groups, MemorySegment s) {
        var mh$ = mlx_conv3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_conv3d", res, input, weight, stride_0, stride_1, stride_2, padding_0, padding_1, padding_2, dilation_0, dilation_1, dilation_2, groups, s);
            }
            return (int)mh$.invokeExact(res, input, weight, stride_0, stride_1, stride_2, padding_0, padding_1, padding_2, dilation_0, dilation_1, dilation_2, groups, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_conv_general {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_INT,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_conv_general");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_conv_general(mlx_array *res, const mlx_array input, const mlx_array weight, const int *stride, size_t stride_num, const int *padding_lo, size_t padding_lo_num, const int *padding_hi, size_t padding_hi_num, const int *kernel_dilation, size_t kernel_dilation_num, const int *input_dilation, size_t input_dilation_num, int groups, bool flip, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_conv_general$descriptor() {
        return mlx_conv_general.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_conv_general(mlx_array *res, const mlx_array input, const mlx_array weight, const int *stride, size_t stride_num, const int *padding_lo, size_t padding_lo_num, const int *padding_hi, size_t padding_hi_num, const int *kernel_dilation, size_t kernel_dilation_num, const int *input_dilation, size_t input_dilation_num, int groups, bool flip, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_conv_general$handle() {
        return mlx_conv_general.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_conv_general(mlx_array *res, const mlx_array input, const mlx_array weight, const int *stride, size_t stride_num, const int *padding_lo, size_t padding_lo_num, const int *padding_hi, size_t padding_hi_num, const int *kernel_dilation, size_t kernel_dilation_num, const int *input_dilation, size_t input_dilation_num, int groups, bool flip, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_conv_general$address() {
        return mlx_conv_general.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_conv_general(mlx_array *res, const mlx_array input, const mlx_array weight, const int *stride, size_t stride_num, const int *padding_lo, size_t padding_lo_num, const int *padding_hi, size_t padding_hi_num, const int *kernel_dilation, size_t kernel_dilation_num, const int *input_dilation, size_t input_dilation_num, int groups, bool flip, const mlx_stream s)
     * }
     */
    public static int mlx_conv_general(MemorySegment res, MemorySegment input, MemorySegment weight, MemorySegment stride, long stride_num, MemorySegment padding_lo, long padding_lo_num, MemorySegment padding_hi, long padding_hi_num, MemorySegment kernel_dilation, long kernel_dilation_num, MemorySegment input_dilation, long input_dilation_num, int groups, boolean flip, MemorySegment s) {
        var mh$ = mlx_conv_general.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_conv_general", res, input, weight, stride, stride_num, padding_lo, padding_lo_num, padding_hi, padding_hi_num, kernel_dilation, kernel_dilation_num, input_dilation, input_dilation_num, groups, flip, s);
            }
            return (int)mh$.invokeExact(res, input, weight, stride, stride_num, padding_lo, padding_lo_num, padding_hi, padding_hi_num, kernel_dilation, kernel_dilation_num, input_dilation, input_dilation_num, groups, flip, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_conv_transpose1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_conv_transpose1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_conv_transpose1d(mlx_array *res, const mlx_array input, const mlx_array weight, int stride, int padding, int dilation, int output_padding, int groups, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_conv_transpose1d$descriptor() {
        return mlx_conv_transpose1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_conv_transpose1d(mlx_array *res, const mlx_array input, const mlx_array weight, int stride, int padding, int dilation, int output_padding, int groups, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_conv_transpose1d$handle() {
        return mlx_conv_transpose1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_conv_transpose1d(mlx_array *res, const mlx_array input, const mlx_array weight, int stride, int padding, int dilation, int output_padding, int groups, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_conv_transpose1d$address() {
        return mlx_conv_transpose1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_conv_transpose1d(mlx_array *res, const mlx_array input, const mlx_array weight, int stride, int padding, int dilation, int output_padding, int groups, const mlx_stream s)
     * }
     */
    public static int mlx_conv_transpose1d(MemorySegment res, MemorySegment input, MemorySegment weight, int stride, int padding, int dilation, int output_padding, int groups, MemorySegment s) {
        var mh$ = mlx_conv_transpose1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_conv_transpose1d", res, input, weight, stride, padding, dilation, output_padding, groups, s);
            }
            return (int)mh$.invokeExact(res, input, weight, stride, padding, dilation, output_padding, groups, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_conv_transpose2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_conv_transpose2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_conv_transpose2d(mlx_array *res, const mlx_array input, const mlx_array weight, int stride_0, int stride_1, int padding_0, int padding_1, int dilation_0, int dilation_1, int output_padding_0, int output_padding_1, int groups, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_conv_transpose2d$descriptor() {
        return mlx_conv_transpose2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_conv_transpose2d(mlx_array *res, const mlx_array input, const mlx_array weight, int stride_0, int stride_1, int padding_0, int padding_1, int dilation_0, int dilation_1, int output_padding_0, int output_padding_1, int groups, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_conv_transpose2d$handle() {
        return mlx_conv_transpose2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_conv_transpose2d(mlx_array *res, const mlx_array input, const mlx_array weight, int stride_0, int stride_1, int padding_0, int padding_1, int dilation_0, int dilation_1, int output_padding_0, int output_padding_1, int groups, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_conv_transpose2d$address() {
        return mlx_conv_transpose2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_conv_transpose2d(mlx_array *res, const mlx_array input, const mlx_array weight, int stride_0, int stride_1, int padding_0, int padding_1, int dilation_0, int dilation_1, int output_padding_0, int output_padding_1, int groups, const mlx_stream s)
     * }
     */
    public static int mlx_conv_transpose2d(MemorySegment res, MemorySegment input, MemorySegment weight, int stride_0, int stride_1, int padding_0, int padding_1, int dilation_0, int dilation_1, int output_padding_0, int output_padding_1, int groups, MemorySegment s) {
        var mh$ = mlx_conv_transpose2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_conv_transpose2d", res, input, weight, stride_0, stride_1, padding_0, padding_1, dilation_0, dilation_1, output_padding_0, output_padding_1, groups, s);
            }
            return (int)mh$.invokeExact(res, input, weight, stride_0, stride_1, padding_0, padding_1, dilation_0, dilation_1, output_padding_0, output_padding_1, groups, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_conv_transpose3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_conv_transpose3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_conv_transpose3d(mlx_array *res, const mlx_array input, const mlx_array weight, int stride_0, int stride_1, int stride_2, int padding_0, int padding_1, int padding_2, int dilation_0, int dilation_1, int dilation_2, int output_padding_0, int output_padding_1, int output_padding_2, int groups, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_conv_transpose3d$descriptor() {
        return mlx_conv_transpose3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_conv_transpose3d(mlx_array *res, const mlx_array input, const mlx_array weight, int stride_0, int stride_1, int stride_2, int padding_0, int padding_1, int padding_2, int dilation_0, int dilation_1, int dilation_2, int output_padding_0, int output_padding_1, int output_padding_2, int groups, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_conv_transpose3d$handle() {
        return mlx_conv_transpose3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_conv_transpose3d(mlx_array *res, const mlx_array input, const mlx_array weight, int stride_0, int stride_1, int stride_2, int padding_0, int padding_1, int padding_2, int dilation_0, int dilation_1, int dilation_2, int output_padding_0, int output_padding_1, int output_padding_2, int groups, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_conv_transpose3d$address() {
        return mlx_conv_transpose3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_conv_transpose3d(mlx_array *res, const mlx_array input, const mlx_array weight, int stride_0, int stride_1, int stride_2, int padding_0, int padding_1, int padding_2, int dilation_0, int dilation_1, int dilation_2, int output_padding_0, int output_padding_1, int output_padding_2, int groups, const mlx_stream s)
     * }
     */
    public static int mlx_conv_transpose3d(MemorySegment res, MemorySegment input, MemorySegment weight, int stride_0, int stride_1, int stride_2, int padding_0, int padding_1, int padding_2, int dilation_0, int dilation_1, int dilation_2, int output_padding_0, int output_padding_1, int output_padding_2, int groups, MemorySegment s) {
        var mh$ = mlx_conv_transpose3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_conv_transpose3d", res, input, weight, stride_0, stride_1, stride_2, padding_0, padding_1, padding_2, dilation_0, dilation_1, dilation_2, output_padding_0, output_padding_1, output_padding_2, groups, s);
            }
            return (int)mh$.invokeExact(res, input, weight, stride_0, stride_1, stride_2, padding_0, padding_1, padding_2, dilation_0, dilation_1, dilation_2, output_padding_0, output_padding_1, output_padding_2, groups, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_copy(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_copy$descriptor() {
        return mlx_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_copy(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_copy$handle() {
        return mlx_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_copy(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_copy$address() {
        return mlx_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_copy(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_copy(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_copy", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_cos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_cos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_cos(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_cos$descriptor() {
        return mlx_cos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_cos(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_cos$handle() {
        return mlx_cos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_cos(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_cos$address() {
        return mlx_cos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_cos(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_cos(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_cos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_cos", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_cosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_cosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_cosh(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_cosh$descriptor() {
        return mlx_cosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_cosh(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_cosh$handle() {
        return mlx_cosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_cosh(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_cosh$address() {
        return mlx_cosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_cosh(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_cosh(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_cosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_cosh", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_cummax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_BOOL,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_cummax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_cummax(mlx_array *res, const mlx_array a, int axis, bool reverse, bool inclusive, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_cummax$descriptor() {
        return mlx_cummax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_cummax(mlx_array *res, const mlx_array a, int axis, bool reverse, bool inclusive, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_cummax$handle() {
        return mlx_cummax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_cummax(mlx_array *res, const mlx_array a, int axis, bool reverse, bool inclusive, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_cummax$address() {
        return mlx_cummax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_cummax(mlx_array *res, const mlx_array a, int axis, bool reverse, bool inclusive, const mlx_stream s)
     * }
     */
    public static int mlx_cummax(MemorySegment res, MemorySegment a, int axis, boolean reverse, boolean inclusive, MemorySegment s) {
        var mh$ = mlx_cummax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_cummax", res, a, axis, reverse, inclusive, s);
            }
            return (int)mh$.invokeExact(res, a, axis, reverse, inclusive, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_cummin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_BOOL,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_cummin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_cummin(mlx_array *res, const mlx_array a, int axis, bool reverse, bool inclusive, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_cummin$descriptor() {
        return mlx_cummin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_cummin(mlx_array *res, const mlx_array a, int axis, bool reverse, bool inclusive, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_cummin$handle() {
        return mlx_cummin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_cummin(mlx_array *res, const mlx_array a, int axis, bool reverse, bool inclusive, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_cummin$address() {
        return mlx_cummin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_cummin(mlx_array *res, const mlx_array a, int axis, bool reverse, bool inclusive, const mlx_stream s)
     * }
     */
    public static int mlx_cummin(MemorySegment res, MemorySegment a, int axis, boolean reverse, boolean inclusive, MemorySegment s) {
        var mh$ = mlx_cummin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_cummin", res, a, axis, reverse, inclusive, s);
            }
            return (int)mh$.invokeExact(res, a, axis, reverse, inclusive, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_cumprod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_BOOL,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_cumprod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_cumprod(mlx_array *res, const mlx_array a, int axis, bool reverse, bool inclusive, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_cumprod$descriptor() {
        return mlx_cumprod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_cumprod(mlx_array *res, const mlx_array a, int axis, bool reverse, bool inclusive, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_cumprod$handle() {
        return mlx_cumprod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_cumprod(mlx_array *res, const mlx_array a, int axis, bool reverse, bool inclusive, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_cumprod$address() {
        return mlx_cumprod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_cumprod(mlx_array *res, const mlx_array a, int axis, bool reverse, bool inclusive, const mlx_stream s)
     * }
     */
    public static int mlx_cumprod(MemorySegment res, MemorySegment a, int axis, boolean reverse, boolean inclusive, MemorySegment s) {
        var mh$ = mlx_cumprod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_cumprod", res, a, axis, reverse, inclusive, s);
            }
            return (int)mh$.invokeExact(res, a, axis, reverse, inclusive, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_cumsum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_BOOL,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_cumsum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_cumsum(mlx_array *res, const mlx_array a, int axis, bool reverse, bool inclusive, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_cumsum$descriptor() {
        return mlx_cumsum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_cumsum(mlx_array *res, const mlx_array a, int axis, bool reverse, bool inclusive, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_cumsum$handle() {
        return mlx_cumsum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_cumsum(mlx_array *res, const mlx_array a, int axis, bool reverse, bool inclusive, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_cumsum$address() {
        return mlx_cumsum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_cumsum(mlx_array *res, const mlx_array a, int axis, bool reverse, bool inclusive, const mlx_stream s)
     * }
     */
    public static int mlx_cumsum(MemorySegment res, MemorySegment a, int axis, boolean reverse, boolean inclusive, MemorySegment s) {
        var mh$ = mlx_cumsum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_cumsum", res, a, axis, reverse, inclusive, s);
            }
            return (int)mh$.invokeExact(res, a, axis, reverse, inclusive, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_degrees {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_degrees");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_degrees(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_degrees$descriptor() {
        return mlx_degrees.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_degrees(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_degrees$handle() {
        return mlx_degrees.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_degrees(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_degrees$address() {
        return mlx_degrees.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_degrees(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_degrees(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_degrees.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_degrees", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_depends {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_vector_array_.layout(),
            mlx_vector_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_depends");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_depends(mlx_vector_array *res, const mlx_vector_array inputs, const mlx_vector_array dependencies)
     * }
     */
    public static FunctionDescriptor mlx_depends$descriptor() {
        return mlx_depends.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_depends(mlx_vector_array *res, const mlx_vector_array inputs, const mlx_vector_array dependencies)
     * }
     */
    public static MethodHandle mlx_depends$handle() {
        return mlx_depends.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_depends(mlx_vector_array *res, const mlx_vector_array inputs, const mlx_vector_array dependencies)
     * }
     */
    public static MemorySegment mlx_depends$address() {
        return mlx_depends.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_depends(mlx_vector_array *res, const mlx_vector_array inputs, const mlx_vector_array dependencies)
     * }
     */
    public static int mlx_depends(MemorySegment res, MemorySegment inputs, MemorySegment dependencies) {
        var mh$ = mlx_depends.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_depends", res, inputs, dependencies);
            }
            return (int)mh$.invokeExact(res, inputs, dependencies);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_dequantize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_dequantize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_dequantize(mlx_array *res, const mlx_array w, const mlx_array scales, const mlx_array biases, int group_size, int bits, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_dequantize$descriptor() {
        return mlx_dequantize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_dequantize(mlx_array *res, const mlx_array w, const mlx_array scales, const mlx_array biases, int group_size, int bits, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_dequantize$handle() {
        return mlx_dequantize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_dequantize(mlx_array *res, const mlx_array w, const mlx_array scales, const mlx_array biases, int group_size, int bits, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_dequantize$address() {
        return mlx_dequantize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_dequantize(mlx_array *res, const mlx_array w, const mlx_array scales, const mlx_array biases, int group_size, int bits, const mlx_stream s)
     * }
     */
    public static int mlx_dequantize(MemorySegment res, MemorySegment w, MemorySegment scales, MemorySegment biases, int group_size, int bits, MemorySegment s) {
        var mh$ = mlx_dequantize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_dequantize", res, w, scales, biases, group_size, bits, s);
            }
            return (int)mh$.invokeExact(res, w, scales, biases, group_size, bits, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_diag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_diag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_diag(mlx_array *res, const mlx_array a, int k, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_diag$descriptor() {
        return mlx_diag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_diag(mlx_array *res, const mlx_array a, int k, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_diag$handle() {
        return mlx_diag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_diag(mlx_array *res, const mlx_array a, int k, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_diag$address() {
        return mlx_diag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_diag(mlx_array *res, const mlx_array a, int k, const mlx_stream s)
     * }
     */
    public static int mlx_diag(MemorySegment res, MemorySegment a, int k, MemorySegment s) {
        var mh$ = mlx_diag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_diag", res, a, k, s);
            }
            return (int)mh$.invokeExact(res, a, k, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_diagonal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_diagonal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_diagonal(mlx_array *res, const mlx_array a, int offset, int axis1, int axis2, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_diagonal$descriptor() {
        return mlx_diagonal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_diagonal(mlx_array *res, const mlx_array a, int offset, int axis1, int axis2, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_diagonal$handle() {
        return mlx_diagonal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_diagonal(mlx_array *res, const mlx_array a, int offset, int axis1, int axis2, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_diagonal$address() {
        return mlx_diagonal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_diagonal(mlx_array *res, const mlx_array a, int offset, int axis1, int axis2, const mlx_stream s)
     * }
     */
    public static int mlx_diagonal(MemorySegment res, MemorySegment a, int offset, int axis1, int axis2, MemorySegment s) {
        var mh$ = mlx_diagonal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_diagonal", res, a, offset, axis1, axis2, s);
            }
            return (int)mh$.invokeExact(res, a, offset, axis1, axis2, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_divide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_divide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_divide(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_divide$descriptor() {
        return mlx_divide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_divide(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_divide$handle() {
        return mlx_divide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_divide(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_divide$address() {
        return mlx_divide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_divide(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_divide(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_divide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_divide", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_divmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_divmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_divmod(mlx_vector_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_divmod$descriptor() {
        return mlx_divmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_divmod(mlx_vector_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_divmod$handle() {
        return mlx_divmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_divmod(mlx_vector_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_divmod$address() {
        return mlx_divmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_divmod(mlx_vector_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_divmod(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_divmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_divmod", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_einsum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_vector_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_einsum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_einsum(mlx_array *res, const char *subscripts, const mlx_vector_array operands, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_einsum$descriptor() {
        return mlx_einsum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_einsum(mlx_array *res, const char *subscripts, const mlx_vector_array operands, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_einsum$handle() {
        return mlx_einsum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_einsum(mlx_array *res, const char *subscripts, const mlx_vector_array operands, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_einsum$address() {
        return mlx_einsum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_einsum(mlx_array *res, const char *subscripts, const mlx_vector_array operands, const mlx_stream s)
     * }
     */
    public static int mlx_einsum(MemorySegment res, MemorySegment subscripts, MemorySegment operands, MemorySegment s) {
        var mh$ = mlx_einsum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_einsum", res, subscripts, operands, s);
            }
            return (int)mh$.invokeExact(res, subscripts, operands, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_equal(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_equal$descriptor() {
        return mlx_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_equal(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_equal$handle() {
        return mlx_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_equal(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_equal$address() {
        return mlx_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_equal(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_equal(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_equal", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_erf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_erf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_erf(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_erf$descriptor() {
        return mlx_erf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_erf(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_erf$handle() {
        return mlx_erf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_erf(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_erf$address() {
        return mlx_erf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_erf(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_erf(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_erf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_erf", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_erfinv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_erfinv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_erfinv(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_erfinv$descriptor() {
        return mlx_erfinv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_erfinv(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_erfinv$handle() {
        return mlx_erfinv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_erfinv(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_erfinv$address() {
        return mlx_erfinv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_erfinv(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_erfinv(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_erfinv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_erfinv", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_exp(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_exp$descriptor() {
        return mlx_exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_exp(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_exp$handle() {
        return mlx_exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_exp(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_exp$address() {
        return mlx_exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_exp(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_exp(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_exp", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_expand_dims_axes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_expand_dims_axes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_expand_dims_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_expand_dims_axes$descriptor() {
        return mlx_expand_dims_axes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_expand_dims_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_expand_dims_axes$handle() {
        return mlx_expand_dims_axes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_expand_dims_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_expand_dims_axes$address() {
        return mlx_expand_dims_axes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_expand_dims_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static int mlx_expand_dims_axes(MemorySegment res, MemorySegment a, MemorySegment axes, long axes_num, MemorySegment s) {
        var mh$ = mlx_expand_dims_axes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_expand_dims_axes", res, a, axes, axes_num, s);
            }
            return (int)mh$.invokeExact(res, a, axes, axes_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_expand_dims {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_expand_dims");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_expand_dims(mlx_array *res, const mlx_array a, int axis, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_expand_dims$descriptor() {
        return mlx_expand_dims.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_expand_dims(mlx_array *res, const mlx_array a, int axis, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_expand_dims$handle() {
        return mlx_expand_dims.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_expand_dims(mlx_array *res, const mlx_array a, int axis, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_expand_dims$address() {
        return mlx_expand_dims.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_expand_dims(mlx_array *res, const mlx_array a, int axis, const mlx_stream s)
     * }
     */
    public static int mlx_expand_dims(MemorySegment res, MemorySegment a, int axis, MemorySegment s) {
        var mh$ = mlx_expand_dims.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_expand_dims", res, a, axis, s);
            }
            return (int)mh$.invokeExact(res, a, axis, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_expm1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_expm1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_expm1(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_expm1$descriptor() {
        return mlx_expm1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_expm1(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_expm1$handle() {
        return mlx_expm1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_expm1(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_expm1$address() {
        return mlx_expm1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_expm1(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_expm1(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_expm1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_expm1", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_eye {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_eye");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_eye(mlx_array *res, int n, int m, int k, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_eye$descriptor() {
        return mlx_eye.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_eye(mlx_array *res, int n, int m, int k, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_eye$handle() {
        return mlx_eye.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_eye(mlx_array *res, int n, int m, int k, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_eye$address() {
        return mlx_eye.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_eye(mlx_array *res, int n, int m, int k, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static int mlx_eye(MemorySegment res, int n, int m, int k, int dtype, MemorySegment s) {
        var mh$ = mlx_eye.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_eye", res, n, m, k, dtype, s);
            }
            return (int)mh$.invokeExact(res, n, m, k, dtype, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_flatten {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_flatten");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_flatten(mlx_array *res, const mlx_array a, int start_axis, int end_axis, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_flatten$descriptor() {
        return mlx_flatten.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_flatten(mlx_array *res, const mlx_array a, int start_axis, int end_axis, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_flatten$handle() {
        return mlx_flatten.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_flatten(mlx_array *res, const mlx_array a, int start_axis, int end_axis, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_flatten$address() {
        return mlx_flatten.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_flatten(mlx_array *res, const mlx_array a, int start_axis, int end_axis, const mlx_stream s)
     * }
     */
    public static int mlx_flatten(MemorySegment res, MemorySegment a, int start_axis, int end_axis, MemorySegment s) {
        var mh$ = mlx_flatten.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_flatten", res, a, start_axis, end_axis, s);
            }
            return (int)mh$.invokeExact(res, a, start_axis, end_axis, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_floor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_floor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_floor(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_floor$descriptor() {
        return mlx_floor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_floor(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_floor$handle() {
        return mlx_floor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_floor(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_floor$address() {
        return mlx_floor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_floor(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_floor(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_floor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_floor", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_floor_divide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_floor_divide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_floor_divide(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_floor_divide$descriptor() {
        return mlx_floor_divide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_floor_divide(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_floor_divide$handle() {
        return mlx_floor_divide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_floor_divide(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_floor_divide$address() {
        return mlx_floor_divide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_floor_divide(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_floor_divide(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_floor_divide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_floor_divide", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_full(mlx_array *res, const int *shape, size_t shape_num, const mlx_array vals, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_full$descriptor() {
        return mlx_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_full(mlx_array *res, const int *shape, size_t shape_num, const mlx_array vals, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_full$handle() {
        return mlx_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_full(mlx_array *res, const int *shape, size_t shape_num, const mlx_array vals, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_full$address() {
        return mlx_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_full(mlx_array *res, const int *shape, size_t shape_num, const mlx_array vals, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static int mlx_full(MemorySegment res, MemorySegment shape, long shape_num, MemorySegment vals, int dtype, MemorySegment s) {
        var mh$ = mlx_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_full", res, shape, shape_num, vals, dtype, s);
            }
            return (int)mh$.invokeExact(res, shape, shape_num, vals, dtype, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_gather {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_vector_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_gather");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_gather(mlx_array *res, const mlx_array a, const mlx_vector_array indices, const int *axes, size_t axes_num, const int *slice_sizes, size_t slice_sizes_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_gather$descriptor() {
        return mlx_gather.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_gather(mlx_array *res, const mlx_array a, const mlx_vector_array indices, const int *axes, size_t axes_num, const int *slice_sizes, size_t slice_sizes_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_gather$handle() {
        return mlx_gather.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_gather(mlx_array *res, const mlx_array a, const mlx_vector_array indices, const int *axes, size_t axes_num, const int *slice_sizes, size_t slice_sizes_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_gather$address() {
        return mlx_gather.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_gather(mlx_array *res, const mlx_array a, const mlx_vector_array indices, const int *axes, size_t axes_num, const int *slice_sizes, size_t slice_sizes_num, const mlx_stream s)
     * }
     */
    public static int mlx_gather(MemorySegment res, MemorySegment a, MemorySegment indices, MemorySegment axes, long axes_num, MemorySegment slice_sizes, long slice_sizes_num, MemorySegment s) {
        var mh$ = mlx_gather.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_gather", res, a, indices, axes, axes_num, slice_sizes, slice_sizes_num, s);
            }
            return (int)mh$.invokeExact(res, a, indices, axes, axes_num, slice_sizes, slice_sizes_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_gather_mm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_gather_mm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_gather_mm(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_array lhs_indices, const mlx_array rhs_indices, bool sorted_indices, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_gather_mm$descriptor() {
        return mlx_gather_mm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_gather_mm(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_array lhs_indices, const mlx_array rhs_indices, bool sorted_indices, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_gather_mm$handle() {
        return mlx_gather_mm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_gather_mm(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_array lhs_indices, const mlx_array rhs_indices, bool sorted_indices, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_gather_mm$address() {
        return mlx_gather_mm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_gather_mm(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_array lhs_indices, const mlx_array rhs_indices, bool sorted_indices, const mlx_stream s)
     * }
     */
    public static int mlx_gather_mm(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment lhs_indices, MemorySegment rhs_indices, boolean sorted_indices, MemorySegment s) {
        var mh$ = mlx_gather_mm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_gather_mm", res, a, b, lhs_indices, rhs_indices, sorted_indices, s);
            }
            return (int)mh$.invokeExact(res, a, b, lhs_indices, rhs_indices, sorted_indices, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_gather_qmm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_BOOL,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_gather_qmm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_gather_qmm(mlx_array *res, const mlx_array x, const mlx_array w, const mlx_array scales, const mlx_array biases, const mlx_array lhs_indices, const mlx_array rhs_indices, bool transpose, int group_size, int bits, bool sorted_indices, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_gather_qmm$descriptor() {
        return mlx_gather_qmm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_gather_qmm(mlx_array *res, const mlx_array x, const mlx_array w, const mlx_array scales, const mlx_array biases, const mlx_array lhs_indices, const mlx_array rhs_indices, bool transpose, int group_size, int bits, bool sorted_indices, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_gather_qmm$handle() {
        return mlx_gather_qmm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_gather_qmm(mlx_array *res, const mlx_array x, const mlx_array w, const mlx_array scales, const mlx_array biases, const mlx_array lhs_indices, const mlx_array rhs_indices, bool transpose, int group_size, int bits, bool sorted_indices, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_gather_qmm$address() {
        return mlx_gather_qmm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_gather_qmm(mlx_array *res, const mlx_array x, const mlx_array w, const mlx_array scales, const mlx_array biases, const mlx_array lhs_indices, const mlx_array rhs_indices, bool transpose, int group_size, int bits, bool sorted_indices, const mlx_stream s)
     * }
     */
    public static int mlx_gather_qmm(MemorySegment res, MemorySegment x, MemorySegment w, MemorySegment scales, MemorySegment biases, MemorySegment lhs_indices, MemorySegment rhs_indices, boolean transpose, int group_size, int bits, boolean sorted_indices, MemorySegment s) {
        var mh$ = mlx_gather_qmm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_gather_qmm", res, x, w, scales, biases, lhs_indices, rhs_indices, transpose, group_size, bits, sorted_indices, s);
            }
            return (int)mh$.invokeExact(res, x, w, scales, biases, lhs_indices, rhs_indices, transpose, group_size, bits, sorted_indices, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_greater {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_greater");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_greater(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_greater$descriptor() {
        return mlx_greater.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_greater(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_greater$handle() {
        return mlx_greater.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_greater(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_greater$address() {
        return mlx_greater.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_greater(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_greater(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_greater.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_greater", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_greater_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_greater_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_greater_equal(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_greater_equal$descriptor() {
        return mlx_greater_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_greater_equal(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_greater_equal$handle() {
        return mlx_greater_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_greater_equal(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_greater_equal$address() {
        return mlx_greater_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_greater_equal(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_greater_equal(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_greater_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_greater_equal", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_hadamard_transform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_optional_float_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_hadamard_transform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_hadamard_transform(mlx_array *res, const mlx_array a, mlx_optional_float scale, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_hadamard_transform$descriptor() {
        return mlx_hadamard_transform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_hadamard_transform(mlx_array *res, const mlx_array a, mlx_optional_float scale, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_hadamard_transform$handle() {
        return mlx_hadamard_transform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_hadamard_transform(mlx_array *res, const mlx_array a, mlx_optional_float scale, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_hadamard_transform$address() {
        return mlx_hadamard_transform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_hadamard_transform(mlx_array *res, const mlx_array a, mlx_optional_float scale, const mlx_stream s)
     * }
     */
    public static int mlx_hadamard_transform(MemorySegment res, MemorySegment a, MemorySegment scale, MemorySegment s) {
        var mh$ = mlx_hadamard_transform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_hadamard_transform", res, a, scale, s);
            }
            return (int)mh$.invokeExact(res, a, scale, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_identity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_identity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_identity(mlx_array *res, int n, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_identity$descriptor() {
        return mlx_identity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_identity(mlx_array *res, int n, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_identity$handle() {
        return mlx_identity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_identity(mlx_array *res, int n, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_identity$address() {
        return mlx_identity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_identity(mlx_array *res, int n, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static int mlx_identity(MemorySegment res, int n, int dtype, MemorySegment s) {
        var mh$ = mlx_identity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_identity", res, n, dtype, s);
            }
            return (int)mh$.invokeExact(res, n, dtype, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_imag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_imag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_imag(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_imag$descriptor() {
        return mlx_imag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_imag(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_imag$handle() {
        return mlx_imag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_imag(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_imag$address() {
        return mlx_imag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_imag(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_imag(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_imag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_imag", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_inner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_inner");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_inner(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_inner$descriptor() {
        return mlx_inner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_inner(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_inner$handle() {
        return mlx_inner.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_inner(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_inner$address() {
        return mlx_inner.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_inner(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_inner(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_inner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_inner", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_isclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_DOUBLE,
            mlx_h.C_DOUBLE,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_isclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_isclose(mlx_array *res, const mlx_array a, const mlx_array b, double rtol, double atol, bool equal_nan, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_isclose$descriptor() {
        return mlx_isclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_isclose(mlx_array *res, const mlx_array a, const mlx_array b, double rtol, double atol, bool equal_nan, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_isclose$handle() {
        return mlx_isclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_isclose(mlx_array *res, const mlx_array a, const mlx_array b, double rtol, double atol, bool equal_nan, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_isclose$address() {
        return mlx_isclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_isclose(mlx_array *res, const mlx_array a, const mlx_array b, double rtol, double atol, bool equal_nan, const mlx_stream s)
     * }
     */
    public static int mlx_isclose(MemorySegment res, MemorySegment a, MemorySegment b, double rtol, double atol, boolean equal_nan, MemorySegment s) {
        var mh$ = mlx_isclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_isclose", res, a, b, rtol, atol, equal_nan, s);
            }
            return (int)mh$.invokeExact(res, a, b, rtol, atol, equal_nan, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_isfinite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_isfinite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_isfinite(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_isfinite$descriptor() {
        return mlx_isfinite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_isfinite(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_isfinite$handle() {
        return mlx_isfinite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_isfinite(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_isfinite$address() {
        return mlx_isfinite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_isfinite(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_isfinite(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_isfinite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_isfinite", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_isinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_isinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_isinf(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_isinf$descriptor() {
        return mlx_isinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_isinf(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_isinf$handle() {
        return mlx_isinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_isinf(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_isinf$address() {
        return mlx_isinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_isinf(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_isinf(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_isinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_isinf", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_isnan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_isnan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_isnan(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_isnan$descriptor() {
        return mlx_isnan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_isnan(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_isnan$handle() {
        return mlx_isnan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_isnan(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_isnan$address() {
        return mlx_isnan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_isnan(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_isnan(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_isnan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_isnan", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_isneginf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_isneginf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_isneginf(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_isneginf$descriptor() {
        return mlx_isneginf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_isneginf(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_isneginf$handle() {
        return mlx_isneginf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_isneginf(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_isneginf$address() {
        return mlx_isneginf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_isneginf(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_isneginf(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_isneginf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_isneginf", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_isposinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_isposinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_isposinf(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_isposinf$descriptor() {
        return mlx_isposinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_isposinf(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_isposinf$handle() {
        return mlx_isposinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_isposinf(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_isposinf$address() {
        return mlx_isposinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_isposinf(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_isposinf(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_isposinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_isposinf", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_kron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_kron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_kron(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_kron$descriptor() {
        return mlx_kron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_kron(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_kron$handle() {
        return mlx_kron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_kron(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_kron$address() {
        return mlx_kron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_kron(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_kron(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_kron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_kron", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_left_shift {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_left_shift");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_left_shift(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_left_shift$descriptor() {
        return mlx_left_shift.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_left_shift(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_left_shift$handle() {
        return mlx_left_shift.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_left_shift(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_left_shift$address() {
        return mlx_left_shift.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_left_shift(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_left_shift(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_left_shift.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_left_shift", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_less {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_less");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_less(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_less$descriptor() {
        return mlx_less.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_less(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_less$handle() {
        return mlx_less.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_less(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_less$address() {
        return mlx_less.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_less(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_less(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_less.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_less", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_less_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_less_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_less_equal(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_less_equal$descriptor() {
        return mlx_less_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_less_equal(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_less_equal$handle() {
        return mlx_less_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_less_equal(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_less_equal$address() {
        return mlx_less_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_less_equal(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_less_equal(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_less_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_less_equal", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_linspace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_DOUBLE,
            mlx_h.C_DOUBLE,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_linspace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_linspace(mlx_array *res, double start, double stop, int num, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_linspace$descriptor() {
        return mlx_linspace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_linspace(mlx_array *res, double start, double stop, int num, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_linspace$handle() {
        return mlx_linspace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_linspace(mlx_array *res, double start, double stop, int num, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_linspace$address() {
        return mlx_linspace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_linspace(mlx_array *res, double start, double stop, int num, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static int mlx_linspace(MemorySegment res, double start, double stop, int num, int dtype, MemorySegment s) {
        var mh$ = mlx_linspace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_linspace", res, start, stop, num, dtype, s);
            }
            return (int)mh$.invokeExact(res, start, stop, num, dtype, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_log(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_log$descriptor() {
        return mlx_log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_log(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_log$handle() {
        return mlx_log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_log(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_log$address() {
        return mlx_log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_log(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_log(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_log", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_log10 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_log10");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_log10(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_log10$descriptor() {
        return mlx_log10.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_log10(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_log10$handle() {
        return mlx_log10.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_log10(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_log10$address() {
        return mlx_log10.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_log10(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_log10(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_log10.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_log10", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_log1p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_log1p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_log1p(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_log1p$descriptor() {
        return mlx_log1p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_log1p(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_log1p$handle() {
        return mlx_log1p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_log1p(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_log1p$address() {
        return mlx_log1p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_log1p(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_log1p(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_log1p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_log1p", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_log2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_log2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_log2(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_log2$descriptor() {
        return mlx_log2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_log2(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_log2$handle() {
        return mlx_log2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_log2(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_log2$address() {
        return mlx_log2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_log2(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_log2(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_log2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_log2", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_logaddexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_logaddexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_logaddexp(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_logaddexp$descriptor() {
        return mlx_logaddexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_logaddexp(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_logaddexp$handle() {
        return mlx_logaddexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_logaddexp(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_logaddexp$address() {
        return mlx_logaddexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_logaddexp(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_logaddexp(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_logaddexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_logaddexp", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_logcumsumexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_BOOL,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_logcumsumexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_logcumsumexp(mlx_array *res, const mlx_array a, int axis, bool reverse, bool inclusive, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_logcumsumexp$descriptor() {
        return mlx_logcumsumexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_logcumsumexp(mlx_array *res, const mlx_array a, int axis, bool reverse, bool inclusive, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_logcumsumexp$handle() {
        return mlx_logcumsumexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_logcumsumexp(mlx_array *res, const mlx_array a, int axis, bool reverse, bool inclusive, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_logcumsumexp$address() {
        return mlx_logcumsumexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_logcumsumexp(mlx_array *res, const mlx_array a, int axis, bool reverse, bool inclusive, const mlx_stream s)
     * }
     */
    public static int mlx_logcumsumexp(MemorySegment res, MemorySegment a, int axis, boolean reverse, boolean inclusive, MemorySegment s) {
        var mh$ = mlx_logcumsumexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_logcumsumexp", res, a, axis, reverse, inclusive, s);
            }
            return (int)mh$.invokeExact(res, a, axis, reverse, inclusive, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_logical_and {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_logical_and");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_logical_and(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_logical_and$descriptor() {
        return mlx_logical_and.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_logical_and(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_logical_and$handle() {
        return mlx_logical_and.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_logical_and(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_logical_and$address() {
        return mlx_logical_and.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_logical_and(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_logical_and(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_logical_and.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_logical_and", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_logical_not {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_logical_not");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_logical_not(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_logical_not$descriptor() {
        return mlx_logical_not.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_logical_not(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_logical_not$handle() {
        return mlx_logical_not.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_logical_not(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_logical_not$address() {
        return mlx_logical_not.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_logical_not(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_logical_not(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_logical_not.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_logical_not", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_logical_or {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_logical_or");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_logical_or(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_logical_or$descriptor() {
        return mlx_logical_or.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_logical_or(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_logical_or$handle() {
        return mlx_logical_or.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_logical_or(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_logical_or$address() {
        return mlx_logical_or.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_logical_or(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_logical_or(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_logical_or.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_logical_or", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_logsumexp_axes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_logsumexp_axes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_logsumexp_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_logsumexp_axes$descriptor() {
        return mlx_logsumexp_axes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_logsumexp_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_logsumexp_axes$handle() {
        return mlx_logsumexp_axes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_logsumexp_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_logsumexp_axes$address() {
        return mlx_logsumexp_axes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_logsumexp_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_logsumexp_axes(MemorySegment res, MemorySegment a, MemorySegment axes, long axes_num, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_logsumexp_axes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_logsumexp_axes", res, a, axes, axes_num, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, axes, axes_num, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_logsumexp_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_logsumexp_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_logsumexp_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_logsumexp_axis$descriptor() {
        return mlx_logsumexp_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_logsumexp_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_logsumexp_axis$handle() {
        return mlx_logsumexp_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_logsumexp_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_logsumexp_axis$address() {
        return mlx_logsumexp_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_logsumexp_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_logsumexp_axis(MemorySegment res, MemorySegment a, int axis, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_logsumexp_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_logsumexp_axis", res, a, axis, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, axis, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_logsumexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_logsumexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_logsumexp(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_logsumexp$descriptor() {
        return mlx_logsumexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_logsumexp(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_logsumexp$handle() {
        return mlx_logsumexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_logsumexp(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_logsumexp$address() {
        return mlx_logsumexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_logsumexp(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_logsumexp(MemorySegment res, MemorySegment a, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_logsumexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_logsumexp", res, a, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_matmul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_matmul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_matmul(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_matmul$descriptor() {
        return mlx_matmul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_matmul(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_matmul$handle() {
        return mlx_matmul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_matmul(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_matmul$address() {
        return mlx_matmul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_matmul(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_matmul(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_matmul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_matmul", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_max_axes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_max_axes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_max_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_max_axes$descriptor() {
        return mlx_max_axes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_max_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_max_axes$handle() {
        return mlx_max_axes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_max_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_max_axes$address() {
        return mlx_max_axes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_max_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_max_axes(MemorySegment res, MemorySegment a, MemorySegment axes, long axes_num, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_max_axes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_max_axes", res, a, axes, axes_num, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, axes, axes_num, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_max_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_max_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_max_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_max_axis$descriptor() {
        return mlx_max_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_max_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_max_axis$handle() {
        return mlx_max_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_max_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_max_axis$address() {
        return mlx_max_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_max_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_max_axis(MemorySegment res, MemorySegment a, int axis, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_max_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_max_axis", res, a, axis, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, axis, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_max(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_max$descriptor() {
        return mlx_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_max(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_max$handle() {
        return mlx_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_max(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_max$address() {
        return mlx_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_max(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_max(MemorySegment res, MemorySegment a, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_max", res, a, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_maximum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_maximum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_maximum(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_maximum$descriptor() {
        return mlx_maximum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_maximum(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_maximum$handle() {
        return mlx_maximum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_maximum(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_maximum$address() {
        return mlx_maximum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_maximum(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_maximum(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_maximum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_maximum", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_mean_axes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_mean_axes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_mean_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_mean_axes$descriptor() {
        return mlx_mean_axes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_mean_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_mean_axes$handle() {
        return mlx_mean_axes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_mean_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_mean_axes$address() {
        return mlx_mean_axes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_mean_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_mean_axes(MemorySegment res, MemorySegment a, MemorySegment axes, long axes_num, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_mean_axes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_mean_axes", res, a, axes, axes_num, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, axes, axes_num, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_mean_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_mean_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_mean_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_mean_axis$descriptor() {
        return mlx_mean_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_mean_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_mean_axis$handle() {
        return mlx_mean_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_mean_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_mean_axis$address() {
        return mlx_mean_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_mean_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_mean_axis(MemorySegment res, MemorySegment a, int axis, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_mean_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_mean_axis", res, a, axis, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, axis, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_mean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_mean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_mean(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_mean$descriptor() {
        return mlx_mean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_mean(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_mean$handle() {
        return mlx_mean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_mean(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_mean$address() {
        return mlx_mean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_mean(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_mean(MemorySegment res, MemorySegment a, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_mean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_mean", res, a, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_meshgrid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_vector_array_.layout(),
            mlx_h.C_BOOL,
            mlx_h.C_POINTER,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_meshgrid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_meshgrid(mlx_vector_array *res, const mlx_vector_array arrays, bool sparse, const char *indexing, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_meshgrid$descriptor() {
        return mlx_meshgrid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_meshgrid(mlx_vector_array *res, const mlx_vector_array arrays, bool sparse, const char *indexing, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_meshgrid$handle() {
        return mlx_meshgrid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_meshgrid(mlx_vector_array *res, const mlx_vector_array arrays, bool sparse, const char *indexing, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_meshgrid$address() {
        return mlx_meshgrid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_meshgrid(mlx_vector_array *res, const mlx_vector_array arrays, bool sparse, const char *indexing, const mlx_stream s)
     * }
     */
    public static int mlx_meshgrid(MemorySegment res, MemorySegment arrays, boolean sparse, MemorySegment indexing, MemorySegment s) {
        var mh$ = mlx_meshgrid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_meshgrid", res, arrays, sparse, indexing, s);
            }
            return (int)mh$.invokeExact(res, arrays, sparse, indexing, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_min_axes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_min_axes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_min_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_min_axes$descriptor() {
        return mlx_min_axes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_min_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_min_axes$handle() {
        return mlx_min_axes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_min_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_min_axes$address() {
        return mlx_min_axes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_min_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_min_axes(MemorySegment res, MemorySegment a, MemorySegment axes, long axes_num, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_min_axes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_min_axes", res, a, axes, axes_num, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, axes, axes_num, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_min_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_min_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_min_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_min_axis$descriptor() {
        return mlx_min_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_min_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_min_axis$handle() {
        return mlx_min_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_min_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_min_axis$address() {
        return mlx_min_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_min_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_min_axis(MemorySegment res, MemorySegment a, int axis, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_min_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_min_axis", res, a, axis, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, axis, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_min {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_min");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_min(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_min$descriptor() {
        return mlx_min.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_min(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_min$handle() {
        return mlx_min.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_min(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_min$address() {
        return mlx_min.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_min(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_min(MemorySegment res, MemorySegment a, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_min.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_min", res, a, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_minimum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_minimum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_minimum(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_minimum$descriptor() {
        return mlx_minimum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_minimum(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_minimum$handle() {
        return mlx_minimum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_minimum(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_minimum$address() {
        return mlx_minimum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_minimum(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_minimum(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_minimum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_minimum", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_moveaxis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_moveaxis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_moveaxis(mlx_array *res, const mlx_array a, int source, int destination, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_moveaxis$descriptor() {
        return mlx_moveaxis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_moveaxis(mlx_array *res, const mlx_array a, int source, int destination, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_moveaxis$handle() {
        return mlx_moveaxis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_moveaxis(mlx_array *res, const mlx_array a, int source, int destination, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_moveaxis$address() {
        return mlx_moveaxis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_moveaxis(mlx_array *res, const mlx_array a, int source, int destination, const mlx_stream s)
     * }
     */
    public static int mlx_moveaxis(MemorySegment res, MemorySegment a, int source, int destination, MemorySegment s) {
        var mh$ = mlx_moveaxis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_moveaxis", res, a, source, destination, s);
            }
            return (int)mh$.invokeExact(res, a, source, destination, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_multiply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_multiply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_multiply(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_multiply$descriptor() {
        return mlx_multiply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_multiply(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_multiply$handle() {
        return mlx_multiply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_multiply(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_multiply$address() {
        return mlx_multiply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_multiply(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_multiply(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_multiply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_multiply", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_nan_to_num {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_FLOAT,
            mlx_optional_float_.layout(),
            mlx_optional_float_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_nan_to_num");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_nan_to_num(mlx_array *res, const mlx_array a, float nan, mlx_optional_float posinf, mlx_optional_float neginf, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_nan_to_num$descriptor() {
        return mlx_nan_to_num.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_nan_to_num(mlx_array *res, const mlx_array a, float nan, mlx_optional_float posinf, mlx_optional_float neginf, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_nan_to_num$handle() {
        return mlx_nan_to_num.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_nan_to_num(mlx_array *res, const mlx_array a, float nan, mlx_optional_float posinf, mlx_optional_float neginf, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_nan_to_num$address() {
        return mlx_nan_to_num.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_nan_to_num(mlx_array *res, const mlx_array a, float nan, mlx_optional_float posinf, mlx_optional_float neginf, const mlx_stream s)
     * }
     */
    public static int mlx_nan_to_num(MemorySegment res, MemorySegment a, float nan, MemorySegment posinf, MemorySegment neginf, MemorySegment s) {
        var mh$ = mlx_nan_to_num.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_nan_to_num", res, a, nan, posinf, neginf, s);
            }
            return (int)mh$.invokeExact(res, a, nan, posinf, neginf, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_negative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_negative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_negative(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_negative$descriptor() {
        return mlx_negative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_negative(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_negative$handle() {
        return mlx_negative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_negative(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_negative$address() {
        return mlx_negative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_negative(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_negative(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_negative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_negative", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_not_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_not_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_not_equal(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_not_equal$descriptor() {
        return mlx_not_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_not_equal(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_not_equal$handle() {
        return mlx_not_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_not_equal(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_not_equal$address() {
        return mlx_not_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_not_equal(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_not_equal(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_not_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_not_equal", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_number_of_elements {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_BOOL,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_number_of_elements");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_number_of_elements(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool inverted, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_number_of_elements$descriptor() {
        return mlx_number_of_elements.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_number_of_elements(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool inverted, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_number_of_elements$handle() {
        return mlx_number_of_elements.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_number_of_elements(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool inverted, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_number_of_elements$address() {
        return mlx_number_of_elements.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_number_of_elements(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool inverted, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static int mlx_number_of_elements(MemorySegment res, MemorySegment a, MemorySegment axes, long axes_num, boolean inverted, int dtype, MemorySegment s) {
        var mh$ = mlx_number_of_elements.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_number_of_elements", res, a, axes, axes_num, inverted, dtype, s);
            }
            return (int)mh$.invokeExact(res, a, axes, axes_num, inverted, dtype, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_ones {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_ones");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_ones(mlx_array *res, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_ones$descriptor() {
        return mlx_ones.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_ones(mlx_array *res, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_ones$handle() {
        return mlx_ones.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_ones(mlx_array *res, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_ones$address() {
        return mlx_ones.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_ones(mlx_array *res, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static int mlx_ones(MemorySegment res, MemorySegment shape, long shape_num, int dtype, MemorySegment s) {
        var mh$ = mlx_ones.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_ones", res, shape, shape_num, dtype, s);
            }
            return (int)mh$.invokeExact(res, shape, shape_num, dtype, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_ones_like {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_ones_like");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_ones_like(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_ones_like$descriptor() {
        return mlx_ones_like.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_ones_like(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_ones_like$handle() {
        return mlx_ones_like.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_ones_like(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_ones_like$address() {
        return mlx_ones_like.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_ones_like(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_ones_like(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_ones_like.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_ones_like", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_outer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_outer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_outer(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_outer$descriptor() {
        return mlx_outer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_outer(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_outer$handle() {
        return mlx_outer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_outer(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_outer$address() {
        return mlx_outer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_outer(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_outer(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_outer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_outer", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_pad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_pad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_pad(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, const int *low_pad_size, size_t low_pad_size_num, const int *high_pad_size, size_t high_pad_size_num, const mlx_array pad_value, const char *mode, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_pad$descriptor() {
        return mlx_pad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_pad(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, const int *low_pad_size, size_t low_pad_size_num, const int *high_pad_size, size_t high_pad_size_num, const mlx_array pad_value, const char *mode, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_pad$handle() {
        return mlx_pad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_pad(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, const int *low_pad_size, size_t low_pad_size_num, const int *high_pad_size, size_t high_pad_size_num, const mlx_array pad_value, const char *mode, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_pad$address() {
        return mlx_pad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_pad(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, const int *low_pad_size, size_t low_pad_size_num, const int *high_pad_size, size_t high_pad_size_num, const mlx_array pad_value, const char *mode, const mlx_stream s)
     * }
     */
    public static int mlx_pad(MemorySegment res, MemorySegment a, MemorySegment axes, long axes_num, MemorySegment low_pad_size, long low_pad_size_num, MemorySegment high_pad_size, long high_pad_size_num, MemorySegment pad_value, MemorySegment mode, MemorySegment s) {
        var mh$ = mlx_pad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_pad", res, a, axes, axes_num, low_pad_size, low_pad_size_num, high_pad_size, high_pad_size_num, pad_value, mode, s);
            }
            return (int)mh$.invokeExact(res, a, axes, axes_num, low_pad_size, low_pad_size_num, high_pad_size, high_pad_size_num, pad_value, mode, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_pad_symmetric {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_pad_symmetric");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_pad_symmetric(mlx_array *res, const mlx_array a, int pad_width, const mlx_array pad_value, const char *mode, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_pad_symmetric$descriptor() {
        return mlx_pad_symmetric.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_pad_symmetric(mlx_array *res, const mlx_array a, int pad_width, const mlx_array pad_value, const char *mode, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_pad_symmetric$handle() {
        return mlx_pad_symmetric.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_pad_symmetric(mlx_array *res, const mlx_array a, int pad_width, const mlx_array pad_value, const char *mode, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_pad_symmetric$address() {
        return mlx_pad_symmetric.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_pad_symmetric(mlx_array *res, const mlx_array a, int pad_width, const mlx_array pad_value, const char *mode, const mlx_stream s)
     * }
     */
    public static int mlx_pad_symmetric(MemorySegment res, MemorySegment a, int pad_width, MemorySegment pad_value, MemorySegment mode, MemorySegment s) {
        var mh$ = mlx_pad_symmetric.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_pad_symmetric", res, a, pad_width, pad_value, mode, s);
            }
            return (int)mh$.invokeExact(res, a, pad_width, pad_value, mode, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_partition_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_partition_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_partition_axis(mlx_array *res, const mlx_array a, int kth, int axis, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_partition_axis$descriptor() {
        return mlx_partition_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_partition_axis(mlx_array *res, const mlx_array a, int kth, int axis, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_partition_axis$handle() {
        return mlx_partition_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_partition_axis(mlx_array *res, const mlx_array a, int kth, int axis, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_partition_axis$address() {
        return mlx_partition_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_partition_axis(mlx_array *res, const mlx_array a, int kth, int axis, const mlx_stream s)
     * }
     */
    public static int mlx_partition_axis(MemorySegment res, MemorySegment a, int kth, int axis, MemorySegment s) {
        var mh$ = mlx_partition_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_partition_axis", res, a, kth, axis, s);
            }
            return (int)mh$.invokeExact(res, a, kth, axis, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_partition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_partition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_partition(mlx_array *res, const mlx_array a, int kth, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_partition$descriptor() {
        return mlx_partition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_partition(mlx_array *res, const mlx_array a, int kth, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_partition$handle() {
        return mlx_partition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_partition(mlx_array *res, const mlx_array a, int kth, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_partition$address() {
        return mlx_partition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_partition(mlx_array *res, const mlx_array a, int kth, const mlx_stream s)
     * }
     */
    public static int mlx_partition(MemorySegment res, MemorySegment a, int kth, MemorySegment s) {
        var mh$ = mlx_partition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_partition", res, a, kth, s);
            }
            return (int)mh$.invokeExact(res, a, kth, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_power {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_power");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_power(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_power$descriptor() {
        return mlx_power.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_power(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_power$handle() {
        return mlx_power.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_power(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_power$address() {
        return mlx_power.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_power(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_power(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_power.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_power", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_prod_axes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_prod_axes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_prod_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_prod_axes$descriptor() {
        return mlx_prod_axes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_prod_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_prod_axes$handle() {
        return mlx_prod_axes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_prod_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_prod_axes$address() {
        return mlx_prod_axes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_prod_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_prod_axes(MemorySegment res, MemorySegment a, MemorySegment axes, long axes_num, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_prod_axes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_prod_axes", res, a, axes, axes_num, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, axes, axes_num, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_prod_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_prod_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_prod_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_prod_axis$descriptor() {
        return mlx_prod_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_prod_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_prod_axis$handle() {
        return mlx_prod_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_prod_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_prod_axis$address() {
        return mlx_prod_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_prod_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_prod_axis(MemorySegment res, MemorySegment a, int axis, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_prod_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_prod_axis", res, a, axis, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, axis, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_prod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_prod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_prod(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_prod$descriptor() {
        return mlx_prod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_prod(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_prod$handle() {
        return mlx_prod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_prod(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_prod$address() {
        return mlx_prod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_prod(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_prod(MemorySegment res, MemorySegment a, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_prod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_prod", res, a, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_put_along_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_put_along_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_put_along_axis(mlx_array *res, const mlx_array a, const mlx_array indices, const mlx_array values, int axis, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_put_along_axis$descriptor() {
        return mlx_put_along_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_put_along_axis(mlx_array *res, const mlx_array a, const mlx_array indices, const mlx_array values, int axis, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_put_along_axis$handle() {
        return mlx_put_along_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_put_along_axis(mlx_array *res, const mlx_array a, const mlx_array indices, const mlx_array values, int axis, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_put_along_axis$address() {
        return mlx_put_along_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_put_along_axis(mlx_array *res, const mlx_array a, const mlx_array indices, const mlx_array values, int axis, const mlx_stream s)
     * }
     */
    public static int mlx_put_along_axis(MemorySegment res, MemorySegment a, MemorySegment indices, MemorySegment values, int axis, MemorySegment s) {
        var mh$ = mlx_put_along_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_put_along_axis", res, a, indices, values, axis, s);
            }
            return (int)mh$.invokeExact(res, a, indices, values, axis, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_quantize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_quantize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_quantize(mlx_array *res_0, mlx_array *res_1, mlx_array *res_2, const mlx_array w, int group_size, int bits, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_quantize$descriptor() {
        return mlx_quantize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_quantize(mlx_array *res_0, mlx_array *res_1, mlx_array *res_2, const mlx_array w, int group_size, int bits, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_quantize$handle() {
        return mlx_quantize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_quantize(mlx_array *res_0, mlx_array *res_1, mlx_array *res_2, const mlx_array w, int group_size, int bits, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_quantize$address() {
        return mlx_quantize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_quantize(mlx_array *res_0, mlx_array *res_1, mlx_array *res_2, const mlx_array w, int group_size, int bits, const mlx_stream s)
     * }
     */
    public static int mlx_quantize(MemorySegment res_0, MemorySegment res_1, MemorySegment res_2, MemorySegment w, int group_size, int bits, MemorySegment s) {
        var mh$ = mlx_quantize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_quantize", res_0, res_1, res_2, w, group_size, bits, s);
            }
            return (int)mh$.invokeExact(res_0, res_1, res_2, w, group_size, bits, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_quantized_matmul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_BOOL,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_quantized_matmul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_quantized_matmul(mlx_array *res, const mlx_array x, const mlx_array w, const mlx_array scales, const mlx_array biases, bool transpose, int group_size, int bits, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_quantized_matmul$descriptor() {
        return mlx_quantized_matmul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_quantized_matmul(mlx_array *res, const mlx_array x, const mlx_array w, const mlx_array scales, const mlx_array biases, bool transpose, int group_size, int bits, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_quantized_matmul$handle() {
        return mlx_quantized_matmul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_quantized_matmul(mlx_array *res, const mlx_array x, const mlx_array w, const mlx_array scales, const mlx_array biases, bool transpose, int group_size, int bits, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_quantized_matmul$address() {
        return mlx_quantized_matmul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_quantized_matmul(mlx_array *res, const mlx_array x, const mlx_array w, const mlx_array scales, const mlx_array biases, bool transpose, int group_size, int bits, const mlx_stream s)
     * }
     */
    public static int mlx_quantized_matmul(MemorySegment res, MemorySegment x, MemorySegment w, MemorySegment scales, MemorySegment biases, boolean transpose, int group_size, int bits, MemorySegment s) {
        var mh$ = mlx_quantized_matmul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_quantized_matmul", res, x, w, scales, biases, transpose, group_size, bits, s);
            }
            return (int)mh$.invokeExact(res, x, w, scales, biases, transpose, group_size, bits, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_radians {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_radians");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_radians(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_radians$descriptor() {
        return mlx_radians.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_radians(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_radians$handle() {
        return mlx_radians.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_radians(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_radians$address() {
        return mlx_radians.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_radians(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_radians(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_radians.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_radians", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_real {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_real");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_real(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_real$descriptor() {
        return mlx_real.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_real(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_real$handle() {
        return mlx_real.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_real(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_real$address() {
        return mlx_real.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_real(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_real(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_real.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_real", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_reciprocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_reciprocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_reciprocal(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_reciprocal$descriptor() {
        return mlx_reciprocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_reciprocal(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_reciprocal$handle() {
        return mlx_reciprocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_reciprocal(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_reciprocal$address() {
        return mlx_reciprocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_reciprocal(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_reciprocal(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_reciprocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_reciprocal", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_remainder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_remainder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_remainder(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_remainder$descriptor() {
        return mlx_remainder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_remainder(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_remainder$handle() {
        return mlx_remainder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_remainder(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_remainder$address() {
        return mlx_remainder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_remainder(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_remainder(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_remainder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_remainder", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_repeat_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_repeat_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_repeat_axis(mlx_array *res, const mlx_array arr, int repeats, int axis, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_repeat_axis$descriptor() {
        return mlx_repeat_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_repeat_axis(mlx_array *res, const mlx_array arr, int repeats, int axis, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_repeat_axis$handle() {
        return mlx_repeat_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_repeat_axis(mlx_array *res, const mlx_array arr, int repeats, int axis, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_repeat_axis$address() {
        return mlx_repeat_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_repeat_axis(mlx_array *res, const mlx_array arr, int repeats, int axis, const mlx_stream s)
     * }
     */
    public static int mlx_repeat_axis(MemorySegment res, MemorySegment arr, int repeats, int axis, MemorySegment s) {
        var mh$ = mlx_repeat_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_repeat_axis", res, arr, repeats, axis, s);
            }
            return (int)mh$.invokeExact(res, arr, repeats, axis, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_repeat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_repeat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_repeat(mlx_array *res, const mlx_array arr, int repeats, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_repeat$descriptor() {
        return mlx_repeat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_repeat(mlx_array *res, const mlx_array arr, int repeats, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_repeat$handle() {
        return mlx_repeat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_repeat(mlx_array *res, const mlx_array arr, int repeats, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_repeat$address() {
        return mlx_repeat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_repeat(mlx_array *res, const mlx_array arr, int repeats, const mlx_stream s)
     * }
     */
    public static int mlx_repeat(MemorySegment res, MemorySegment arr, int repeats, MemorySegment s) {
        var mh$ = mlx_repeat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_repeat", res, arr, repeats, s);
            }
            return (int)mh$.invokeExact(res, arr, repeats, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_reshape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_reshape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_reshape(mlx_array *res, const mlx_array a, const int *shape, size_t shape_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_reshape$descriptor() {
        return mlx_reshape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_reshape(mlx_array *res, const mlx_array a, const int *shape, size_t shape_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_reshape$handle() {
        return mlx_reshape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_reshape(mlx_array *res, const mlx_array a, const int *shape, size_t shape_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_reshape$address() {
        return mlx_reshape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_reshape(mlx_array *res, const mlx_array a, const int *shape, size_t shape_num, const mlx_stream s)
     * }
     */
    public static int mlx_reshape(MemorySegment res, MemorySegment a, MemorySegment shape, long shape_num, MemorySegment s) {
        var mh$ = mlx_reshape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_reshape", res, a, shape, shape_num, s);
            }
            return (int)mh$.invokeExact(res, a, shape, shape_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_right_shift {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_right_shift");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_right_shift(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_right_shift$descriptor() {
        return mlx_right_shift.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_right_shift(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_right_shift$handle() {
        return mlx_right_shift.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_right_shift(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_right_shift$address() {
        return mlx_right_shift.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_right_shift(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_right_shift(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_right_shift.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_right_shift", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_roll_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_roll_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_roll_axis(mlx_array *res, const mlx_array a, const int *shift, size_t shift_num, int axis, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_roll_axis$descriptor() {
        return mlx_roll_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_roll_axis(mlx_array *res, const mlx_array a, const int *shift, size_t shift_num, int axis, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_roll_axis$handle() {
        return mlx_roll_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_roll_axis(mlx_array *res, const mlx_array a, const int *shift, size_t shift_num, int axis, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_roll_axis$address() {
        return mlx_roll_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_roll_axis(mlx_array *res, const mlx_array a, const int *shift, size_t shift_num, int axis, const mlx_stream s)
     * }
     */
    public static int mlx_roll_axis(MemorySegment res, MemorySegment a, MemorySegment shift, long shift_num, int axis, MemorySegment s) {
        var mh$ = mlx_roll_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_roll_axis", res, a, shift, shift_num, axis, s);
            }
            return (int)mh$.invokeExact(res, a, shift, shift_num, axis, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_roll_axes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_roll_axes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_roll_axes(mlx_array *res, const mlx_array a, const int *shift, size_t shift_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_roll_axes$descriptor() {
        return mlx_roll_axes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_roll_axes(mlx_array *res, const mlx_array a, const int *shift, size_t shift_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_roll_axes$handle() {
        return mlx_roll_axes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_roll_axes(mlx_array *res, const mlx_array a, const int *shift, size_t shift_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_roll_axes$address() {
        return mlx_roll_axes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_roll_axes(mlx_array *res, const mlx_array a, const int *shift, size_t shift_num, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static int mlx_roll_axes(MemorySegment res, MemorySegment a, MemorySegment shift, long shift_num, MemorySegment axes, long axes_num, MemorySegment s) {
        var mh$ = mlx_roll_axes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_roll_axes", res, a, shift, shift_num, axes, axes_num, s);
            }
            return (int)mh$.invokeExact(res, a, shift, shift_num, axes, axes_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_roll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_roll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_roll(mlx_array *res, const mlx_array a, const int *shift, size_t shift_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_roll$descriptor() {
        return mlx_roll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_roll(mlx_array *res, const mlx_array a, const int *shift, size_t shift_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_roll$handle() {
        return mlx_roll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_roll(mlx_array *res, const mlx_array a, const int *shift, size_t shift_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_roll$address() {
        return mlx_roll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_roll(mlx_array *res, const mlx_array a, const int *shift, size_t shift_num, const mlx_stream s)
     * }
     */
    public static int mlx_roll(MemorySegment res, MemorySegment a, MemorySegment shift, long shift_num, MemorySegment s) {
        var mh$ = mlx_roll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_roll", res, a, shift, shift_num, s);
            }
            return (int)mh$.invokeExact(res, a, shift, shift_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_round {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_round");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_round(mlx_array *res, const mlx_array a, int decimals, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_round$descriptor() {
        return mlx_round.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_round(mlx_array *res, const mlx_array a, int decimals, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_round$handle() {
        return mlx_round.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_round(mlx_array *res, const mlx_array a, int decimals, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_round$address() {
        return mlx_round.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_round(mlx_array *res, const mlx_array a, int decimals, const mlx_stream s)
     * }
     */
    public static int mlx_round(MemorySegment res, MemorySegment a, int decimals, MemorySegment s) {
        var mh$ = mlx_round.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_round", res, a, decimals, s);
            }
            return (int)mh$.invokeExact(res, a, decimals, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_rsqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_rsqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_rsqrt(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_rsqrt$descriptor() {
        return mlx_rsqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_rsqrt(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_rsqrt$handle() {
        return mlx_rsqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_rsqrt(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_rsqrt$address() {
        return mlx_rsqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_rsqrt(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_rsqrt(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_rsqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_rsqrt", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_scatter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_vector_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_scatter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_scatter(mlx_array *res, const mlx_array a, const mlx_vector_array indices, const mlx_array updates, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_scatter$descriptor() {
        return mlx_scatter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_scatter(mlx_array *res, const mlx_array a, const mlx_vector_array indices, const mlx_array updates, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_scatter$handle() {
        return mlx_scatter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_scatter(mlx_array *res, const mlx_array a, const mlx_vector_array indices, const mlx_array updates, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_scatter$address() {
        return mlx_scatter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_scatter(mlx_array *res, const mlx_array a, const mlx_vector_array indices, const mlx_array updates, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static int mlx_scatter(MemorySegment res, MemorySegment a, MemorySegment indices, MemorySegment updates, MemorySegment axes, long axes_num, MemorySegment s) {
        var mh$ = mlx_scatter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_scatter", res, a, indices, updates, axes, axes_num, s);
            }
            return (int)mh$.invokeExact(res, a, indices, updates, axes, axes_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_scatter_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_vector_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_scatter_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_scatter_add(mlx_array *res, const mlx_array a, const mlx_vector_array indices, const mlx_array updates, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_scatter_add$descriptor() {
        return mlx_scatter_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_scatter_add(mlx_array *res, const mlx_array a, const mlx_vector_array indices, const mlx_array updates, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_scatter_add$handle() {
        return mlx_scatter_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_scatter_add(mlx_array *res, const mlx_array a, const mlx_vector_array indices, const mlx_array updates, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_scatter_add$address() {
        return mlx_scatter_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_scatter_add(mlx_array *res, const mlx_array a, const mlx_vector_array indices, const mlx_array updates, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static int mlx_scatter_add(MemorySegment res, MemorySegment a, MemorySegment indices, MemorySegment updates, MemorySegment axes, long axes_num, MemorySegment s) {
        var mh$ = mlx_scatter_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_scatter_add", res, a, indices, updates, axes, axes_num, s);
            }
            return (int)mh$.invokeExact(res, a, indices, updates, axes, axes_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_scatter_add_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_scatter_add_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_scatter_add_axis(mlx_array *res, const mlx_array a, const mlx_array indices, const mlx_array values, int axis, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_scatter_add_axis$descriptor() {
        return mlx_scatter_add_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_scatter_add_axis(mlx_array *res, const mlx_array a, const mlx_array indices, const mlx_array values, int axis, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_scatter_add_axis$handle() {
        return mlx_scatter_add_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_scatter_add_axis(mlx_array *res, const mlx_array a, const mlx_array indices, const mlx_array values, int axis, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_scatter_add_axis$address() {
        return mlx_scatter_add_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_scatter_add_axis(mlx_array *res, const mlx_array a, const mlx_array indices, const mlx_array values, int axis, const mlx_stream s)
     * }
     */
    public static int mlx_scatter_add_axis(MemorySegment res, MemorySegment a, MemorySegment indices, MemorySegment values, int axis, MemorySegment s) {
        var mh$ = mlx_scatter_add_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_scatter_add_axis", res, a, indices, values, axis, s);
            }
            return (int)mh$.invokeExact(res, a, indices, values, axis, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_scatter_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_vector_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_scatter_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_scatter_max(mlx_array *res, const mlx_array a, const mlx_vector_array indices, const mlx_array updates, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_scatter_max$descriptor() {
        return mlx_scatter_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_scatter_max(mlx_array *res, const mlx_array a, const mlx_vector_array indices, const mlx_array updates, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_scatter_max$handle() {
        return mlx_scatter_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_scatter_max(mlx_array *res, const mlx_array a, const mlx_vector_array indices, const mlx_array updates, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_scatter_max$address() {
        return mlx_scatter_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_scatter_max(mlx_array *res, const mlx_array a, const mlx_vector_array indices, const mlx_array updates, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static int mlx_scatter_max(MemorySegment res, MemorySegment a, MemorySegment indices, MemorySegment updates, MemorySegment axes, long axes_num, MemorySegment s) {
        var mh$ = mlx_scatter_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_scatter_max", res, a, indices, updates, axes, axes_num, s);
            }
            return (int)mh$.invokeExact(res, a, indices, updates, axes, axes_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_scatter_min {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_vector_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_scatter_min");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_scatter_min(mlx_array *res, const mlx_array a, const mlx_vector_array indices, const mlx_array updates, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_scatter_min$descriptor() {
        return mlx_scatter_min.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_scatter_min(mlx_array *res, const mlx_array a, const mlx_vector_array indices, const mlx_array updates, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_scatter_min$handle() {
        return mlx_scatter_min.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_scatter_min(mlx_array *res, const mlx_array a, const mlx_vector_array indices, const mlx_array updates, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_scatter_min$address() {
        return mlx_scatter_min.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_scatter_min(mlx_array *res, const mlx_array a, const mlx_vector_array indices, const mlx_array updates, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static int mlx_scatter_min(MemorySegment res, MemorySegment a, MemorySegment indices, MemorySegment updates, MemorySegment axes, long axes_num, MemorySegment s) {
        var mh$ = mlx_scatter_min.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_scatter_min", res, a, indices, updates, axes, axes_num, s);
            }
            return (int)mh$.invokeExact(res, a, indices, updates, axes, axes_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_scatter_prod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_vector_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_scatter_prod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_scatter_prod(mlx_array *res, const mlx_array a, const mlx_vector_array indices, const mlx_array updates, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_scatter_prod$descriptor() {
        return mlx_scatter_prod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_scatter_prod(mlx_array *res, const mlx_array a, const mlx_vector_array indices, const mlx_array updates, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_scatter_prod$handle() {
        return mlx_scatter_prod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_scatter_prod(mlx_array *res, const mlx_array a, const mlx_vector_array indices, const mlx_array updates, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_scatter_prod$address() {
        return mlx_scatter_prod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_scatter_prod(mlx_array *res, const mlx_array a, const mlx_vector_array indices, const mlx_array updates, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static int mlx_scatter_prod(MemorySegment res, MemorySegment a, MemorySegment indices, MemorySegment updates, MemorySegment axes, long axes_num, MemorySegment s) {
        var mh$ = mlx_scatter_prod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_scatter_prod", res, a, indices, updates, axes, axes_num, s);
            }
            return (int)mh$.invokeExact(res, a, indices, updates, axes, axes_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_sigmoid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_sigmoid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_sigmoid(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_sigmoid$descriptor() {
        return mlx_sigmoid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_sigmoid(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_sigmoid$handle() {
        return mlx_sigmoid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_sigmoid(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_sigmoid$address() {
        return mlx_sigmoid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_sigmoid(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_sigmoid(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_sigmoid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_sigmoid", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_sign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_sign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_sign(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_sign$descriptor() {
        return mlx_sign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_sign(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_sign$handle() {
        return mlx_sign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_sign(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_sign$address() {
        return mlx_sign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_sign(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_sign(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_sign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_sign", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_sin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_sin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_sin(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_sin$descriptor() {
        return mlx_sin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_sin(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_sin$handle() {
        return mlx_sin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_sin(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_sin$address() {
        return mlx_sin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_sin(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_sin(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_sin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_sin", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_sinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_sinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_sinh(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_sinh$descriptor() {
        return mlx_sinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_sinh(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_sinh$handle() {
        return mlx_sinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_sinh(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_sinh$address() {
        return mlx_sinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_sinh(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_sinh(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_sinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_sinh", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_slice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_slice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_slice(mlx_array *res, const mlx_array a, const int *start, size_t start_num, const int *stop, size_t stop_num, const int *strides, size_t strides_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_slice$descriptor() {
        return mlx_slice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_slice(mlx_array *res, const mlx_array a, const int *start, size_t start_num, const int *stop, size_t stop_num, const int *strides, size_t strides_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_slice$handle() {
        return mlx_slice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_slice(mlx_array *res, const mlx_array a, const int *start, size_t start_num, const int *stop, size_t stop_num, const int *strides, size_t strides_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_slice$address() {
        return mlx_slice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_slice(mlx_array *res, const mlx_array a, const int *start, size_t start_num, const int *stop, size_t stop_num, const int *strides, size_t strides_num, const mlx_stream s)
     * }
     */
    public static int mlx_slice(MemorySegment res, MemorySegment a, MemorySegment start, long start_num, MemorySegment stop, long stop_num, MemorySegment strides, long strides_num, MemorySegment s) {
        var mh$ = mlx_slice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_slice", res, a, start, start_num, stop, stop_num, strides, strides_num, s);
            }
            return (int)mh$.invokeExact(res, a, start, start_num, stop, stop_num, strides, strides_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_slice_dynamic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_slice_dynamic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_slice_dynamic(mlx_array *res, const mlx_array a, const mlx_array start, const int *axes, size_t axes_num, const int *slice_size, size_t slice_size_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_slice_dynamic$descriptor() {
        return mlx_slice_dynamic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_slice_dynamic(mlx_array *res, const mlx_array a, const mlx_array start, const int *axes, size_t axes_num, const int *slice_size, size_t slice_size_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_slice_dynamic$handle() {
        return mlx_slice_dynamic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_slice_dynamic(mlx_array *res, const mlx_array a, const mlx_array start, const int *axes, size_t axes_num, const int *slice_size, size_t slice_size_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_slice_dynamic$address() {
        return mlx_slice_dynamic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_slice_dynamic(mlx_array *res, const mlx_array a, const mlx_array start, const int *axes, size_t axes_num, const int *slice_size, size_t slice_size_num, const mlx_stream s)
     * }
     */
    public static int mlx_slice_dynamic(MemorySegment res, MemorySegment a, MemorySegment start, MemorySegment axes, long axes_num, MemorySegment slice_size, long slice_size_num, MemorySegment s) {
        var mh$ = mlx_slice_dynamic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_slice_dynamic", res, a, start, axes, axes_num, slice_size, slice_size_num, s);
            }
            return (int)mh$.invokeExact(res, a, start, axes, axes_num, slice_size, slice_size_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_slice_update {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_slice_update");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_slice_update(mlx_array *res, const mlx_array src, const mlx_array update, const int *start, size_t start_num, const int *stop, size_t stop_num, const int *strides, size_t strides_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_slice_update$descriptor() {
        return mlx_slice_update.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_slice_update(mlx_array *res, const mlx_array src, const mlx_array update, const int *start, size_t start_num, const int *stop, size_t stop_num, const int *strides, size_t strides_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_slice_update$handle() {
        return mlx_slice_update.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_slice_update(mlx_array *res, const mlx_array src, const mlx_array update, const int *start, size_t start_num, const int *stop, size_t stop_num, const int *strides, size_t strides_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_slice_update$address() {
        return mlx_slice_update.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_slice_update(mlx_array *res, const mlx_array src, const mlx_array update, const int *start, size_t start_num, const int *stop, size_t stop_num, const int *strides, size_t strides_num, const mlx_stream s)
     * }
     */
    public static int mlx_slice_update(MemorySegment res, MemorySegment src, MemorySegment update, MemorySegment start, long start_num, MemorySegment stop, long stop_num, MemorySegment strides, long strides_num, MemorySegment s) {
        var mh$ = mlx_slice_update.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_slice_update", res, src, update, start, start_num, stop, stop_num, strides, strides_num, s);
            }
            return (int)mh$.invokeExact(res, src, update, start, start_num, stop, stop_num, strides, strides_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_slice_update_dynamic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_slice_update_dynamic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_slice_update_dynamic(mlx_array *res, const mlx_array src, const mlx_array update, const mlx_array start, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_slice_update_dynamic$descriptor() {
        return mlx_slice_update_dynamic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_slice_update_dynamic(mlx_array *res, const mlx_array src, const mlx_array update, const mlx_array start, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_slice_update_dynamic$handle() {
        return mlx_slice_update_dynamic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_slice_update_dynamic(mlx_array *res, const mlx_array src, const mlx_array update, const mlx_array start, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_slice_update_dynamic$address() {
        return mlx_slice_update_dynamic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_slice_update_dynamic(mlx_array *res, const mlx_array src, const mlx_array update, const mlx_array start, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static int mlx_slice_update_dynamic(MemorySegment res, MemorySegment src, MemorySegment update, MemorySegment start, MemorySegment axes, long axes_num, MemorySegment s) {
        var mh$ = mlx_slice_update_dynamic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_slice_update_dynamic", res, src, update, start, axes, axes_num, s);
            }
            return (int)mh$.invokeExact(res, src, update, start, axes, axes_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_softmax_axes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_softmax_axes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_softmax_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool precise, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_softmax_axes$descriptor() {
        return mlx_softmax_axes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_softmax_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool precise, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_softmax_axes$handle() {
        return mlx_softmax_axes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_softmax_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool precise, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_softmax_axes$address() {
        return mlx_softmax_axes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_softmax_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool precise, const mlx_stream s)
     * }
     */
    public static int mlx_softmax_axes(MemorySegment res, MemorySegment a, MemorySegment axes, long axes_num, boolean precise, MemorySegment s) {
        var mh$ = mlx_softmax_axes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_softmax_axes", res, a, axes, axes_num, precise, s);
            }
            return (int)mh$.invokeExact(res, a, axes, axes_num, precise, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_softmax_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_softmax_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_softmax_axis(mlx_array *res, const mlx_array a, int axis, bool precise, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_softmax_axis$descriptor() {
        return mlx_softmax_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_softmax_axis(mlx_array *res, const mlx_array a, int axis, bool precise, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_softmax_axis$handle() {
        return mlx_softmax_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_softmax_axis(mlx_array *res, const mlx_array a, int axis, bool precise, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_softmax_axis$address() {
        return mlx_softmax_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_softmax_axis(mlx_array *res, const mlx_array a, int axis, bool precise, const mlx_stream s)
     * }
     */
    public static int mlx_softmax_axis(MemorySegment res, MemorySegment a, int axis, boolean precise, MemorySegment s) {
        var mh$ = mlx_softmax_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_softmax_axis", res, a, axis, precise, s);
            }
            return (int)mh$.invokeExact(res, a, axis, precise, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_softmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_softmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_softmax(mlx_array *res, const mlx_array a, bool precise, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_softmax$descriptor() {
        return mlx_softmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_softmax(mlx_array *res, const mlx_array a, bool precise, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_softmax$handle() {
        return mlx_softmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_softmax(mlx_array *res, const mlx_array a, bool precise, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_softmax$address() {
        return mlx_softmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_softmax(mlx_array *res, const mlx_array a, bool precise, const mlx_stream s)
     * }
     */
    public static int mlx_softmax(MemorySegment res, MemorySegment a, boolean precise, MemorySegment s) {
        var mh$ = mlx_softmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_softmax", res, a, precise, s);
            }
            return (int)mh$.invokeExact(res, a, precise, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_sort_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_sort_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_sort_axis(mlx_array *res, const mlx_array a, int axis, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_sort_axis$descriptor() {
        return mlx_sort_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_sort_axis(mlx_array *res, const mlx_array a, int axis, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_sort_axis$handle() {
        return mlx_sort_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_sort_axis(mlx_array *res, const mlx_array a, int axis, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_sort_axis$address() {
        return mlx_sort_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_sort_axis(mlx_array *res, const mlx_array a, int axis, const mlx_stream s)
     * }
     */
    public static int mlx_sort_axis(MemorySegment res, MemorySegment a, int axis, MemorySegment s) {
        var mh$ = mlx_sort_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_sort_axis", res, a, axis, s);
            }
            return (int)mh$.invokeExact(res, a, axis, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_sort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_sort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_sort(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_sort$descriptor() {
        return mlx_sort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_sort(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_sort$handle() {
        return mlx_sort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_sort(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_sort$address() {
        return mlx_sort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_sort(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_sort(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_sort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_sort", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_split {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_split");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_split(mlx_vector_array *res, const mlx_array a, int num_splits, int axis, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_split$descriptor() {
        return mlx_split.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_split(mlx_vector_array *res, const mlx_array a, int num_splits, int axis, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_split$handle() {
        return mlx_split.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_split(mlx_vector_array *res, const mlx_array a, int num_splits, int axis, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_split$address() {
        return mlx_split.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_split(mlx_vector_array *res, const mlx_array a, int num_splits, int axis, const mlx_stream s)
     * }
     */
    public static int mlx_split(MemorySegment res, MemorySegment a, int num_splits, int axis, MemorySegment s) {
        var mh$ = mlx_split.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_split", res, a, num_splits, axis, s);
            }
            return (int)mh$.invokeExact(res, a, num_splits, axis, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_split_sections {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_split_sections");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_split_sections(mlx_vector_array *res, const mlx_array a, const int *indices, size_t indices_num, int axis, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_split_sections$descriptor() {
        return mlx_split_sections.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_split_sections(mlx_vector_array *res, const mlx_array a, const int *indices, size_t indices_num, int axis, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_split_sections$handle() {
        return mlx_split_sections.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_split_sections(mlx_vector_array *res, const mlx_array a, const int *indices, size_t indices_num, int axis, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_split_sections$address() {
        return mlx_split_sections.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_split_sections(mlx_vector_array *res, const mlx_array a, const int *indices, size_t indices_num, int axis, const mlx_stream s)
     * }
     */
    public static int mlx_split_sections(MemorySegment res, MemorySegment a, MemorySegment indices, long indices_num, int axis, MemorySegment s) {
        var mh$ = mlx_split_sections.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_split_sections", res, a, indices, indices_num, axis, s);
            }
            return (int)mh$.invokeExact(res, a, indices, indices_num, axis, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_sqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_sqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_sqrt(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_sqrt$descriptor() {
        return mlx_sqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_sqrt(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_sqrt$handle() {
        return mlx_sqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_sqrt(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_sqrt$address() {
        return mlx_sqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_sqrt(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_sqrt(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_sqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_sqrt", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_square {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_square");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_square(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_square$descriptor() {
        return mlx_square.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_square(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_square$handle() {
        return mlx_square.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_square(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_square$address() {
        return mlx_square.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_square(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_square(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_square.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_square", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_squeeze_axes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_squeeze_axes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_squeeze_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_squeeze_axes$descriptor() {
        return mlx_squeeze_axes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_squeeze_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_squeeze_axes$handle() {
        return mlx_squeeze_axes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_squeeze_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_squeeze_axes$address() {
        return mlx_squeeze_axes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_squeeze_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static int mlx_squeeze_axes(MemorySegment res, MemorySegment a, MemorySegment axes, long axes_num, MemorySegment s) {
        var mh$ = mlx_squeeze_axes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_squeeze_axes", res, a, axes, axes_num, s);
            }
            return (int)mh$.invokeExact(res, a, axes, axes_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_squeeze_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_squeeze_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_squeeze_axis(mlx_array *res, const mlx_array a, int axis, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_squeeze_axis$descriptor() {
        return mlx_squeeze_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_squeeze_axis(mlx_array *res, const mlx_array a, int axis, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_squeeze_axis$handle() {
        return mlx_squeeze_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_squeeze_axis(mlx_array *res, const mlx_array a, int axis, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_squeeze_axis$address() {
        return mlx_squeeze_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_squeeze_axis(mlx_array *res, const mlx_array a, int axis, const mlx_stream s)
     * }
     */
    public static int mlx_squeeze_axis(MemorySegment res, MemorySegment a, int axis, MemorySegment s) {
        var mh$ = mlx_squeeze_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_squeeze_axis", res, a, axis, s);
            }
            return (int)mh$.invokeExact(res, a, axis, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_squeeze {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_squeeze");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_squeeze(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_squeeze$descriptor() {
        return mlx_squeeze.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_squeeze(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_squeeze$handle() {
        return mlx_squeeze.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_squeeze(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_squeeze$address() {
        return mlx_squeeze.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_squeeze(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_squeeze(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_squeeze.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_squeeze", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_stack_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_vector_array_.layout(),
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_stack_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_stack_axis(mlx_array *res, const mlx_vector_array arrays, int axis, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_stack_axis$descriptor() {
        return mlx_stack_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_stack_axis(mlx_array *res, const mlx_vector_array arrays, int axis, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_stack_axis$handle() {
        return mlx_stack_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_stack_axis(mlx_array *res, const mlx_vector_array arrays, int axis, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_stack_axis$address() {
        return mlx_stack_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_stack_axis(mlx_array *res, const mlx_vector_array arrays, int axis, const mlx_stream s)
     * }
     */
    public static int mlx_stack_axis(MemorySegment res, MemorySegment arrays, int axis, MemorySegment s) {
        var mh$ = mlx_stack_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_stack_axis", res, arrays, axis, s);
            }
            return (int)mh$.invokeExact(res, arrays, axis, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_stack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_vector_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_stack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_stack(mlx_array *res, const mlx_vector_array arrays, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_stack$descriptor() {
        return mlx_stack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_stack(mlx_array *res, const mlx_vector_array arrays, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_stack$handle() {
        return mlx_stack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_stack(mlx_array *res, const mlx_vector_array arrays, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_stack$address() {
        return mlx_stack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_stack(mlx_array *res, const mlx_vector_array arrays, const mlx_stream s)
     * }
     */
    public static int mlx_stack(MemorySegment res, MemorySegment arrays, MemorySegment s) {
        var mh$ = mlx_stack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_stack", res, arrays, s);
            }
            return (int)mh$.invokeExact(res, arrays, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_std_axes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_BOOL,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_std_axes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_std_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, int ddof, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_std_axes$descriptor() {
        return mlx_std_axes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_std_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, int ddof, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_std_axes$handle() {
        return mlx_std_axes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_std_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, int ddof, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_std_axes$address() {
        return mlx_std_axes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_std_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, int ddof, const mlx_stream s)
     * }
     */
    public static int mlx_std_axes(MemorySegment res, MemorySegment a, MemorySegment axes, long axes_num, boolean keepdims, int ddof, MemorySegment s) {
        var mh$ = mlx_std_axes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_std_axes", res, a, axes, axes_num, keepdims, ddof, s);
            }
            return (int)mh$.invokeExact(res, a, axes, axes_num, keepdims, ddof, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_std_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_BOOL,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_std_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_std_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, int ddof, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_std_axis$descriptor() {
        return mlx_std_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_std_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, int ddof, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_std_axis$handle() {
        return mlx_std_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_std_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, int ddof, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_std_axis$address() {
        return mlx_std_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_std_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, int ddof, const mlx_stream s)
     * }
     */
    public static int mlx_std_axis(MemorySegment res, MemorySegment a, int axis, boolean keepdims, int ddof, MemorySegment s) {
        var mh$ = mlx_std_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_std_axis", res, a, axis, keepdims, ddof, s);
            }
            return (int)mh$.invokeExact(res, a, axis, keepdims, ddof, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_std {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_BOOL,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_std");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_std(mlx_array *res, const mlx_array a, bool keepdims, int ddof, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_std$descriptor() {
        return mlx_std.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_std(mlx_array *res, const mlx_array a, bool keepdims, int ddof, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_std$handle() {
        return mlx_std.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_std(mlx_array *res, const mlx_array a, bool keepdims, int ddof, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_std$address() {
        return mlx_std.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_std(mlx_array *res, const mlx_array a, bool keepdims, int ddof, const mlx_stream s)
     * }
     */
    public static int mlx_std(MemorySegment res, MemorySegment a, boolean keepdims, int ddof, MemorySegment s) {
        var mh$ = mlx_std.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_std", res, a, keepdims, ddof, s);
            }
            return (int)mh$.invokeExact(res, a, keepdims, ddof, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_stop_gradient {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_stop_gradient");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_stop_gradient(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_stop_gradient$descriptor() {
        return mlx_stop_gradient.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_stop_gradient(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_stop_gradient$handle() {
        return mlx_stop_gradient.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_stop_gradient(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_stop_gradient$address() {
        return mlx_stop_gradient.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_stop_gradient(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_stop_gradient(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_stop_gradient.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_stop_gradient", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_subtract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_subtract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_subtract(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_subtract$descriptor() {
        return mlx_subtract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_subtract(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_subtract$handle() {
        return mlx_subtract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_subtract(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_subtract$address() {
        return mlx_subtract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_subtract(mlx_array *res, const mlx_array a, const mlx_array b, const mlx_stream s)
     * }
     */
    public static int mlx_subtract(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment s) {
        var mh$ = mlx_subtract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_subtract", res, a, b, s);
            }
            return (int)mh$.invokeExact(res, a, b, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_sum_axes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_sum_axes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_sum_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_sum_axes$descriptor() {
        return mlx_sum_axes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_sum_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_sum_axes$handle() {
        return mlx_sum_axes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_sum_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_sum_axes$address() {
        return mlx_sum_axes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_sum_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_sum_axes(MemorySegment res, MemorySegment a, MemorySegment axes, long axes_num, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_sum_axes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_sum_axes", res, a, axes, axes_num, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, axes, axes_num, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_sum_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_sum_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_sum_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_sum_axis$descriptor() {
        return mlx_sum_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_sum_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_sum_axis$handle() {
        return mlx_sum_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_sum_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_sum_axis$address() {
        return mlx_sum_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_sum_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_sum_axis(MemorySegment res, MemorySegment a, int axis, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_sum_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_sum_axis", res, a, axis, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, axis, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_sum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_BOOL,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_sum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_sum(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_sum$descriptor() {
        return mlx_sum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_sum(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_sum$handle() {
        return mlx_sum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_sum(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_sum$address() {
        return mlx_sum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_sum(mlx_array *res, const mlx_array a, bool keepdims, const mlx_stream s)
     * }
     */
    public static int mlx_sum(MemorySegment res, MemorySegment a, boolean keepdims, MemorySegment s) {
        var mh$ = mlx_sum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_sum", res, a, keepdims, s);
            }
            return (int)mh$.invokeExact(res, a, keepdims, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_swapaxes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_swapaxes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_swapaxes(mlx_array *res, const mlx_array a, int axis1, int axis2, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_swapaxes$descriptor() {
        return mlx_swapaxes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_swapaxes(mlx_array *res, const mlx_array a, int axis1, int axis2, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_swapaxes$handle() {
        return mlx_swapaxes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_swapaxes(mlx_array *res, const mlx_array a, int axis1, int axis2, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_swapaxes$address() {
        return mlx_swapaxes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_swapaxes(mlx_array *res, const mlx_array a, int axis1, int axis2, const mlx_stream s)
     * }
     */
    public static int mlx_swapaxes(MemorySegment res, MemorySegment a, int axis1, int axis2, MemorySegment s) {
        var mh$ = mlx_swapaxes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_swapaxes", res, a, axis1, axis2, s);
            }
            return (int)mh$.invokeExact(res, a, axis1, axis2, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_take_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_take_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_take_axis(mlx_array *res, const mlx_array a, const mlx_array indices, int axis, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_take_axis$descriptor() {
        return mlx_take_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_take_axis(mlx_array *res, const mlx_array a, const mlx_array indices, int axis, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_take_axis$handle() {
        return mlx_take_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_take_axis(mlx_array *res, const mlx_array a, const mlx_array indices, int axis, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_take_axis$address() {
        return mlx_take_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_take_axis(mlx_array *res, const mlx_array a, const mlx_array indices, int axis, const mlx_stream s)
     * }
     */
    public static int mlx_take_axis(MemorySegment res, MemorySegment a, MemorySegment indices, int axis, MemorySegment s) {
        var mh$ = mlx_take_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_take_axis", res, a, indices, axis, s);
            }
            return (int)mh$.invokeExact(res, a, indices, axis, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_take {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_take");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_take(mlx_array *res, const mlx_array a, const mlx_array indices, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_take$descriptor() {
        return mlx_take.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_take(mlx_array *res, const mlx_array a, const mlx_array indices, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_take$handle() {
        return mlx_take.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_take(mlx_array *res, const mlx_array a, const mlx_array indices, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_take$address() {
        return mlx_take.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_take(mlx_array *res, const mlx_array a, const mlx_array indices, const mlx_stream s)
     * }
     */
    public static int mlx_take(MemorySegment res, MemorySegment a, MemorySegment indices, MemorySegment s) {
        var mh$ = mlx_take.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_take", res, a, indices, s);
            }
            return (int)mh$.invokeExact(res, a, indices, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_take_along_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_take_along_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_take_along_axis(mlx_array *res, const mlx_array a, const mlx_array indices, int axis, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_take_along_axis$descriptor() {
        return mlx_take_along_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_take_along_axis(mlx_array *res, const mlx_array a, const mlx_array indices, int axis, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_take_along_axis$handle() {
        return mlx_take_along_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_take_along_axis(mlx_array *res, const mlx_array a, const mlx_array indices, int axis, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_take_along_axis$address() {
        return mlx_take_along_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_take_along_axis(mlx_array *res, const mlx_array a, const mlx_array indices, int axis, const mlx_stream s)
     * }
     */
    public static int mlx_take_along_axis(MemorySegment res, MemorySegment a, MemorySegment indices, int axis, MemorySegment s) {
        var mh$ = mlx_take_along_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_take_along_axis", res, a, indices, axis, s);
            }
            return (int)mh$.invokeExact(res, a, indices, axis, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_tan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_tan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_tan(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_tan$descriptor() {
        return mlx_tan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_tan(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_tan$handle() {
        return mlx_tan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_tan(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_tan$address() {
        return mlx_tan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_tan(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_tan(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_tan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_tan", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_tanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_tanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_tanh(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_tanh$descriptor() {
        return mlx_tanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_tanh(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_tanh$handle() {
        return mlx_tanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_tanh(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_tanh$address() {
        return mlx_tanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_tanh(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_tanh(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_tanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_tanh", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_tensordot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_tensordot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_tensordot(mlx_array *res, const mlx_array a, const mlx_array b, const int *axes_a, size_t axes_a_num, const int *axes_b, size_t axes_b_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_tensordot$descriptor() {
        return mlx_tensordot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_tensordot(mlx_array *res, const mlx_array a, const mlx_array b, const int *axes_a, size_t axes_a_num, const int *axes_b, size_t axes_b_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_tensordot$handle() {
        return mlx_tensordot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_tensordot(mlx_array *res, const mlx_array a, const mlx_array b, const int *axes_a, size_t axes_a_num, const int *axes_b, size_t axes_b_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_tensordot$address() {
        return mlx_tensordot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_tensordot(mlx_array *res, const mlx_array a, const mlx_array b, const int *axes_a, size_t axes_a_num, const int *axes_b, size_t axes_b_num, const mlx_stream s)
     * }
     */
    public static int mlx_tensordot(MemorySegment res, MemorySegment a, MemorySegment b, MemorySegment axes_a, long axes_a_num, MemorySegment axes_b, long axes_b_num, MemorySegment s) {
        var mh$ = mlx_tensordot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_tensordot", res, a, b, axes_a, axes_a_num, axes_b, axes_b_num, s);
            }
            return (int)mh$.invokeExact(res, a, b, axes_a, axes_a_num, axes_b, axes_b_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_tensordot_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_tensordot_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_tensordot_axis(mlx_array *res, const mlx_array a, const mlx_array b, int axis, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_tensordot_axis$descriptor() {
        return mlx_tensordot_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_tensordot_axis(mlx_array *res, const mlx_array a, const mlx_array b, int axis, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_tensordot_axis$handle() {
        return mlx_tensordot_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_tensordot_axis(mlx_array *res, const mlx_array a, const mlx_array b, int axis, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_tensordot_axis$address() {
        return mlx_tensordot_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_tensordot_axis(mlx_array *res, const mlx_array a, const mlx_array b, int axis, const mlx_stream s)
     * }
     */
    public static int mlx_tensordot_axis(MemorySegment res, MemorySegment a, MemorySegment b, int axis, MemorySegment s) {
        var mh$ = mlx_tensordot_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_tensordot_axis", res, a, b, axis, s);
            }
            return (int)mh$.invokeExact(res, a, b, axis, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_tile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_tile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_tile(mlx_array *res, const mlx_array arr, const int *reps, size_t reps_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_tile$descriptor() {
        return mlx_tile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_tile(mlx_array *res, const mlx_array arr, const int *reps, size_t reps_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_tile$handle() {
        return mlx_tile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_tile(mlx_array *res, const mlx_array arr, const int *reps, size_t reps_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_tile$address() {
        return mlx_tile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_tile(mlx_array *res, const mlx_array arr, const int *reps, size_t reps_num, const mlx_stream s)
     * }
     */
    public static int mlx_tile(MemorySegment res, MemorySegment arr, MemorySegment reps, long reps_num, MemorySegment s) {
        var mh$ = mlx_tile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_tile", res, arr, reps, reps_num, s);
            }
            return (int)mh$.invokeExact(res, arr, reps, reps_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_topk_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_topk_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_topk_axis(mlx_array *res, const mlx_array a, int k, int axis, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_topk_axis$descriptor() {
        return mlx_topk_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_topk_axis(mlx_array *res, const mlx_array a, int k, int axis, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_topk_axis$handle() {
        return mlx_topk_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_topk_axis(mlx_array *res, const mlx_array a, int k, int axis, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_topk_axis$address() {
        return mlx_topk_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_topk_axis(mlx_array *res, const mlx_array a, int k, int axis, const mlx_stream s)
     * }
     */
    public static int mlx_topk_axis(MemorySegment res, MemorySegment a, int k, int axis, MemorySegment s) {
        var mh$ = mlx_topk_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_topk_axis", res, a, k, axis, s);
            }
            return (int)mh$.invokeExact(res, a, k, axis, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_topk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_topk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_topk(mlx_array *res, const mlx_array a, int k, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_topk$descriptor() {
        return mlx_topk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_topk(mlx_array *res, const mlx_array a, int k, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_topk$handle() {
        return mlx_topk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_topk(mlx_array *res, const mlx_array a, int k, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_topk$address() {
        return mlx_topk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_topk(mlx_array *res, const mlx_array a, int k, const mlx_stream s)
     * }
     */
    public static int mlx_topk(MemorySegment res, MemorySegment a, int k, MemorySegment s) {
        var mh$ = mlx_topk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_topk", res, a, k, s);
            }
            return (int)mh$.invokeExact(res, a, k, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_trace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_trace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_trace(mlx_array *res, const mlx_array a, int offset, int axis1, int axis2, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_trace$descriptor() {
        return mlx_trace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_trace(mlx_array *res, const mlx_array a, int offset, int axis1, int axis2, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_trace$handle() {
        return mlx_trace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_trace(mlx_array *res, const mlx_array a, int offset, int axis1, int axis2, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_trace$address() {
        return mlx_trace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_trace(mlx_array *res, const mlx_array a, int offset, int axis1, int axis2, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static int mlx_trace(MemorySegment res, MemorySegment a, int offset, int axis1, int axis2, int dtype, MemorySegment s) {
        var mh$ = mlx_trace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_trace", res, a, offset, axis1, axis2, dtype, s);
            }
            return (int)mh$.invokeExact(res, a, offset, axis1, axis2, dtype, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_transpose_axes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_transpose_axes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_transpose_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_transpose_axes$descriptor() {
        return mlx_transpose_axes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_transpose_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_transpose_axes$handle() {
        return mlx_transpose_axes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_transpose_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_transpose_axes$address() {
        return mlx_transpose_axes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_transpose_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, const mlx_stream s)
     * }
     */
    public static int mlx_transpose_axes(MemorySegment res, MemorySegment a, MemorySegment axes, long axes_num, MemorySegment s) {
        var mh$ = mlx_transpose_axes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_transpose_axes", res, a, axes, axes_num, s);
            }
            return (int)mh$.invokeExact(res, a, axes, axes_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_transpose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_transpose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_transpose(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_transpose$descriptor() {
        return mlx_transpose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_transpose(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_transpose$handle() {
        return mlx_transpose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_transpose(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_transpose$address() {
        return mlx_transpose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_transpose(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_transpose(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_transpose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_transpose", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_tri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_tri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_tri(mlx_array *res, int n, int m, int k, mlx_dtype type, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_tri$descriptor() {
        return mlx_tri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_tri(mlx_array *res, int n, int m, int k, mlx_dtype type, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_tri$handle() {
        return mlx_tri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_tri(mlx_array *res, int n, int m, int k, mlx_dtype type, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_tri$address() {
        return mlx_tri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_tri(mlx_array *res, int n, int m, int k, mlx_dtype type, const mlx_stream s)
     * }
     */
    public static int mlx_tri(MemorySegment res, int n, int m, int k, int type, MemorySegment s) {
        var mh$ = mlx_tri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_tri", res, n, m, k, type, s);
            }
            return (int)mh$.invokeExact(res, n, m, k, type, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_tril {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_tril");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_tril(mlx_array *res, const mlx_array x, int k, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_tril$descriptor() {
        return mlx_tril.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_tril(mlx_array *res, const mlx_array x, int k, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_tril$handle() {
        return mlx_tril.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_tril(mlx_array *res, const mlx_array x, int k, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_tril$address() {
        return mlx_tril.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_tril(mlx_array *res, const mlx_array x, int k, const mlx_stream s)
     * }
     */
    public static int mlx_tril(MemorySegment res, MemorySegment x, int k, MemorySegment s) {
        var mh$ = mlx_tril.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_tril", res, x, k, s);
            }
            return (int)mh$.invokeExact(res, x, k, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_triu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_triu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_triu(mlx_array *res, const mlx_array x, int k, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_triu$descriptor() {
        return mlx_triu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_triu(mlx_array *res, const mlx_array x, int k, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_triu$handle() {
        return mlx_triu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_triu(mlx_array *res, const mlx_array x, int k, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_triu$address() {
        return mlx_triu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_triu(mlx_array *res, const mlx_array x, int k, const mlx_stream s)
     * }
     */
    public static int mlx_triu(MemorySegment res, MemorySegment x, int k, MemorySegment s) {
        var mh$ = mlx_triu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_triu", res, x, k, s);
            }
            return (int)mh$.invokeExact(res, x, k, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_unflatten {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_unflatten");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_unflatten(mlx_array *res, const mlx_array a, int axis, const int *shape, size_t shape_num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_unflatten$descriptor() {
        return mlx_unflatten.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_unflatten(mlx_array *res, const mlx_array a, int axis, const int *shape, size_t shape_num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_unflatten$handle() {
        return mlx_unflatten.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_unflatten(mlx_array *res, const mlx_array a, int axis, const int *shape, size_t shape_num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_unflatten$address() {
        return mlx_unflatten.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_unflatten(mlx_array *res, const mlx_array a, int axis, const int *shape, size_t shape_num, const mlx_stream s)
     * }
     */
    public static int mlx_unflatten(MemorySegment res, MemorySegment a, int axis, MemorySegment shape, long shape_num, MemorySegment s) {
        var mh$ = mlx_unflatten.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_unflatten", res, a, axis, shape, shape_num, s);
            }
            return (int)mh$.invokeExact(res, a, axis, shape, shape_num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_var_axes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_BOOL,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_var_axes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_var_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, int ddof, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_var_axes$descriptor() {
        return mlx_var_axes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_var_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, int ddof, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_var_axes$handle() {
        return mlx_var_axes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_var_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, int ddof, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_var_axes$address() {
        return mlx_var_axes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_var_axes(mlx_array *res, const mlx_array a, const int *axes, size_t axes_num, bool keepdims, int ddof, const mlx_stream s)
     * }
     */
    public static int mlx_var_axes(MemorySegment res, MemorySegment a, MemorySegment axes, long axes_num, boolean keepdims, int ddof, MemorySegment s) {
        var mh$ = mlx_var_axes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_var_axes", res, a, axes, axes_num, keepdims, ddof, s);
            }
            return (int)mh$.invokeExact(res, a, axes, axes_num, keepdims, ddof, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_var_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_BOOL,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_var_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_var_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, int ddof, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_var_axis$descriptor() {
        return mlx_var_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_var_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, int ddof, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_var_axis$handle() {
        return mlx_var_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_var_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, int ddof, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_var_axis$address() {
        return mlx_var_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_var_axis(mlx_array *res, const mlx_array a, int axis, bool keepdims, int ddof, const mlx_stream s)
     * }
     */
    public static int mlx_var_axis(MemorySegment res, MemorySegment a, int axis, boolean keepdims, int ddof, MemorySegment s) {
        var mh$ = mlx_var_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_var_axis", res, a, axis, keepdims, ddof, s);
            }
            return (int)mh$.invokeExact(res, a, axis, keepdims, ddof, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_var {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_BOOL,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_var");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_var(mlx_array *res, const mlx_array a, bool keepdims, int ddof, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_var$descriptor() {
        return mlx_var.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_var(mlx_array *res, const mlx_array a, bool keepdims, int ddof, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_var$handle() {
        return mlx_var.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_var(mlx_array *res, const mlx_array a, bool keepdims, int ddof, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_var$address() {
        return mlx_var.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_var(mlx_array *res, const mlx_array a, bool keepdims, int ddof, const mlx_stream s)
     * }
     */
    public static int mlx_var(MemorySegment res, MemorySegment a, boolean keepdims, int ddof, MemorySegment s) {
        var mh$ = mlx_var.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_var", res, a, keepdims, ddof, s);
            }
            return (int)mh$.invokeExact(res, a, keepdims, ddof, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_view {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_view");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_view(mlx_array *res, const mlx_array a, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_view$descriptor() {
        return mlx_view.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_view(mlx_array *res, const mlx_array a, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_view$handle() {
        return mlx_view.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_view(mlx_array *res, const mlx_array a, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_view$address() {
        return mlx_view.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_view(mlx_array *res, const mlx_array a, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static int mlx_view(MemorySegment res, MemorySegment a, int dtype, MemorySegment s) {
        var mh$ = mlx_view.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_view", res, a, dtype, s);
            }
            return (int)mh$.invokeExact(res, a, dtype, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_where {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_where");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_where(mlx_array *res, const mlx_array condition, const mlx_array x, const mlx_array y, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_where$descriptor() {
        return mlx_where.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_where(mlx_array *res, const mlx_array condition, const mlx_array x, const mlx_array y, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_where$handle() {
        return mlx_where.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_where(mlx_array *res, const mlx_array condition, const mlx_array x, const mlx_array y, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_where$address() {
        return mlx_where.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_where(mlx_array *res, const mlx_array condition, const mlx_array x, const mlx_array y, const mlx_stream s)
     * }
     */
    public static int mlx_where(MemorySegment res, MemorySegment condition, MemorySegment x, MemorySegment y, MemorySegment s) {
        var mh$ = mlx_where.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_where", res, condition, x, y, s);
            }
            return (int)mh$.invokeExact(res, condition, x, y, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_zeros {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_zeros");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_zeros(mlx_array *res, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_zeros$descriptor() {
        return mlx_zeros.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_zeros(mlx_array *res, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_zeros$handle() {
        return mlx_zeros.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_zeros(mlx_array *res, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_zeros$address() {
        return mlx_zeros.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_zeros(mlx_array *res, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_stream s)
     * }
     */
    public static int mlx_zeros(MemorySegment res, MemorySegment shape, long shape_num, int dtype, MemorySegment s) {
        var mh$ = mlx_zeros.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_zeros", res, shape, shape_num, dtype, s);
            }
            return (int)mh$.invokeExact(res, shape, shape_num, dtype, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_zeros_like {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_zeros_like");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_zeros_like(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_zeros_like$descriptor() {
        return mlx_zeros_like.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_zeros_like(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_zeros_like$handle() {
        return mlx_zeros_like.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_zeros_like(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_zeros_like$address() {
        return mlx_zeros_like.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_zeros_like(mlx_array *res, const mlx_array a, const mlx_stream s)
     * }
     */
    public static int mlx_zeros_like(MemorySegment res, MemorySegment a, MemorySegment s) {
        var mh$ = mlx_zeros_like.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_zeros_like", res, a, s);
            }
            return (int)mh$.invokeExact(res, a, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_random_bernoulli {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_random_bernoulli");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_random_bernoulli(mlx_array *res, const mlx_array p, const int *shape, size_t shape_num, const mlx_array key, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_random_bernoulli$descriptor() {
        return mlx_random_bernoulli.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_random_bernoulli(mlx_array *res, const mlx_array p, const int *shape, size_t shape_num, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_random_bernoulli$handle() {
        return mlx_random_bernoulli.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_random_bernoulli(mlx_array *res, const mlx_array p, const int *shape, size_t shape_num, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_random_bernoulli$address() {
        return mlx_random_bernoulli.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_random_bernoulli(mlx_array *res, const mlx_array p, const int *shape, size_t shape_num, const mlx_array key, const mlx_stream s)
     * }
     */
    public static int mlx_random_bernoulli(MemorySegment res, MemorySegment p, MemorySegment shape, long shape_num, MemorySegment key, MemorySegment s) {
        var mh$ = mlx_random_bernoulli.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_random_bernoulli", res, p, shape, shape_num, key, s);
            }
            return (int)mh$.invokeExact(res, p, shape, shape_num, key, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_random_bits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_INT,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_random_bits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_random_bits(mlx_array *res, const int *shape, size_t shape_num, int width, const mlx_array key, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_random_bits$descriptor() {
        return mlx_random_bits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_random_bits(mlx_array *res, const int *shape, size_t shape_num, int width, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_random_bits$handle() {
        return mlx_random_bits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_random_bits(mlx_array *res, const int *shape, size_t shape_num, int width, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_random_bits$address() {
        return mlx_random_bits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_random_bits(mlx_array *res, const int *shape, size_t shape_num, int width, const mlx_array key, const mlx_stream s)
     * }
     */
    public static int mlx_random_bits(MemorySegment res, MemorySegment shape, long shape_num, int width, MemorySegment key, MemorySegment s) {
        var mh$ = mlx_random_bits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_random_bits", res, shape, shape_num, width, key, s);
            }
            return (int)mh$.invokeExact(res, shape, shape_num, width, key, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_random_categorical_shape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_random_categorical_shape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_random_categorical_shape(mlx_array *res, const mlx_array logits, int axis, const int *shape, size_t shape_num, const mlx_array key, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_random_categorical_shape$descriptor() {
        return mlx_random_categorical_shape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_random_categorical_shape(mlx_array *res, const mlx_array logits, int axis, const int *shape, size_t shape_num, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_random_categorical_shape$handle() {
        return mlx_random_categorical_shape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_random_categorical_shape(mlx_array *res, const mlx_array logits, int axis, const int *shape, size_t shape_num, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_random_categorical_shape$address() {
        return mlx_random_categorical_shape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_random_categorical_shape(mlx_array *res, const mlx_array logits, int axis, const int *shape, size_t shape_num, const mlx_array key, const mlx_stream s)
     * }
     */
    public static int mlx_random_categorical_shape(MemorySegment res, MemorySegment logits, int axis, MemorySegment shape, long shape_num, MemorySegment key, MemorySegment s) {
        var mh$ = mlx_random_categorical_shape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_random_categorical_shape", res, logits, axis, shape, shape_num, key, s);
            }
            return (int)mh$.invokeExact(res, logits, axis, shape, shape_num, key, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_random_categorical_num_samples {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_h.C_INT,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_random_categorical_num_samples");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_random_categorical_num_samples(mlx_array *res, const mlx_array logits_, int axis, int num_samples, const mlx_array key, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_random_categorical_num_samples$descriptor() {
        return mlx_random_categorical_num_samples.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_random_categorical_num_samples(mlx_array *res, const mlx_array logits_, int axis, int num_samples, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_random_categorical_num_samples$handle() {
        return mlx_random_categorical_num_samples.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_random_categorical_num_samples(mlx_array *res, const mlx_array logits_, int axis, int num_samples, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_random_categorical_num_samples$address() {
        return mlx_random_categorical_num_samples.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_random_categorical_num_samples(mlx_array *res, const mlx_array logits_, int axis, int num_samples, const mlx_array key, const mlx_stream s)
     * }
     */
    public static int mlx_random_categorical_num_samples(MemorySegment res, MemorySegment logits_, int axis, int num_samples, MemorySegment key, MemorySegment s) {
        var mh$ = mlx_random_categorical_num_samples.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_random_categorical_num_samples", res, logits_, axis, num_samples, key, s);
            }
            return (int)mh$.invokeExact(res, logits_, axis, num_samples, key, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_random_categorical {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_random_categorical");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_random_categorical(mlx_array *res, const mlx_array logits, int axis, const mlx_array key, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_random_categorical$descriptor() {
        return mlx_random_categorical.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_random_categorical(mlx_array *res, const mlx_array logits, int axis, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_random_categorical$handle() {
        return mlx_random_categorical.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_random_categorical(mlx_array *res, const mlx_array logits, int axis, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_random_categorical$address() {
        return mlx_random_categorical.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_random_categorical(mlx_array *res, const mlx_array logits, int axis, const mlx_array key, const mlx_stream s)
     * }
     */
    public static int mlx_random_categorical(MemorySegment res, MemorySegment logits, int axis, MemorySegment key, MemorySegment s) {
        var mh$ = mlx_random_categorical.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_random_categorical", res, logits, axis, key, s);
            }
            return (int)mh$.invokeExact(res, logits, axis, key, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_random_gumbel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_INT,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_random_gumbel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_random_gumbel(mlx_array *res, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_array key, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_random_gumbel$descriptor() {
        return mlx_random_gumbel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_random_gumbel(mlx_array *res, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_random_gumbel$handle() {
        return mlx_random_gumbel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_random_gumbel(mlx_array *res, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_random_gumbel$address() {
        return mlx_random_gumbel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_random_gumbel(mlx_array *res, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_array key, const mlx_stream s)
     * }
     */
    public static int mlx_random_gumbel(MemorySegment res, MemorySegment shape, long shape_num, int dtype, MemorySegment key, MemorySegment s) {
        var mh$ = mlx_random_gumbel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_random_gumbel", res, shape, shape_num, dtype, key, s);
            }
            return (int)mh$.invokeExact(res, shape, shape_num, dtype, key, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_random_key {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_random_key");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_random_key(mlx_array *res, uint64_t seed)
     * }
     */
    public static FunctionDescriptor mlx_random_key$descriptor() {
        return mlx_random_key.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_random_key(mlx_array *res, uint64_t seed)
     * }
     */
    public static MethodHandle mlx_random_key$handle() {
        return mlx_random_key.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_random_key(mlx_array *res, uint64_t seed)
     * }
     */
    public static MemorySegment mlx_random_key$address() {
        return mlx_random_key.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_random_key(mlx_array *res, uint64_t seed)
     * }
     */
    public static int mlx_random_key(MemorySegment res, long seed) {
        var mh$ = mlx_random_key.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_random_key", res, seed);
            }
            return (int)mh$.invokeExact(res, seed);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_random_laplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_INT,
            mlx_h.C_FLOAT,
            mlx_h.C_FLOAT,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_random_laplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_random_laplace(mlx_array *res, const int *shape, size_t shape_num, mlx_dtype dtype, float loc, float scale, const mlx_array key, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_random_laplace$descriptor() {
        return mlx_random_laplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_random_laplace(mlx_array *res, const int *shape, size_t shape_num, mlx_dtype dtype, float loc, float scale, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_random_laplace$handle() {
        return mlx_random_laplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_random_laplace(mlx_array *res, const int *shape, size_t shape_num, mlx_dtype dtype, float loc, float scale, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_random_laplace$address() {
        return mlx_random_laplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_random_laplace(mlx_array *res, const int *shape, size_t shape_num, mlx_dtype dtype, float loc, float scale, const mlx_array key, const mlx_stream s)
     * }
     */
    public static int mlx_random_laplace(MemorySegment res, MemorySegment shape, long shape_num, int dtype, float loc, float scale, MemorySegment key, MemorySegment s) {
        var mh$ = mlx_random_laplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_random_laplace", res, shape, shape_num, dtype, loc, scale, key, s);
            }
            return (int)mh$.invokeExact(res, shape, shape_num, dtype, loc, scale, key, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_random_multivariate_normal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_INT,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_random_multivariate_normal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_random_multivariate_normal(mlx_array *res, const mlx_array mean, const mlx_array cov, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_array key, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_random_multivariate_normal$descriptor() {
        return mlx_random_multivariate_normal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_random_multivariate_normal(mlx_array *res, const mlx_array mean, const mlx_array cov, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_random_multivariate_normal$handle() {
        return mlx_random_multivariate_normal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_random_multivariate_normal(mlx_array *res, const mlx_array mean, const mlx_array cov, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_random_multivariate_normal$address() {
        return mlx_random_multivariate_normal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_random_multivariate_normal(mlx_array *res, const mlx_array mean, const mlx_array cov, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_array key, const mlx_stream s)
     * }
     */
    public static int mlx_random_multivariate_normal(MemorySegment res, MemorySegment mean, MemorySegment cov, MemorySegment shape, long shape_num, int dtype, MemorySegment key, MemorySegment s) {
        var mh$ = mlx_random_multivariate_normal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_random_multivariate_normal", res, mean, cov, shape, shape_num, dtype, key, s);
            }
            return (int)mh$.invokeExact(res, mean, cov, shape, shape_num, dtype, key, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_random_normal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_INT,
            mlx_h.C_FLOAT,
            mlx_h.C_FLOAT,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_random_normal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_random_normal(mlx_array *res, const int *shape, size_t shape_num, mlx_dtype dtype, float loc, float scale, const mlx_array key, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_random_normal$descriptor() {
        return mlx_random_normal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_random_normal(mlx_array *res, const int *shape, size_t shape_num, mlx_dtype dtype, float loc, float scale, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_random_normal$handle() {
        return mlx_random_normal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_random_normal(mlx_array *res, const int *shape, size_t shape_num, mlx_dtype dtype, float loc, float scale, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_random_normal$address() {
        return mlx_random_normal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_random_normal(mlx_array *res, const int *shape, size_t shape_num, mlx_dtype dtype, float loc, float scale, const mlx_array key, const mlx_stream s)
     * }
     */
    public static int mlx_random_normal(MemorySegment res, MemorySegment shape, long shape_num, int dtype, float loc, float scale, MemorySegment key, MemorySegment s) {
        var mh$ = mlx_random_normal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_random_normal", res, shape, shape_num, dtype, loc, scale, key, s);
            }
            return (int)mh$.invokeExact(res, shape, shape_num, dtype, loc, scale, key, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_random_permutation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_random_permutation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_random_permutation(mlx_array *res, const mlx_array x, int axis, const mlx_array key, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_random_permutation$descriptor() {
        return mlx_random_permutation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_random_permutation(mlx_array *res, const mlx_array x, int axis, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_random_permutation$handle() {
        return mlx_random_permutation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_random_permutation(mlx_array *res, const mlx_array x, int axis, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_random_permutation$address() {
        return mlx_random_permutation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_random_permutation(mlx_array *res, const mlx_array x, int axis, const mlx_array key, const mlx_stream s)
     * }
     */
    public static int mlx_random_permutation(MemorySegment res, MemorySegment x, int axis, MemorySegment key, MemorySegment s) {
        var mh$ = mlx_random_permutation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_random_permutation", res, x, axis, key, s);
            }
            return (int)mh$.invokeExact(res, x, axis, key, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_random_permutation_arange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_INT,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_random_permutation_arange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_random_permutation_arange(mlx_array *res, int x, const mlx_array key, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_random_permutation_arange$descriptor() {
        return mlx_random_permutation_arange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_random_permutation_arange(mlx_array *res, int x, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_random_permutation_arange$handle() {
        return mlx_random_permutation_arange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_random_permutation_arange(mlx_array *res, int x, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_random_permutation_arange$address() {
        return mlx_random_permutation_arange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_random_permutation_arange(mlx_array *res, int x, const mlx_array key, const mlx_stream s)
     * }
     */
    public static int mlx_random_permutation_arange(MemorySegment res, int x, MemorySegment key, MemorySegment s) {
        var mh$ = mlx_random_permutation_arange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_random_permutation_arange", res, x, key, s);
            }
            return (int)mh$.invokeExact(res, x, key, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_random_randint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_INT,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_random_randint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_random_randint(mlx_array *res, const mlx_array low, const mlx_array high, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_array key, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_random_randint$descriptor() {
        return mlx_random_randint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_random_randint(mlx_array *res, const mlx_array low, const mlx_array high, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_random_randint$handle() {
        return mlx_random_randint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_random_randint(mlx_array *res, const mlx_array low, const mlx_array high, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_random_randint$address() {
        return mlx_random_randint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_random_randint(mlx_array *res, const mlx_array low, const mlx_array high, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_array key, const mlx_stream s)
     * }
     */
    public static int mlx_random_randint(MemorySegment res, MemorySegment low, MemorySegment high, MemorySegment shape, long shape_num, int dtype, MemorySegment key, MemorySegment s) {
        var mh$ = mlx_random_randint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_random_randint", res, low, high, shape, shape_num, dtype, key, s);
            }
            return (int)mh$.invokeExact(res, low, high, shape, shape_num, dtype, key, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_random_seed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_random_seed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_random_seed(uint64_t seed)
     * }
     */
    public static FunctionDescriptor mlx_random_seed$descriptor() {
        return mlx_random_seed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_random_seed(uint64_t seed)
     * }
     */
    public static MethodHandle mlx_random_seed$handle() {
        return mlx_random_seed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_random_seed(uint64_t seed)
     * }
     */
    public static MemorySegment mlx_random_seed$address() {
        return mlx_random_seed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_random_seed(uint64_t seed)
     * }
     */
    public static int mlx_random_seed(long seed) {
        var mh$ = mlx_random_seed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_random_seed", seed);
            }
            return (int)mh$.invokeExact(seed);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_random_split_num {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_h.C_INT,
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_random_split_num");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_random_split_num(mlx_array *res, const mlx_array key, int num, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_random_split_num$descriptor() {
        return mlx_random_split_num.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_random_split_num(mlx_array *res, const mlx_array key, int num, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_random_split_num$handle() {
        return mlx_random_split_num.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_random_split_num(mlx_array *res, const mlx_array key, int num, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_random_split_num$address() {
        return mlx_random_split_num.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_random_split_num(mlx_array *res, const mlx_array key, int num, const mlx_stream s)
     * }
     */
    public static int mlx_random_split_num(MemorySegment res, MemorySegment key, int num, MemorySegment s) {
        var mh$ = mlx_random_split_num.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_random_split_num", res, key, num, s);
            }
            return (int)mh$.invokeExact(res, key, num, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_random_split {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_random_split");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_random_split(mlx_array *res_0, mlx_array *res_1, const mlx_array key, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_random_split$descriptor() {
        return mlx_random_split.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_random_split(mlx_array *res_0, mlx_array *res_1, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_random_split$handle() {
        return mlx_random_split.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_random_split(mlx_array *res_0, mlx_array *res_1, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_random_split$address() {
        return mlx_random_split.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_random_split(mlx_array *res_0, mlx_array *res_1, const mlx_array key, const mlx_stream s)
     * }
     */
    public static int mlx_random_split(MemorySegment res_0, MemorySegment res_1, MemorySegment key, MemorySegment s) {
        var mh$ = mlx_random_split.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_random_split", res_0, res_1, key, s);
            }
            return (int)mh$.invokeExact(res_0, res_1, key, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_random_truncated_normal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_INT,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_random_truncated_normal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_random_truncated_normal(mlx_array *res, const mlx_array lower, const mlx_array upper, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_array key, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_random_truncated_normal$descriptor() {
        return mlx_random_truncated_normal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_random_truncated_normal(mlx_array *res, const mlx_array lower, const mlx_array upper, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_random_truncated_normal$handle() {
        return mlx_random_truncated_normal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_random_truncated_normal(mlx_array *res, const mlx_array lower, const mlx_array upper, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_random_truncated_normal$address() {
        return mlx_random_truncated_normal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_random_truncated_normal(mlx_array *res, const mlx_array lower, const mlx_array upper, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_array key, const mlx_stream s)
     * }
     */
    public static int mlx_random_truncated_normal(MemorySegment res, MemorySegment lower, MemorySegment upper, MemorySegment shape, long shape_num, int dtype, MemorySegment key, MemorySegment s) {
        var mh$ = mlx_random_truncated_normal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_random_truncated_normal", res, lower, upper, shape, shape_num, dtype, key, s);
            }
            return (int)mh$.invokeExact(res, lower, upper, shape, shape_num, dtype, key, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_random_uniform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_array_.layout(),
            mlx_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_INT,
            mlx_array_.layout(),
            mlx_stream_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_random_uniform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_random_uniform(mlx_array *res, const mlx_array low, const mlx_array high, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_array key, const mlx_stream s)
     * }
     */
    public static FunctionDescriptor mlx_random_uniform$descriptor() {
        return mlx_random_uniform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_random_uniform(mlx_array *res, const mlx_array low, const mlx_array high, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MethodHandle mlx_random_uniform$handle() {
        return mlx_random_uniform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_random_uniform(mlx_array *res, const mlx_array low, const mlx_array high, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_array key, const mlx_stream s)
     * }
     */
    public static MemorySegment mlx_random_uniform$address() {
        return mlx_random_uniform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_random_uniform(mlx_array *res, const mlx_array low, const mlx_array high, const int *shape, size_t shape_num, mlx_dtype dtype, const mlx_array key, const mlx_stream s)
     * }
     */
    public static int mlx_random_uniform(MemorySegment res, MemorySegment low, MemorySegment high, MemorySegment shape, long shape_num, int dtype, MemorySegment key, MemorySegment s) {
        var mh$ = mlx_random_uniform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_random_uniform", res, low, high, shape, shape_num, dtype, key, s);
            }
            return (int)mh$.invokeExact(res, low, high, shape, shape_num, dtype, key, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_async_eval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_vector_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_async_eval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_async_eval(const mlx_vector_array outputs)
     * }
     */
    public static FunctionDescriptor mlx_async_eval$descriptor() {
        return mlx_async_eval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_async_eval(const mlx_vector_array outputs)
     * }
     */
    public static MethodHandle mlx_async_eval$handle() {
        return mlx_async_eval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_async_eval(const mlx_vector_array outputs)
     * }
     */
    public static MemorySegment mlx_async_eval$address() {
        return mlx_async_eval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_async_eval(const mlx_vector_array outputs)
     * }
     */
    public static int mlx_async_eval(MemorySegment outputs) {
        var mh$ = mlx_async_eval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_async_eval", outputs);
            }
            return (int)mh$.invokeExact(outputs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_checkpoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_closure_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_checkpoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_checkpoint(mlx_closure *res, const mlx_closure fun)
     * }
     */
    public static FunctionDescriptor mlx_checkpoint$descriptor() {
        return mlx_checkpoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_checkpoint(mlx_closure *res, const mlx_closure fun)
     * }
     */
    public static MethodHandle mlx_checkpoint$handle() {
        return mlx_checkpoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_checkpoint(mlx_closure *res, const mlx_closure fun)
     * }
     */
    public static MemorySegment mlx_checkpoint$address() {
        return mlx_checkpoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_checkpoint(mlx_closure *res, const mlx_closure fun)
     * }
     */
    public static int mlx_checkpoint(MemorySegment res, MemorySegment fun) {
        var mh$ = mlx_checkpoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_checkpoint", res, fun);
            }
            return (int)mh$.invokeExact(res, fun);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_custom_function {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_closure_.layout(),
            mlx_closure_custom_.layout(),
            mlx_closure_custom_jvp_.layout(),
            mlx_closure_custom_vmap_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_custom_function");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_custom_function(mlx_closure *res, const mlx_closure fun, const mlx_closure_custom fun_vjp, const mlx_closure_custom_jvp fun_jvp, const mlx_closure_custom_vmap fun_vmap)
     * }
     */
    public static FunctionDescriptor mlx_custom_function$descriptor() {
        return mlx_custom_function.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_custom_function(mlx_closure *res, const mlx_closure fun, const mlx_closure_custom fun_vjp, const mlx_closure_custom_jvp fun_jvp, const mlx_closure_custom_vmap fun_vmap)
     * }
     */
    public static MethodHandle mlx_custom_function$handle() {
        return mlx_custom_function.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_custom_function(mlx_closure *res, const mlx_closure fun, const mlx_closure_custom fun_vjp, const mlx_closure_custom_jvp fun_jvp, const mlx_closure_custom_vmap fun_vmap)
     * }
     */
    public static MemorySegment mlx_custom_function$address() {
        return mlx_custom_function.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_custom_function(mlx_closure *res, const mlx_closure fun, const mlx_closure_custom fun_vjp, const mlx_closure_custom_jvp fun_jvp, const mlx_closure_custom_vmap fun_vmap)
     * }
     */
    public static int mlx_custom_function(MemorySegment res, MemorySegment fun, MemorySegment fun_vjp, MemorySegment fun_jvp, MemorySegment fun_vmap) {
        var mh$ = mlx_custom_function.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_custom_function", res, fun, fun_vjp, fun_jvp, fun_vmap);
            }
            return (int)mh$.invokeExact(res, fun, fun_vjp, fun_jvp, fun_vmap);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_custom_vjp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_closure_.layout(),
            mlx_closure_custom_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_custom_vjp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_custom_vjp(mlx_closure *res, const mlx_closure fun, const mlx_closure_custom fun_vjp)
     * }
     */
    public static FunctionDescriptor mlx_custom_vjp$descriptor() {
        return mlx_custom_vjp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_custom_vjp(mlx_closure *res, const mlx_closure fun, const mlx_closure_custom fun_vjp)
     * }
     */
    public static MethodHandle mlx_custom_vjp$handle() {
        return mlx_custom_vjp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_custom_vjp(mlx_closure *res, const mlx_closure fun, const mlx_closure_custom fun_vjp)
     * }
     */
    public static MemorySegment mlx_custom_vjp$address() {
        return mlx_custom_vjp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_custom_vjp(mlx_closure *res, const mlx_closure fun, const mlx_closure_custom fun_vjp)
     * }
     */
    public static int mlx_custom_vjp(MemorySegment res, MemorySegment fun, MemorySegment fun_vjp) {
        var mh$ = mlx_custom_vjp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_custom_vjp", res, fun, fun_vjp);
            }
            return (int)mh$.invokeExact(res, fun, fun_vjp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_eval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_vector_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_eval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_eval(const mlx_vector_array outputs)
     * }
     */
    public static FunctionDescriptor mlx_eval$descriptor() {
        return mlx_eval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_eval(const mlx_vector_array outputs)
     * }
     */
    public static MethodHandle mlx_eval$handle() {
        return mlx_eval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_eval(const mlx_vector_array outputs)
     * }
     */
    public static MemorySegment mlx_eval$address() {
        return mlx_eval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_eval(const mlx_vector_array outputs)
     * }
     */
    public static int mlx_eval(MemorySegment outputs) {
        var mh$ = mlx_eval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_eval", outputs);
            }
            return (int)mh$.invokeExact(outputs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_jvp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_closure_.layout(),
            mlx_vector_array_.layout(),
            mlx_vector_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_jvp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_jvp(mlx_vector_array *res_0, mlx_vector_array *res_1, const mlx_closure fun, const mlx_vector_array primals, const mlx_vector_array tangents)
     * }
     */
    public static FunctionDescriptor mlx_jvp$descriptor() {
        return mlx_jvp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_jvp(mlx_vector_array *res_0, mlx_vector_array *res_1, const mlx_closure fun, const mlx_vector_array primals, const mlx_vector_array tangents)
     * }
     */
    public static MethodHandle mlx_jvp$handle() {
        return mlx_jvp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_jvp(mlx_vector_array *res_0, mlx_vector_array *res_1, const mlx_closure fun, const mlx_vector_array primals, const mlx_vector_array tangents)
     * }
     */
    public static MemorySegment mlx_jvp$address() {
        return mlx_jvp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_jvp(mlx_vector_array *res_0, mlx_vector_array *res_1, const mlx_closure fun, const mlx_vector_array primals, const mlx_vector_array tangents)
     * }
     */
    public static int mlx_jvp(MemorySegment res_0, MemorySegment res_1, MemorySegment fun, MemorySegment primals, MemorySegment tangents) {
        var mh$ = mlx_jvp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_jvp", res_0, res_1, fun, primals, tangents);
            }
            return (int)mh$.invokeExact(res_0, res_1, fun, primals, tangents);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_value_and_grad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_closure_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_value_and_grad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_value_and_grad(mlx_closure_value_and_grad *res, const mlx_closure fun, const int *argnums, size_t argnums_num)
     * }
     */
    public static FunctionDescriptor mlx_value_and_grad$descriptor() {
        return mlx_value_and_grad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_value_and_grad(mlx_closure_value_and_grad *res, const mlx_closure fun, const int *argnums, size_t argnums_num)
     * }
     */
    public static MethodHandle mlx_value_and_grad$handle() {
        return mlx_value_and_grad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_value_and_grad(mlx_closure_value_and_grad *res, const mlx_closure fun, const int *argnums, size_t argnums_num)
     * }
     */
    public static MemorySegment mlx_value_and_grad$address() {
        return mlx_value_and_grad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_value_and_grad(mlx_closure_value_and_grad *res, const mlx_closure fun, const int *argnums, size_t argnums_num)
     * }
     */
    public static int mlx_value_and_grad(MemorySegment res, MemorySegment fun, MemorySegment argnums, long argnums_num) {
        var mh$ = mlx_value_and_grad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_value_and_grad", res, fun, argnums, argnums_num);
            }
            return (int)mh$.invokeExact(res, fun, argnums, argnums_num);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_vjp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_closure_.layout(),
            mlx_vector_array_.layout(),
            mlx_vector_array_.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_vjp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_vjp(mlx_vector_array *res_0, mlx_vector_array *res_1, const mlx_closure fun, const mlx_vector_array primals, const mlx_vector_array cotangents)
     * }
     */
    public static FunctionDescriptor mlx_vjp$descriptor() {
        return mlx_vjp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_vjp(mlx_vector_array *res_0, mlx_vector_array *res_1, const mlx_closure fun, const mlx_vector_array primals, const mlx_vector_array cotangents)
     * }
     */
    public static MethodHandle mlx_vjp$handle() {
        return mlx_vjp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_vjp(mlx_vector_array *res_0, mlx_vector_array *res_1, const mlx_closure fun, const mlx_vector_array primals, const mlx_vector_array cotangents)
     * }
     */
    public static MemorySegment mlx_vjp$address() {
        return mlx_vjp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_vjp(mlx_vector_array *res_0, mlx_vector_array *res_1, const mlx_closure fun, const mlx_vector_array primals, const mlx_vector_array cotangents)
     * }
     */
    public static int mlx_vjp(MemorySegment res_0, MemorySegment res_1, MemorySegment fun, MemorySegment primals, MemorySegment cotangents) {
        var mh$ = mlx_vjp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_vjp", res_0, res_1, fun, primals, cotangents);
            }
            return (int)mh$.invokeExact(res_0, res_1, fun, primals, cotangents);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_detail_vmap_replace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_vector_array_.layout(),
            mlx_vector_array_.layout(),
            mlx_vector_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG,
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_detail_vmap_replace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_detail_vmap_replace(mlx_vector_array *res, const mlx_vector_array inputs, const mlx_vector_array s_inputs, const mlx_vector_array s_outputs, const int *in_axes, size_t in_axes_num, const int *out_axes, size_t out_axes_num)
     * }
     */
    public static FunctionDescriptor mlx_detail_vmap_replace$descriptor() {
        return mlx_detail_vmap_replace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_detail_vmap_replace(mlx_vector_array *res, const mlx_vector_array inputs, const mlx_vector_array s_inputs, const mlx_vector_array s_outputs, const int *in_axes, size_t in_axes_num, const int *out_axes, size_t out_axes_num)
     * }
     */
    public static MethodHandle mlx_detail_vmap_replace$handle() {
        return mlx_detail_vmap_replace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_detail_vmap_replace(mlx_vector_array *res, const mlx_vector_array inputs, const mlx_vector_array s_inputs, const mlx_vector_array s_outputs, const int *in_axes, size_t in_axes_num, const int *out_axes, size_t out_axes_num)
     * }
     */
    public static MemorySegment mlx_detail_vmap_replace$address() {
        return mlx_detail_vmap_replace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_detail_vmap_replace(mlx_vector_array *res, const mlx_vector_array inputs, const mlx_vector_array s_inputs, const mlx_vector_array s_outputs, const int *in_axes, size_t in_axes_num, const int *out_axes, size_t out_axes_num)
     * }
     */
    public static int mlx_detail_vmap_replace(MemorySegment res, MemorySegment inputs, MemorySegment s_inputs, MemorySegment s_outputs, MemorySegment in_axes, long in_axes_num, MemorySegment out_axes, long out_axes_num) {
        var mh$ = mlx_detail_vmap_replace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_detail_vmap_replace", res, inputs, s_inputs, s_outputs, in_axes, in_axes_num, out_axes, out_axes_num);
            }
            return (int)mh$.invokeExact(res, inputs, s_inputs, s_outputs, in_axes, in_axes_num, out_axes, out_axes_num);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_detail_vmap_trace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER,
            mlx_h.C_POINTER,
            mlx_closure_.layout(),
            mlx_vector_array_.layout(),
            mlx_h.C_POINTER,
            mlx_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_detail_vmap_trace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_detail_vmap_trace(mlx_vector_array *res_0, mlx_vector_array *res_1, const mlx_closure fun, const mlx_vector_array inputs, const int *in_axes, size_t in_axes_num)
     * }
     */
    public static FunctionDescriptor mlx_detail_vmap_trace$descriptor() {
        return mlx_detail_vmap_trace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_detail_vmap_trace(mlx_vector_array *res_0, mlx_vector_array *res_1, const mlx_closure fun, const mlx_vector_array inputs, const int *in_axes, size_t in_axes_num)
     * }
     */
    public static MethodHandle mlx_detail_vmap_trace$handle() {
        return mlx_detail_vmap_trace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_detail_vmap_trace(mlx_vector_array *res_0, mlx_vector_array *res_1, const mlx_closure fun, const mlx_vector_array inputs, const int *in_axes, size_t in_axes_num)
     * }
     */
    public static MemorySegment mlx_detail_vmap_trace$address() {
        return mlx_detail_vmap_trace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_detail_vmap_trace(mlx_vector_array *res_0, mlx_vector_array *res_1, const mlx_closure fun, const mlx_vector_array inputs, const int *in_axes, size_t in_axes_num)
     * }
     */
    public static int mlx_detail_vmap_trace(MemorySegment res_0, MemorySegment res_1, MemorySegment fun, MemorySegment inputs, MemorySegment in_axes, long in_axes_num) {
        var mh$ = mlx_detail_vmap_trace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_detail_vmap_trace", res_0, res_1, fun, inputs, in_axes, in_axes_num);
            }
            return (int)mh$.invokeExact(res_0, res_1, fun, inputs, in_axes, in_axes_num);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mlx_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mlx_h.C_INT,
            mlx_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mlx_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mlx_version(mlx_string *str_)
     * }
     */
    public static FunctionDescriptor mlx_version$descriptor() {
        return mlx_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mlx_version(mlx_string *str_)
     * }
     */
    public static MethodHandle mlx_version$handle() {
        return mlx_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mlx_version(mlx_string *str_)
     * }
     */
    public static MemorySegment mlx_version$address() {
        return mlx_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mlx_version(mlx_string *str_)
     * }
     */
    public static int mlx_version(MemorySegment str_) {
        var mh$ = mlx_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mlx_version", str_);
            }
            return (int)mh$.invokeExact(str_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int FLT_EVAL_METHOD = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FLT_EVAL_METHOD 0
     * }
     */
    public static int FLT_EVAL_METHOD() {
        return FLT_EVAL_METHOD;
    }
    private static final int FLT_RADIX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FLT_RADIX 2
     * }
     */
    public static int FLT_RADIX() {
        return FLT_RADIX;
    }
    private static final int FLT_MANT_DIG = (int)24L;
    /**
     * {@snippet lang=c :
     * #define FLT_MANT_DIG 24
     * }
     */
    public static int FLT_MANT_DIG() {
        return FLT_MANT_DIG;
    }
    private static final int DBL_MANT_DIG = (int)53L;
    /**
     * {@snippet lang=c :
     * #define DBL_MANT_DIG 53
     * }
     */
    public static int DBL_MANT_DIG() {
        return DBL_MANT_DIG;
    }
    private static final int LDBL_MANT_DIG = (int)53L;
    /**
     * {@snippet lang=c :
     * #define LDBL_MANT_DIG 53
     * }
     */
    public static int LDBL_MANT_DIG() {
        return LDBL_MANT_DIG;
    }
    private static final int FLT_DIG = (int)6L;
    /**
     * {@snippet lang=c :
     * #define FLT_DIG 6
     * }
     */
    public static int FLT_DIG() {
        return FLT_DIG;
    }
    private static final int DBL_DIG = (int)15L;
    /**
     * {@snippet lang=c :
     * #define DBL_DIG 15
     * }
     */
    public static int DBL_DIG() {
        return DBL_DIG;
    }
    private static final int LDBL_DIG = (int)15L;
    /**
     * {@snippet lang=c :
     * #define LDBL_DIG 15
     * }
     */
    public static int LDBL_DIG() {
        return LDBL_DIG;
    }
    private static final int FLT_MIN_EXP = (int)-125L;
    /**
     * {@snippet lang=c :
     * #define FLT_MIN_EXP -125
     * }
     */
    public static int FLT_MIN_EXP() {
        return FLT_MIN_EXP;
    }
    private static final int DBL_MIN_EXP = (int)-1021L;
    /**
     * {@snippet lang=c :
     * #define DBL_MIN_EXP -1021
     * }
     */
    public static int DBL_MIN_EXP() {
        return DBL_MIN_EXP;
    }
    private static final int LDBL_MIN_EXP = (int)-1021L;
    /**
     * {@snippet lang=c :
     * #define LDBL_MIN_EXP -1021
     * }
     */
    public static int LDBL_MIN_EXP() {
        return LDBL_MIN_EXP;
    }
    private static final int FLT_MIN_10_EXP = (int)-37L;
    /**
     * {@snippet lang=c :
     * #define FLT_MIN_10_EXP -37
     * }
     */
    public static int FLT_MIN_10_EXP() {
        return FLT_MIN_10_EXP;
    }
    private static final int DBL_MIN_10_EXP = (int)-307L;
    /**
     * {@snippet lang=c :
     * #define DBL_MIN_10_EXP -307
     * }
     */
    public static int DBL_MIN_10_EXP() {
        return DBL_MIN_10_EXP;
    }
    private static final int LDBL_MIN_10_EXP = (int)-307L;
    /**
     * {@snippet lang=c :
     * #define LDBL_MIN_10_EXP -307
     * }
     */
    public static int LDBL_MIN_10_EXP() {
        return LDBL_MIN_10_EXP;
    }
    private static final int FLT_MAX_EXP = (int)128L;
    /**
     * {@snippet lang=c :
     * #define FLT_MAX_EXP 128
     * }
     */
    public static int FLT_MAX_EXP() {
        return FLT_MAX_EXP;
    }
    private static final int DBL_MAX_EXP = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define DBL_MAX_EXP 1024
     * }
     */
    public static int DBL_MAX_EXP() {
        return DBL_MAX_EXP;
    }
    private static final int LDBL_MAX_EXP = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define LDBL_MAX_EXP 1024
     * }
     */
    public static int LDBL_MAX_EXP() {
        return LDBL_MAX_EXP;
    }
    private static final int FLT_MAX_10_EXP = (int)38L;
    /**
     * {@snippet lang=c :
     * #define FLT_MAX_10_EXP 38
     * }
     */
    public static int FLT_MAX_10_EXP() {
        return FLT_MAX_10_EXP;
    }
    private static final int DBL_MAX_10_EXP = (int)308L;
    /**
     * {@snippet lang=c :
     * #define DBL_MAX_10_EXP 308
     * }
     */
    public static int DBL_MAX_10_EXP() {
        return DBL_MAX_10_EXP;
    }
    private static final int LDBL_MAX_10_EXP = (int)308L;
    /**
     * {@snippet lang=c :
     * #define LDBL_MAX_10_EXP 308
     * }
     */
    public static int LDBL_MAX_10_EXP() {
        return LDBL_MAX_10_EXP;
    }
    private static final float FLT_MAX = 3.4028234663852886E38f;
    /**
     * {@snippet lang=c :
     * #define FLT_MAX 3.4028234663852886E38
     * }
     */
    public static float FLT_MAX() {
        return FLT_MAX;
    }
    private static final double DBL_MAX = 1.7976931348623157E308d;
    /**
     * {@snippet lang=c :
     * #define DBL_MAX 1.7976931348623157E308
     * }
     */
    public static double DBL_MAX() {
        return DBL_MAX;
    }
    private static final float FLT_EPSILON = 1.1920928955078125E-7f;
    /**
     * {@snippet lang=c :
     * #define FLT_EPSILON 1.1920928955078125E-7
     * }
     */
    public static float FLT_EPSILON() {
        return FLT_EPSILON;
    }
    private static final double DBL_EPSILON = 2.220446049250313E-16d;
    /**
     * {@snippet lang=c :
     * #define DBL_EPSILON 2.220446049250313E-16
     * }
     */
    public static double DBL_EPSILON() {
        return DBL_EPSILON;
    }
    private static final float FLT_MIN = 1.1754943508222875E-38f;
    /**
     * {@snippet lang=c :
     * #define FLT_MIN 1.1754943508222875E-38
     * }
     */
    public static float FLT_MIN() {
        return FLT_MIN;
    }
    private static final double DBL_MIN = 2.2250738585072014E-308d;
    /**
     * {@snippet lang=c :
     * #define DBL_MIN 2.2250738585072014E-308
     * }
     */
    public static double DBL_MIN() {
        return DBL_MIN;
    }
    private static final int DECIMAL_DIG = (int)17L;
    /**
     * {@snippet lang=c :
     * #define DECIMAL_DIG 17
     * }
     */
    public static int DECIMAL_DIG() {
        return DECIMAL_DIG;
    }
    private static final float FLT_TRUE_MIN = 1.401298464324817E-45f;
    /**
     * {@snippet lang=c :
     * #define FLT_TRUE_MIN 1.401298464324817E-45
     * }
     */
    public static float FLT_TRUE_MIN() {
        return FLT_TRUE_MIN;
    }
    private static final double DBL_TRUE_MIN = 4.9E-324d;
    /**
     * {@snippet lang=c :
     * #define DBL_TRUE_MIN 4.9E-324
     * }
     */
    public static double DBL_TRUE_MIN() {
        return DBL_TRUE_MIN;
    }
    private static final int FLT_DECIMAL_DIG = (int)9L;
    /**
     * {@snippet lang=c :
     * #define FLT_DECIMAL_DIG 9
     * }
     */
    public static int FLT_DECIMAL_DIG() {
        return FLT_DECIMAL_DIG;
    }
    private static final int DBL_DECIMAL_DIG = (int)17L;
    /**
     * {@snippet lang=c :
     * #define DBL_DECIMAL_DIG 17
     * }
     */
    public static int DBL_DECIMAL_DIG() {
        return DBL_DECIMAL_DIG;
    }
    private static final int LDBL_DECIMAL_DIG = (int)17L;
    /**
     * {@snippet lang=c :
     * #define LDBL_DECIMAL_DIG 17
     * }
     */
    public static int LDBL_DECIMAL_DIG() {
        return LDBL_DECIMAL_DIG;
    }
    private static final float INFINITY = Float.valueOf("Infinity");
    /**
     * {@snippet lang=c :
     * #define INFINITY Infinity
     * }
     */
    public static float INFINITY() {
        return INFINITY;
    }
    private static final float NAN = Float.valueOf("NaN");
    /**
     * {@snippet lang=c :
     * #define NAN NaN
     * }
     */
    public static float NAN() {
        return NAN;
    }
    private static final float FLT_NORM_MAX = 3.4028234663852886E38f;
    /**
     * {@snippet lang=c :
     * #define FLT_NORM_MAX 3.4028234663852886E38
     * }
     */
    public static float FLT_NORM_MAX() {
        return FLT_NORM_MAX;
    }
    private static final double DBL_NORM_MAX = 1.7976931348623157E308d;
    /**
     * {@snippet lang=c :
     * #define DBL_NORM_MAX 1.7976931348623157E308
     * }
     */
    public static double DBL_NORM_MAX() {
        return DBL_NORM_MAX;
    }
    /**
     * {@snippet lang=c :
     * #define __DARWIN_SUF_EXTSN "$DARWIN_EXTSN"
     * }
     */
    public static MemorySegment __DARWIN_SUF_EXTSN() {
        class Holder {
            static final MemorySegment __DARWIN_SUF_EXTSN
                = mlx_h.LIBRARY_ARENA.allocateFrom("$DARWIN_EXTSN");
        }
        return Holder.__DARWIN_SUF_EXTSN;
    }
    private static final long __DARWIN_C_ANSI = 4096L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_ANSI 4096
     * }
     */
    public static long __DARWIN_C_ANSI() {
        return __DARWIN_C_ANSI;
    }
    private static final long __DARWIN_C_FULL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_FULL 900000
     * }
     */
    public static long __DARWIN_C_FULL() {
        return __DARWIN_C_FULL;
    }
    private static final long __DARWIN_C_LEVEL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_LEVEL 900000
     * }
     */
    public static long __DARWIN_C_LEVEL() {
        return __DARWIN_C_LEVEL;
    }
    private static final MemorySegment __DARWIN_NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NULL (void*) 0
     * }
     */
    public static MemorySegment __DARWIN_NULL() {
        return __DARWIN_NULL;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final int INT_FAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -32768
     * }
     */
    public static int INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final int INT_FAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -2147483648
     * }
     */
    public static int INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final int INT_FAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 32767
     * }
     */
    public static int INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final int INT_FAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 2147483647
     * }
     */
    public static int INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final int UINT_FAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX 65535
     * }
     */
    public static int UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final int UINT_FAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX 4294967295
     * }
     */
    public static int UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final long RSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RSIZE_MAX 9223372036854775807
     * }
     */
    public static long RSIZE_MAX() {
        return RSIZE_MAX;
    }
    private static final int WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WINT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN -2147483648
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 2147483647
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final int MAC_OS_X_VERSION_10_0 = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_0 1000
     * }
     */
    public static int MAC_OS_X_VERSION_10_0() {
        return MAC_OS_X_VERSION_10_0;
    }
    private static final int MAC_OS_X_VERSION_10_1 = (int)1010L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_1 1010
     * }
     */
    public static int MAC_OS_X_VERSION_10_1() {
        return MAC_OS_X_VERSION_10_1;
    }
    private static final int MAC_OS_X_VERSION_10_2 = (int)1020L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_2 1020
     * }
     */
    public static int MAC_OS_X_VERSION_10_2() {
        return MAC_OS_X_VERSION_10_2;
    }
    private static final int MAC_OS_X_VERSION_10_3 = (int)1030L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_3 1030
     * }
     */
    public static int MAC_OS_X_VERSION_10_3() {
        return MAC_OS_X_VERSION_10_3;
    }
    private static final int MAC_OS_X_VERSION_10_4 = (int)1040L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_4 1040
     * }
     */
    public static int MAC_OS_X_VERSION_10_4() {
        return MAC_OS_X_VERSION_10_4;
    }
    private static final int MAC_OS_X_VERSION_10_5 = (int)1050L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_5 1050
     * }
     */
    public static int MAC_OS_X_VERSION_10_5() {
        return MAC_OS_X_VERSION_10_5;
    }
    private static final int MAC_OS_X_VERSION_10_6 = (int)1060L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_6 1060
     * }
     */
    public static int MAC_OS_X_VERSION_10_6() {
        return MAC_OS_X_VERSION_10_6;
    }
    private static final int MAC_OS_X_VERSION_10_7 = (int)1070L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_7 1070
     * }
     */
    public static int MAC_OS_X_VERSION_10_7() {
        return MAC_OS_X_VERSION_10_7;
    }
    private static final int MAC_OS_X_VERSION_10_8 = (int)1080L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_8 1080
     * }
     */
    public static int MAC_OS_X_VERSION_10_8() {
        return MAC_OS_X_VERSION_10_8;
    }
    private static final int MAC_OS_X_VERSION_10_9 = (int)1090L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_9 1090
     * }
     */
    public static int MAC_OS_X_VERSION_10_9() {
        return MAC_OS_X_VERSION_10_9;
    }
    private static final int MAC_OS_X_VERSION_10_10 = (int)101000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10 101000
     * }
     */
    public static int MAC_OS_X_VERSION_10_10() {
        return MAC_OS_X_VERSION_10_10;
    }
    private static final int MAC_OS_X_VERSION_10_10_2 = (int)101002L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10_2 101002
     * }
     */
    public static int MAC_OS_X_VERSION_10_10_2() {
        return MAC_OS_X_VERSION_10_10_2;
    }
    private static final int MAC_OS_X_VERSION_10_10_3 = (int)101003L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10_3 101003
     * }
     */
    public static int MAC_OS_X_VERSION_10_10_3() {
        return MAC_OS_X_VERSION_10_10_3;
    }
    private static final int MAC_OS_X_VERSION_10_11 = (int)101100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11 101100
     * }
     */
    public static int MAC_OS_X_VERSION_10_11() {
        return MAC_OS_X_VERSION_10_11;
    }
    private static final int MAC_OS_X_VERSION_10_11_2 = (int)101102L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_2 101102
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_2() {
        return MAC_OS_X_VERSION_10_11_2;
    }
    private static final int MAC_OS_X_VERSION_10_11_3 = (int)101103L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_3 101103
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_3() {
        return MAC_OS_X_VERSION_10_11_3;
    }
    private static final int MAC_OS_X_VERSION_10_11_4 = (int)101104L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_4 101104
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_4() {
        return MAC_OS_X_VERSION_10_11_4;
    }
    private static final int MAC_OS_X_VERSION_10_12 = (int)101200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12 101200
     * }
     */
    public static int MAC_OS_X_VERSION_10_12() {
        return MAC_OS_X_VERSION_10_12;
    }
    private static final int MAC_OS_X_VERSION_10_12_1 = (int)101201L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_1 101201
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_1() {
        return MAC_OS_X_VERSION_10_12_1;
    }
    private static final int MAC_OS_X_VERSION_10_12_2 = (int)101202L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_2 101202
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_2() {
        return MAC_OS_X_VERSION_10_12_2;
    }
    private static final int MAC_OS_X_VERSION_10_12_4 = (int)101204L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_4 101204
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_4() {
        return MAC_OS_X_VERSION_10_12_4;
    }
    private static final int MAC_OS_X_VERSION_10_13 = (int)101300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13 101300
     * }
     */
    public static int MAC_OS_X_VERSION_10_13() {
        return MAC_OS_X_VERSION_10_13;
    }
    private static final int MAC_OS_X_VERSION_10_13_1 = (int)101301L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_1 101301
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_1() {
        return MAC_OS_X_VERSION_10_13_1;
    }
    private static final int MAC_OS_X_VERSION_10_13_2 = (int)101302L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_2 101302
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_2() {
        return MAC_OS_X_VERSION_10_13_2;
    }
    private static final int MAC_OS_X_VERSION_10_13_4 = (int)101304L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_4 101304
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_4() {
        return MAC_OS_X_VERSION_10_13_4;
    }
    private static final int MAC_OS_X_VERSION_10_14 = (int)101400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14 101400
     * }
     */
    public static int MAC_OS_X_VERSION_10_14() {
        return MAC_OS_X_VERSION_10_14;
    }
    private static final int MAC_OS_X_VERSION_10_14_1 = (int)101401L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_1 101401
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_1() {
        return MAC_OS_X_VERSION_10_14_1;
    }
    private static final int MAC_OS_X_VERSION_10_14_4 = (int)101404L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_4 101404
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_4() {
        return MAC_OS_X_VERSION_10_14_4;
    }
    private static final int MAC_OS_X_VERSION_10_14_5 = (int)101405L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_5 101405
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_5() {
        return MAC_OS_X_VERSION_10_14_5;
    }
    private static final int MAC_OS_X_VERSION_10_14_6 = (int)101406L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_6 101406
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_6() {
        return MAC_OS_X_VERSION_10_14_6;
    }
    private static final int MAC_OS_X_VERSION_10_15 = (int)101500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15 101500
     * }
     */
    public static int MAC_OS_X_VERSION_10_15() {
        return MAC_OS_X_VERSION_10_15;
    }
    private static final int MAC_OS_X_VERSION_10_15_1 = (int)101501L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15_1 101501
     * }
     */
    public static int MAC_OS_X_VERSION_10_15_1() {
        return MAC_OS_X_VERSION_10_15_1;
    }
    private static final int MAC_OS_X_VERSION_10_15_4 = (int)101504L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15_4 101504
     * }
     */
    public static int MAC_OS_X_VERSION_10_15_4() {
        return MAC_OS_X_VERSION_10_15_4;
    }
    private static final int MAC_OS_X_VERSION_10_16 = (int)101600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_16 101600
     * }
     */
    public static int MAC_OS_X_VERSION_10_16() {
        return MAC_OS_X_VERSION_10_16;
    }
    private static final int MAC_OS_VERSION_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_0 110000
     * }
     */
    public static int MAC_OS_VERSION_11_0() {
        return MAC_OS_VERSION_11_0;
    }
    private static final int MAC_OS_VERSION_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_1 110100
     * }
     */
    public static int MAC_OS_VERSION_11_1() {
        return MAC_OS_VERSION_11_1;
    }
    private static final int MAC_OS_VERSION_11_3 = (int)110300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_3 110300
     * }
     */
    public static int MAC_OS_VERSION_11_3() {
        return MAC_OS_VERSION_11_3;
    }
    private static final int MAC_OS_VERSION_11_4 = (int)110400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_4 110400
     * }
     */
    public static int MAC_OS_VERSION_11_4() {
        return MAC_OS_VERSION_11_4;
    }
    private static final int MAC_OS_VERSION_11_5 = (int)110500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_5 110500
     * }
     */
    public static int MAC_OS_VERSION_11_5() {
        return MAC_OS_VERSION_11_5;
    }
    private static final int MAC_OS_VERSION_11_6 = (int)110600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_6 110600
     * }
     */
    public static int MAC_OS_VERSION_11_6() {
        return MAC_OS_VERSION_11_6;
    }
    private static final int MAC_OS_VERSION_12_0 = (int)120000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_0 120000
     * }
     */
    public static int MAC_OS_VERSION_12_0() {
        return MAC_OS_VERSION_12_0;
    }
    private static final int MAC_OS_VERSION_12_1 = (int)120100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_1 120100
     * }
     */
    public static int MAC_OS_VERSION_12_1() {
        return MAC_OS_VERSION_12_1;
    }
    private static final int MAC_OS_VERSION_12_2 = (int)120200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_2 120200
     * }
     */
    public static int MAC_OS_VERSION_12_2() {
        return MAC_OS_VERSION_12_2;
    }
    private static final int MAC_OS_VERSION_12_3 = (int)120300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_3 120300
     * }
     */
    public static int MAC_OS_VERSION_12_3() {
        return MAC_OS_VERSION_12_3;
    }
    private static final int MAC_OS_VERSION_12_4 = (int)120400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_4 120400
     * }
     */
    public static int MAC_OS_VERSION_12_4() {
        return MAC_OS_VERSION_12_4;
    }
    private static final int MAC_OS_VERSION_12_5 = (int)120500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_5 120500
     * }
     */
    public static int MAC_OS_VERSION_12_5() {
        return MAC_OS_VERSION_12_5;
    }
    private static final int MAC_OS_VERSION_12_6 = (int)120600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_6 120600
     * }
     */
    public static int MAC_OS_VERSION_12_6() {
        return MAC_OS_VERSION_12_6;
    }
    private static final int MAC_OS_VERSION_12_7 = (int)120700L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_7 120700
     * }
     */
    public static int MAC_OS_VERSION_12_7() {
        return MAC_OS_VERSION_12_7;
    }
    private static final int MAC_OS_VERSION_13_0 = (int)130000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_0 130000
     * }
     */
    public static int MAC_OS_VERSION_13_0() {
        return MAC_OS_VERSION_13_0;
    }
    private static final int MAC_OS_VERSION_13_1 = (int)130100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_1 130100
     * }
     */
    public static int MAC_OS_VERSION_13_1() {
        return MAC_OS_VERSION_13_1;
    }
    private static final int MAC_OS_VERSION_13_2 = (int)130200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_2 130200
     * }
     */
    public static int MAC_OS_VERSION_13_2() {
        return MAC_OS_VERSION_13_2;
    }
    private static final int MAC_OS_VERSION_13_3 = (int)130300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_3 130300
     * }
     */
    public static int MAC_OS_VERSION_13_3() {
        return MAC_OS_VERSION_13_3;
    }
    private static final int MAC_OS_VERSION_13_4 = (int)130400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_4 130400
     * }
     */
    public static int MAC_OS_VERSION_13_4() {
        return MAC_OS_VERSION_13_4;
    }
    private static final int MAC_OS_VERSION_13_5 = (int)130500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_5 130500
     * }
     */
    public static int MAC_OS_VERSION_13_5() {
        return MAC_OS_VERSION_13_5;
    }
    private static final int MAC_OS_VERSION_13_6 = (int)130600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_6 130600
     * }
     */
    public static int MAC_OS_VERSION_13_6() {
        return MAC_OS_VERSION_13_6;
    }
    private static final int MAC_OS_VERSION_13_7 = (int)130700L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_7 130700
     * }
     */
    public static int MAC_OS_VERSION_13_7() {
        return MAC_OS_VERSION_13_7;
    }
    private static final int MAC_OS_VERSION_14_0 = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_0 140000
     * }
     */
    public static int MAC_OS_VERSION_14_0() {
        return MAC_OS_VERSION_14_0;
    }
    private static final int MAC_OS_VERSION_14_1 = (int)140100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_1 140100
     * }
     */
    public static int MAC_OS_VERSION_14_1() {
        return MAC_OS_VERSION_14_1;
    }
    private static final int MAC_OS_VERSION_14_2 = (int)140200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_2 140200
     * }
     */
    public static int MAC_OS_VERSION_14_2() {
        return MAC_OS_VERSION_14_2;
    }
    private static final int MAC_OS_VERSION_14_3 = (int)140300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_3 140300
     * }
     */
    public static int MAC_OS_VERSION_14_3() {
        return MAC_OS_VERSION_14_3;
    }
    private static final int MAC_OS_VERSION_14_4 = (int)140400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_4 140400
     * }
     */
    public static int MAC_OS_VERSION_14_4() {
        return MAC_OS_VERSION_14_4;
    }
    private static final int MAC_OS_VERSION_14_5 = (int)140500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_5 140500
     * }
     */
    public static int MAC_OS_VERSION_14_5() {
        return MAC_OS_VERSION_14_5;
    }
    private static final int MAC_OS_VERSION_14_6 = (int)140600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_6 140600
     * }
     */
    public static int MAC_OS_VERSION_14_6() {
        return MAC_OS_VERSION_14_6;
    }
    private static final int MAC_OS_VERSION_14_7 = (int)140700L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_7 140700
     * }
     */
    public static int MAC_OS_VERSION_14_7() {
        return MAC_OS_VERSION_14_7;
    }
    private static final int MAC_OS_VERSION_15_0 = (int)150000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_0 150000
     * }
     */
    public static int MAC_OS_VERSION_15_0() {
        return MAC_OS_VERSION_15_0;
    }
    private static final int MAC_OS_VERSION_15_1 = (int)150100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_1 150100
     * }
     */
    public static int MAC_OS_VERSION_15_1() {
        return MAC_OS_VERSION_15_1;
    }
    private static final int MAC_OS_VERSION_15_2 = (int)150200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_2 150200
     * }
     */
    public static int MAC_OS_VERSION_15_2() {
        return MAC_OS_VERSION_15_2;
    }
    private static final int MAC_OS_VERSION_15_3 = (int)150300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_3 150300
     * }
     */
    public static int MAC_OS_VERSION_15_3() {
        return MAC_OS_VERSION_15_3;
    }
    private static final int MAC_OS_VERSION_15_4 = (int)150400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_4 150400
     * }
     */
    public static int MAC_OS_VERSION_15_4() {
        return MAC_OS_VERSION_15_4;
    }
    private static final int MAC_OS_VERSION_15_5 = (int)150500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_5 150500
     * }
     */
    public static int MAC_OS_VERSION_15_5() {
        return MAC_OS_VERSION_15_5;
    }
    private static final int __AVAILABILITY_VERSIONS_VERSION_HASH = (int)93585900L;
    /**
     * {@snippet lang=c :
     * #define __AVAILABILITY_VERSIONS_VERSION_HASH 93585900
     * }
     */
    public static int __AVAILABILITY_VERSIONS_VERSION_HASH() {
        return __AVAILABILITY_VERSIONS_VERSION_HASH;
    }
    /**
     * {@snippet lang=c :
     * #define __AVAILABILITY_VERSIONS_VERSION_STRING "Local"
     * }
     */
    public static MemorySegment __AVAILABILITY_VERSIONS_VERSION_STRING() {
        class Holder {
            static final MemorySegment __AVAILABILITY_VERSIONS_VERSION_STRING
                = mlx_h.LIBRARY_ARENA.allocateFrom("Local");
        }
        return Holder.__AVAILABILITY_VERSIONS_VERSION_STRING;
    }
    /**
     * {@snippet lang=c :
     * #define __AVAILABILITY_FILE "AvailabilityVersions.h"
     * }
     */
    public static MemorySegment __AVAILABILITY_FILE() {
        class Holder {
            static final MemorySegment __AVAILABILITY_FILE
                = mlx_h.LIBRARY_ARENA.allocateFrom("AvailabilityVersions.h");
        }
        return Holder.__AVAILABILITY_FILE;
    }
    private static final int __MAC_OS_X_VERSION_MIN_REQUIRED = (int)150000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_OS_X_VERSION_MIN_REQUIRED 150000
     * }
     */
    public static int __MAC_OS_X_VERSION_MIN_REQUIRED() {
        return __MAC_OS_X_VERSION_MIN_REQUIRED;
    }
    private static final int __MAC_OS_X_VERSION_MAX_ALLOWED = (int)150500L;
    /**
     * {@snippet lang=c :
     * #define __MAC_OS_X_VERSION_MAX_ALLOWED 150500
     * }
     */
    public static int __MAC_OS_X_VERSION_MAX_ALLOWED() {
        return __MAC_OS_X_VERSION_MAX_ALLOWED;
    }
    private static final int __DARWIN_WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WCHAR_MAX 2147483647
     * }
     */
    public static int __DARWIN_WCHAR_MAX() {
        return __DARWIN_WCHAR_MAX;
    }
    private static final int __DARWIN_WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WCHAR_MIN -2147483648
     * }
     */
    public static int __DARWIN_WCHAR_MIN() {
        return __DARWIN_WCHAR_MIN;
    }
    private static final int __DARWIN_WEOF = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WEOF -1
     * }
     */
    public static int __DARWIN_WEOF() {
        return __DARWIN_WEOF;
    }
    private static final int NSIG = (int)32L;
    /**
     * {@snippet lang=c :
     * #define NSIG 32
     * }
     */
    public static int NSIG() {
        return NSIG;
    }
    private static final int SIGIOT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define SIGIOT 6
     * }
     */
    public static int SIGIOT() {
        return SIGIOT;
    }
    private static final MemorySegment SIG_DFL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define SIG_DFL (void*) 0
     * }
     */
    public static MemorySegment SIG_DFL() {
        return SIG_DFL;
    }
    private static final MemorySegment SIG_IGN = MemorySegment.ofAddress(1L);
    /**
     * {@snippet lang=c :
     * #define SIG_IGN (void*) 1
     * }
     */
    public static MemorySegment SIG_IGN() {
        return SIG_IGN;
    }
    private static final MemorySegment SIG_HOLD = MemorySegment.ofAddress(5L);
    /**
     * {@snippet lang=c :
     * #define SIG_HOLD (void*) 5
     * }
     */
    public static MemorySegment SIG_HOLD() {
        return SIG_HOLD;
    }
    private static final MemorySegment SIG_ERR = MemorySegment.ofAddress(-1L);
    /**
     * {@snippet lang=c :
     * #define SIG_ERR (void*) -1
     * }
     */
    public static MemorySegment SIG_ERR() {
        return SIG_ERR;
    }
    private static final long USER_ADDR_NULL = 0L;
    /**
     * {@snippet lang=c :
     * #define USER_ADDR_NULL 0
     * }
     */
    public static long USER_ADDR_NULL() {
        return USER_ADDR_NULL;
    }
    private static final int SA_USERSPACE_MASK = (int)127L;
    /**
     * {@snippet lang=c :
     * #define SA_USERSPACE_MASK 127
     * }
     */
    public static int SA_USERSPACE_MASK() {
        return SA_USERSPACE_MASK;
    }
    private static final int SV_ONSTACK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SV_ONSTACK 1
     * }
     */
    public static int SV_ONSTACK() {
        return SV_ONSTACK;
    }
    private static final int SV_INTERRUPT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SV_INTERRUPT 2
     * }
     */
    public static int SV_INTERRUPT() {
        return SV_INTERRUPT;
    }
    private static final int SV_RESETHAND = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SV_RESETHAND 4
     * }
     */
    public static int SV_RESETHAND() {
        return SV_RESETHAND;
    }
    private static final int SV_NODEFER = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SV_NODEFER 16
     * }
     */
    public static int SV_NODEFER() {
        return SV_NODEFER;
    }
    private static final int SV_NOCLDSTOP = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SV_NOCLDSTOP 8
     * }
     */
    public static int SV_NOCLDSTOP() {
        return SV_NOCLDSTOP;
    }
    private static final int SV_SIGINFO = (int)64L;
    /**
     * {@snippet lang=c :
     * #define SV_SIGINFO 64
     * }
     */
    public static int SV_SIGINFO() {
        return SV_SIGINFO;
    }
    private static final MemorySegment BADSIG = MemorySegment.ofAddress(-1L);
    /**
     * {@snippet lang=c :
     * #define BADSIG (void*) -1
     * }
     */
    public static MemorySegment BADSIG() {
        return BADSIG;
    }
    private static final int PRIO_MIN = (int)-20L;
    /**
     * {@snippet lang=c :
     * #define PRIO_MIN -20
     * }
     */
    public static int PRIO_MIN() {
        return PRIO_MIN;
    }
    private static final int RUSAGE_CHILDREN = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_CHILDREN -1
     * }
     */
    public static int RUSAGE_CHILDREN() {
        return RUSAGE_CHILDREN;
    }
    private static final int RUSAGE_INFO_CURRENT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_CURRENT 6
     * }
     */
    public static int RUSAGE_INFO_CURRENT() {
        return RUSAGE_INFO_CURRENT;
    }
    private static final long RLIM_INFINITY = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RLIM_INFINITY 9223372036854775807
     * }
     */
    public static long RLIM_INFINITY() {
        return RLIM_INFINITY;
    }
    private static final long RLIM_SAVED_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RLIM_SAVED_MAX 9223372036854775807
     * }
     */
    public static long RLIM_SAVED_MAX() {
        return RLIM_SAVED_MAX;
    }
    private static final long RLIM_SAVED_CUR = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RLIM_SAVED_CUR 9223372036854775807
     * }
     */
    public static long RLIM_SAVED_CUR() {
        return RLIM_SAVED_CUR;
    }
    private static final int RLIMIT_RSS = (int)5L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_RSS 5
     * }
     */
    public static int RLIMIT_RSS() {
        return RLIMIT_RSS;
    }
    private static final int IOPOL_APPLICATION = (int)5L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_APPLICATION 5
     * }
     */
    public static int IOPOL_APPLICATION() {
        return IOPOL_APPLICATION;
    }
    private static final int IOPOL_NORMAL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_NORMAL 1
     * }
     */
    public static int IOPOL_NORMAL() {
        return IOPOL_NORMAL;
    }
    private static final int WAIT_ANY = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define WAIT_ANY -1
     * }
     */
    public static int WAIT_ANY() {
        return WAIT_ANY;
    }
    private static final int LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define LITTLE_ENDIAN 1234
     * }
     */
    public static int LITTLE_ENDIAN() {
        return LITTLE_ENDIAN;
    }
    private static final int BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define BIG_ENDIAN 4321
     * }
     */
    public static int BIG_ENDIAN() {
        return BIG_ENDIAN;
    }
    private static final int PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define PDP_ENDIAN 3412
     * }
     */
    public static int PDP_ENDIAN() {
        return PDP_ENDIAN;
    }
    private static final int __DARWIN_BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_BYTE_ORDER 1234
     * }
     */
    public static int __DARWIN_BYTE_ORDER() {
        return __DARWIN_BYTE_ORDER;
    }
    private static final int BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define BYTE_ORDER 1234
     * }
     */
    public static int BYTE_ORDER() {
        return BYTE_ORDER;
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final int EOF = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define EOF -1
     * }
     */
    public static int EOF() {
        return EOF;
    }
    /**
     * {@snippet lang=c :
     * #define P_tmpdir "/var/tmp/"
     * }
     */
    public static MemorySegment P_tmpdir() {
        class Holder {
            static final MemorySegment P_tmpdir
                = mlx_h.LIBRARY_ARENA.allocateFrom("/var/tmp/");
        }
        return Holder.P_tmpdir;
    }
}

