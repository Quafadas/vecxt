// Generated by jextract

package blas;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class cblas_h extends cblas_h$shared {

    cblas_h() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup("/opt/homebrew/Cellar/openblas/0.3.30/lib/libopenblas.dylib", LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    private static final int CblasRowMajor = (int)101L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_ORDER.CblasRowMajor = 101
     * }
     */
    public static int CblasRowMajor() {
        return CblasRowMajor;
    }
    private static final int CblasColMajor = (int)102L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_ORDER.CblasColMajor = 102
     * }
     */
    public static int CblasColMajor() {
        return CblasColMajor;
    }
    private static final int CblasNoTrans = (int)111L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_TRANSPOSE.CblasNoTrans = 111
     * }
     */
    public static int CblasNoTrans() {
        return CblasNoTrans;
    }
    private static final int CblasTrans = (int)112L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_TRANSPOSE.CblasTrans = 112
     * }
     */
    public static int CblasTrans() {
        return CblasTrans;
    }
    private static final int CblasConjTrans = (int)113L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_TRANSPOSE.CblasConjTrans = 113
     * }
     */
    public static int CblasConjTrans() {
        return CblasConjTrans;
    }
    private static final int CblasConjNoTrans = (int)114L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_TRANSPOSE.CblasConjNoTrans = 114
     * }
     */
    public static int CblasConjNoTrans() {
        return CblasConjNoTrans;
    }
    private static final int CblasUpper = (int)121L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_UPLO.CblasUpper = 121
     * }
     */
    public static int CblasUpper() {
        return CblasUpper;
    }
    private static final int CblasLower = (int)122L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_UPLO.CblasLower = 122
     * }
     */
    public static int CblasLower() {
        return CblasLower;
    }
    private static final int CblasNonUnit = (int)131L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_DIAG.CblasNonUnit = 131
     * }
     */
    public static int CblasNonUnit() {
        return CblasNonUnit;
    }
    private static final int CblasUnit = (int)132L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_DIAG.CblasUnit = 132
     * }
     */
    public static int CblasUnit() {
        return CblasUnit;
    }
    private static final int CblasLeft = (int)141L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_SIDE.CblasLeft = 141
     * }
     */
    public static int CblasLeft() {
        return CblasLeft;
    }
    private static final int CblasRight = (int)142L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_SIDE.CblasRight = 142
     * }
     */
    public static int CblasRight() {
        return CblasRight;
    }

    private static class cblas_dgemv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cblas_dgemv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const double alpha, const double *a, const blasint lda, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_dgemv$descriptor() {
        return cblas_dgemv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const double alpha, const double *a, const blasint lda, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_dgemv$handle() {
        return cblas_dgemv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const double alpha, const double *a, const blasint lda, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_dgemv$address() {
        return cblas_dgemv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const double alpha, const double *a, const blasint lda, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static void cblas_dgemv(int order, int trans, int m, int n, double alpha, MemorySegment a, int lda, MemorySegment x, int incx, double beta, MemorySegment y, int incy) {
        var mh$ = cblas_dgemv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dgemv", order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
            }
            mh$.invokeExact(order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dgemm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cblas_dgemm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_dgemm$descriptor() {
        return cblas_dgemm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_dgemm$handle() {
        return cblas_dgemm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_dgemm$address() {
        return cblas_dgemm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static void cblas_dgemm(int Order, int TransA, int TransB, int M, int N, int K, double alpha, MemorySegment A, int lda, MemorySegment B, int ldb, double beta, MemorySegment C, int ldc) {
        var mh$ = cblas_dgemm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dgemm", Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dgemmt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cblas_dgemmt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dgemmt(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_dgemmt$descriptor() {
        return cblas_dgemmt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dgemmt(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_dgemmt$handle() {
        return cblas_dgemmt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dgemmt(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_dgemmt$address() {
        return cblas_dgemmt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dgemmt(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static void cblas_dgemmt(int Order, int Uplo, int TransA, int TransB, int M, int K, double alpha, MemorySegment A, int lda, MemorySegment B, int ldb, double beta, MemorySegment C, int ldc) {
        var mh$ = cblas_dgemmt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dgemmt", Order, Uplo, TransA, TransB, M, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, TransA, TransB, M, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dgemm_batch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cblas_dgemm_batch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dgemm_batch(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE *TransA_array, const enum CBLAS_TRANSPOSE *TransB_array, const blasint *M_array, const blasint *N_array, const blasint *K_array, const double *alpha_array, const double **A_array, const blasint *lda_array, const double **B_array, const blasint *ldb_array, const double *beta_array, double **C_array, const blasint *ldc_array, const blasint group_count, const blasint *group_size)
     * }
     */
    public static FunctionDescriptor cblas_dgemm_batch$descriptor() {
        return cblas_dgemm_batch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dgemm_batch(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE *TransA_array, const enum CBLAS_TRANSPOSE *TransB_array, const blasint *M_array, const blasint *N_array, const blasint *K_array, const double *alpha_array, const double **A_array, const blasint *lda_array, const double **B_array, const blasint *ldb_array, const double *beta_array, double **C_array, const blasint *ldc_array, const blasint group_count, const blasint *group_size)
     * }
     */
    public static MethodHandle cblas_dgemm_batch$handle() {
        return cblas_dgemm_batch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dgemm_batch(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE *TransA_array, const enum CBLAS_TRANSPOSE *TransB_array, const blasint *M_array, const blasint *N_array, const blasint *K_array, const double *alpha_array, const double **A_array, const blasint *lda_array, const double **B_array, const blasint *ldb_array, const double *beta_array, double **C_array, const blasint *ldc_array, const blasint group_count, const blasint *group_size)
     * }
     */
    public static MemorySegment cblas_dgemm_batch$address() {
        return cblas_dgemm_batch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dgemm_batch(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE *TransA_array, const enum CBLAS_TRANSPOSE *TransB_array, const blasint *M_array, const blasint *N_array, const blasint *K_array, const double *alpha_array, const double **A_array, const blasint *lda_array, const double **B_array, const blasint *ldb_array, const double *beta_array, double **C_array, const blasint *ldc_array, const blasint group_count, const blasint *group_size)
     * }
     */
    public static void cblas_dgemm_batch(int Order, MemorySegment TransA_array, MemorySegment TransB_array, MemorySegment M_array, MemorySegment N_array, MemorySegment K_array, MemorySegment alpha_array, MemorySegment A_array, MemorySegment lda_array, MemorySegment B_array, MemorySegment ldb_array, MemorySegment beta_array, MemorySegment C_array, MemorySegment ldc_array, int group_count, MemorySegment group_size) {
        var mh$ = cblas_dgemm_batch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dgemm_batch", Order, TransA_array, TransB_array, M_array, N_array, K_array, alpha_array, A_array, lda_array, B_array, ldb_array, beta_array, C_array, ldc_array, group_count, group_size);
            }
            mh$.invokeExact(Order, TransA_array, TransB_array, M_array, N_array, K_array, alpha_array, A_array, lda_array, B_array, ldb_array, beta_array, C_array, ldc_array, group_count, group_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

